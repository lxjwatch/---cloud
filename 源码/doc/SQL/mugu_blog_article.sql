
SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article`  (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `article_id` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '唯一ID',
  `author_id` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '作者userid',
  `type_id` bigint(11) NULL DEFAULT NULL COMMENT '分类ID',
  `title` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '标题',
  `content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL COMMENT '内容',
  `describe` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '摘要',
  `source` int(1) NULL DEFAULT NULL COMMENT '来源：1 原创 2 转载 3 翻译',
  `view_num` bigint(11) NULL DEFAULT 0 COMMENT '阅读人数',
  `img_url` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '文章首图链接',
  `is_recommend` int(1) NULL DEFAULT 0 COMMENT '是否推荐 1 推荐 0 不推荐',
  `is_explain` int(1) NULL DEFAULT 0 COMMENT '转载说明 1 说明 0 不说明',
  `is_appreciate` int(1) NULL DEFAULT 1 COMMENT '是否赞赏',
  `is_comment` int(1) NULL DEFAULT 1 COMMENT '是否评论 ',
  `status` int(1) NULL DEFAULT 1 COMMENT '状态 1 已保存 2 已发布 0 删除',
  `create_time` datetime(0) NULL DEFAULT NULL,
  `update_time` timestamp(0) NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP(0),
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `article_id`(`article_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 13 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '文章' ROW_FORMAT = Compact;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES (1, '552893733540986880', '94dd9d02befd4dac9d6e708ff92f7d82', 3, 'Spring Cloud 再爆高危漏洞.... 赶紧修复！！', '<p><strong>大家好，我是不才陈某~</strong></p>\n<p>Log4j2 的核弹级漏洞刚告一段落，<strong>Spring Cloud Gateway</strong> 又突发高危漏洞，又得折腾了。。。</p>\n<p>2022年3月1日，Spring官方发布了关于Spring Cloud Gateway的两个CVE漏洞，分别为<strong>CVE-2022-22946</strong>与<strong>CVE-2022-22947</strong>：</p>\n<p><strong>版本/分支/tag： 3.4.X</strong><br><strong>问题描述</strong>：</p>\n<p><strong><img src=\"https://mmbiz.qpic.cn/mmbiz_png/AokYxdF6ctt1NeiayJzDScfIZZrNMaNAkIgMQMKP9OLVWa4hv9WFfXnfYjMLy4WAib31FW8cXMZ2BVSoYuYAia7EQ/640?wx_fmt=png\" alt=\"\"></strong></p>\n<p>Spring Cloud Gateway 是 Spring Cloud 下的一个项目，该项目是基于 Spring 5.0、Spring Boot 2.0 和 Project Reactor 等技术开发的网关，它旨在为微服务架构提供一种简单有效、统一的 API 路由管理方式。</p>\n<h2 id=\"h2--strong-1-strong-spring-cloud-gateway-cve-2022-22947-\"><a name=\"<strong>漏洞1</strong>：Spring Cloud Gateway 远程代码执行漏洞（CVE-2022-22947）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><strong>漏洞1</strong>：Spring Cloud Gateway 远程代码执行漏洞（CVE-2022-22947）</h2><p>3 月 1 日，VMware 官方发布安全公告，声明对 Spring Cloud Gateway 中的一处命令注入漏洞进行了修复，漏洞编号为 CVE-2022-22947：</p>\n<p><a href=\"https://tanzu.vmware.com/security/cve-2022-22947\">https://tanzu.vmware.com/security/cve-2022-22947</a></p>\n<p><strong>漏洞描述</strong></p>\n<p>使用 Spring Cloud Gateway 的应用如果对外暴露了 Gateway Actuator 端点时，则可能存在被 CVE-2022-22947 漏洞利用的风险。攻击者可通过利用此漏洞执行 SpEL 表达式，允许在远程主机上进行任意远程执行。，获取系统权限。</p>\n<p><strong>影响范围</strong></p>\n<p>漏洞利用的前置条件：</p>\n<ol>\n<li>除了 Spring Cloud Gateway 外，程序还用到了 Spring Boot Actuator 组件（它用于对外提供 /actuator/ 接口）；</li><li>Spring 配置对外暴露 gateway 接口，如 application.properties 配置为：</li></ol>\n<pre><code class=\"lang-properties\"># 默认为true\nmanagement.endpoint.gateway.enabled=true\n# 以逗号分隔的一系列值，默认为 health# 若包含 gateway 即表示对外提供 Spring Cloud Gateway 接口\nmanagement.endpoints.web.exposure.include=gateway\n</code></pre>\n<p>漏洞影响的 Spring Cloud Gateway 版本范围：</p>\n<ul>\n<li>Spring Cloud Gateway 3.1.x &lt; 3.1.1</li><li>Spring Cloud Gateway 3.0.x &lt; 3.0.7</li><li>其他旧的、不受支持的 Spring Cloud Gateway 版本</li></ul>\n<p><strong>解决方案</strong></p>\n<p>更新升级 Spring Cloud Gateway 到以下安全版本：</p>\n<ul>\n<li>Spring Cloud Gateway 3.1.1</li><li>Spring Cloud Gateway 3.0.7</li></ul>\n<p>或者在不考虑影响业务的情况下禁用 Gateway actuator 接口：</p>\n<p>在application.properties 中设置 ：</p>\n<pre><code class=\"lang-properties\">management.endpoint.gateway.enabled 为 false。\n</code></pre>\n<h2 id=\"h2--strong-2-strong-cve-2022-22946-spring-cloud-gateway-http2-trustmanager\"><a name=\"<strong>漏洞2</strong>：CVE-2022-22946：Spring Cloud Gateway HTTP2 不安全的 TrustManager\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><strong>漏洞2</strong>：CVE-2022-22946：Spring Cloud Gateway HTTP2 不安全的 TrustManager</h2><p><strong>漏洞描述</strong></p>\n<p>使用配置为启用 HTTP2 且未设置密钥存储或受信任证书的 Spring Cloud Gateway 的应用程序将被配置为使用不安全的 TrustManager。这使得网关能够使用无效或自定义证书连接到远程服务。</p>\n<p><strong>影响范围</strong></p>\n<p>Spring Cloud Gateway = 3.1.0</p>\n<p><strong>解决方案</strong></p>\n<p>官方已经发布安全版本，请升级到3.1.1+</p>\n<p><strong>参考资料</strong></p>\n<p>官方已经发布安全版本，请升级到3.1.1+</p>\n<ul>\n<li><a href=\"https://tanzu.vmware.com/security/cve-2022-22946\">https://tanzu.vmware.com/security/cve-2022-22946</a></li><li><a href=\"https://tanzu.vmware.com/security/cve-2022-22947\">https://tanzu.vmware.com/security/cve-2022-22947</a></li></ul>\n', 'Spring Cloud 再爆高危漏洞.... 赶紧修复！！', 1, 0, 'https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%BC%98%E8%B4%A8%E8%A7%86%E9%A2%91%E8%B5%84%E6%BA%90/1.png', 1, 1, 1, 1, 0, '2022-03-06 16:42:18', '2022-03-06 17:11:37');
INSERT INTO `article` VALUES (2, '552903405278855168', '94dd9d02befd4dac9d6e708ff92f7d82', 3, 'Spring Cloud 再爆高危漏洞.... 赶紧修复！！', '<p><strong>大家好，我是不才陈某~</strong></p>\n<p>Log4j2 的核弹级漏洞刚告一段落，<strong>Spring Cloud Gateway</strong> 又突发高危漏洞，又得折腾了。。。</p>\n<p>2022年3月1日，Spring官方发布了关于Spring Cloud Gateway的两个CVE漏洞，分别为<strong>CVE-2022-22946</strong>与<strong>CVE-2022-22947</strong>：</p>\n<p><strong>版本/分支/tag： 3.4.X</strong><br><strong>问题描述</strong>：</p>\n<p><strong><img src=\"https://mmbiz.qpic.cn/mmbiz_png/AokYxdF6ctt1NeiayJzDScfIZZrNMaNAkIgMQMKP9OLVWa4hv9WFfXnfYjMLy4WAib31FW8cXMZ2BVSoYuYAia7EQ/640?wx_fmt=png\" alt=\"\"></strong></p>\n<p>Spring Cloud Gateway 是 Spring Cloud 下的一个项目，该项目是基于 Spring 5.0、Spring Boot 2.0 和 Project Reactor 等技术开发的网关，它旨在为微服务架构提供一种简单有效、统一的 API 路由管理方式。</p>\n<h2 id=\"h2--strong-1-strong-spring-cloud-gateway-cve-2022-22947-\"><a name=\"<strong>漏洞1</strong>：Spring Cloud Gateway 远程代码执行漏洞（CVE-2022-22947）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><strong>漏洞1</strong>：Spring Cloud Gateway 远程代码执行漏洞（CVE-2022-22947）</h2><p>3 月 1 日，VMware 官方发布安全公告，声明对 Spring Cloud Gateway 中的一处命令注入漏洞进行了修复，漏洞编号为 CVE-2022-22947：</p>\n<p><a href=\"https://tanzu.vmware.com/security/cve-2022-22947\">https://tanzu.vmware.com/security/cve-2022-22947</a></p>\n<p><strong>漏洞描述</strong></p>\n<p>使用 Spring Cloud Gateway 的应用如果对外暴露了 Gateway Actuator 端点时，则可能存在被 CVE-2022-22947 漏洞利用的风险。攻击者可通过利用此漏洞执行 SpEL 表达式，允许在远程主机上进行任意远程执行。，获取系统权限。</p>\n<p><strong>影响范围</strong></p>\n<p>漏洞利用的前置条件：</p>\n<ol>\n<li>除了 Spring Cloud Gateway 外，程序还用到了 Spring Boot Actuator 组件（它用于对外提供 /actuator/ 接口）；</li><li>Spring 配置对外暴露 gateway 接口，如 application.properties 配置为：</li></ol>\n<pre><code class=\"lang-properties\"># 默认为true\nmanagement.endpoint.gateway.enabled=true\n# 以逗号分隔的一系列值，默认为 health# 若包含 gateway 即表示对外提供 Spring Cloud Gateway 接口\nmanagement.endpoints.web.exposure.include=gateway\n</code></pre>\n<p>漏洞影响的 Spring Cloud Gateway 版本范围：</p>\n<ul>\n<li>Spring Cloud Gateway 3.1.x &lt; 3.1.1</li><li>Spring Cloud Gateway 3.0.x &lt; 3.0.7</li><li>其他旧的、不受支持的 Spring Cloud Gateway 版本</li></ul>\n<p><strong>解决方案</strong></p>\n<p>更新升级 Spring Cloud Gateway 到以下安全版本：</p>\n<ul>\n<li>Spring Cloud Gateway 3.1.1</li><li>Spring Cloud Gateway 3.0.7</li></ul>\n<p>或者在不考虑影响业务的情况下禁用 Gateway actuator 接口：</p>\n<p>在application.properties 中设置 ：</p>\n<pre><code class=\"lang-properties\">management.endpoint.gateway.enabled 为 false。\n</code></pre>\n<h2 id=\"h2--strong-2-strong-cve-2022-22946-spring-cloud-gateway-http2-trustmanager\"><a name=\"<strong>漏洞2</strong>：CVE-2022-22946：Spring Cloud Gateway HTTP2 不安全的 TrustManager\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><strong>漏洞2</strong>：CVE-2022-22946：Spring Cloud Gateway HTTP2 不安全的 TrustManager</h2><p><strong>漏洞描述</strong></p>\n<p>使用配置为启用 HTTP2 且未设置密钥存储或受信任证书的 Spring Cloud Gateway 的应用程序将被配置为使用不安全的 TrustManager。这使得网关能够使用无效或自定义证书连接到远程服务。</p>\n<p><strong>影响范围</strong></p>\n<p>Spring Cloud Gateway = 3.1.0</p>\n<p><strong>解决方案</strong></p>\n<p>官方已经发布安全版本，请升级到3.1.1+</p>\n<p><strong>参考资料</strong></p>\n<p>官方已经发布安全版本，请升级到3.1.1+</p>\n<ul>\n<li><a href=\"https://tanzu.vmware.com/security/cve-2022-22946\">https://tanzu.vmware.com/security/cve-2022-22946</a></li><li><a href=\"https://tanzu.vmware.com/security/cve-2022-22947\">https://tanzu.vmware.com/security/cve-2022-22947</a></li></ul>\n', 'Spring Cloud 再爆高危漏洞.... 赶紧修复！！', 1, 0, 'https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%BC%98%E8%B4%A8%E8%A7%86%E9%A2%91%E8%B5%84%E6%BA%90/1.png', 1, 1, 1, 1, 0, '2022-03-06 17:20:44', '2022-03-06 17:22:09');
INSERT INTO `article` VALUES (3, '552903693322682368', '94dd9d02befd4dac9d6e708ff92f7d82', 3, 'Spring Cloud 再爆高危漏洞.... 赶紧修复！！', '<p><strong>大家好，我是不才陈某~</strong></p>\n<p>Log4j2 的核弹级漏洞刚告一段落，<strong>Spring Cloud Gateway</strong> 又突发高危漏洞，又得折腾了。。。</p>\n<p>2022年3月1日，Spring官方发布了关于Spring Cloud Gateway的两个CVE漏洞，分别为<strong>CVE-2022-22946</strong>与<strong>CVE-2022-22947</strong>：</p>\n<p><strong>版本/分支/tag： 3.4.X</strong><br><strong>问题描述</strong>：</p>\n<p><strong><img src=\"https://mmbiz.qpic.cn/mmbiz_png/AokYxdF6ctt1NeiayJzDScfIZZrNMaNAkIgMQMKP9OLVWa4hv9WFfXnfYjMLy4WAib31FW8cXMZ2BVSoYuYAia7EQ/640?wx_fmt=png\" alt=\"\"></strong></p>\n<p>Spring Cloud Gateway 是 Spring Cloud 下的一个项目，该项目是基于 Spring 5.0、Spring Boot 2.0 和 Project Reactor 等技术开发的网关，它旨在为微服务架构提供一种简单有效、统一的 API 路由管理方式。</p>\n<h2 id=\"h2--strong-1-strong-spring-cloud-gateway-cve-2022-22947-\"><a name=\"<strong>漏洞1</strong>：Spring Cloud Gateway 远程代码执行漏洞（CVE-2022-22947）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><strong>漏洞1</strong>：Spring Cloud Gateway 远程代码执行漏洞（CVE-2022-22947）</h2><p>3 月 1 日，VMware 官方发布安全公告，声明对 Spring Cloud Gateway 中的一处命令注入漏洞进行了修复，漏洞编号为 CVE-2022-22947：</p>\n<p><a href=\"https://tanzu.vmware.com/security/cve-2022-22947\">https://tanzu.vmware.com/security/cve-2022-22947</a></p>\n<p><strong>漏洞描述</strong></p>\n<p>使用 Spring Cloud Gateway 的应用如果对外暴露了 Gateway Actuator 端点时，则可能存在被 CVE-2022-22947 漏洞利用的风险。攻击者可通过利用此漏洞执行 SpEL 表达式，允许在远程主机上进行任意远程执行。，获取系统权限。</p>\n<p><strong>影响范围</strong></p>\n<p>漏洞利用的前置条件：</p>\n<ol>\n<li>除了 Spring Cloud Gateway 外，程序还用到了 Spring Boot Actuator 组件（它用于对外提供 /actuator/ 接口）；</li><li>Spring 配置对外暴露 gateway 接口，如 application.properties 配置为：</li></ol>\n<pre><code class=\"lang-properties\"># 默认为true\nmanagement.endpoint.gateway.enabled=true\n# 以逗号分隔的一系列值，默认为 health# 若包含 gateway 即表示对外提供 Spring Cloud Gateway 接口\nmanagement.endpoints.web.exposure.include=gateway\n</code></pre>\n<p>漏洞影响的 Spring Cloud Gateway 版本范围：</p>\n<ul>\n<li>Spring Cloud Gateway 3.1.x &lt; 3.1.1</li><li>Spring Cloud Gateway 3.0.x &lt; 3.0.7</li><li>其他旧的、不受支持的 Spring Cloud Gateway 版本</li></ul>\n<p><strong>解决方案</strong></p>\n<p>更新升级 Spring Cloud Gateway 到以下安全版本：</p>\n<ul>\n<li>Spring Cloud Gateway 3.1.1</li><li>Spring Cloud Gateway 3.0.7</li></ul>\n<p>或者在不考虑影响业务的情况下禁用 Gateway actuator 接口：</p>\n<p>在application.properties 中设置 ：</p>\n<pre><code class=\"lang-properties\">management.endpoint.gateway.enabled 为 false。\n</code></pre>\n<h2 id=\"h2--strong-2-strong-cve-2022-22946-spring-cloud-gateway-http2-trustmanager\"><a name=\"<strong>漏洞2</strong>：CVE-2022-22946：Spring Cloud Gateway HTTP2 不安全的 TrustManager\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><strong>漏洞2</strong>：CVE-2022-22946：Spring Cloud Gateway HTTP2 不安全的 TrustManager</h2><p><strong>漏洞描述</strong></p>\n<p>使用配置为启用 HTTP2 且未设置密钥存储或受信任证书的 Spring Cloud Gateway 的应用程序将被配置为使用不安全的 TrustManager。这使得网关能够使用无效或自定义证书连接到远程服务。</p>\n<p><strong>影响范围</strong></p>\n<p>Spring Cloud Gateway = 3.1.0</p>\n<p><strong>解决方案</strong></p>\n<p>官方已经发布安全版本，请升级到3.1.1+</p>\n<p><strong>参考资料</strong></p>\n<p>官方已经发布安全版本，请升级到3.1.1+</p>\n<ul>\n<li><a href=\"https://tanzu.vmware.com/security/cve-2022-22946\">https://tanzu.vmware.com/security/cve-2022-22946</a></li><li><a href=\"https://tanzu.vmware.com/security/cve-2022-22947\">https://tanzu.vmware.com/security/cve-2022-22947</a></li></ul>\n', 'Spring Cloud 再爆高危漏洞.... 赶紧修复！！', 1, 0, 'https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%BC%98%E8%B4%A8%E8%A7%86%E9%A2%91%E8%B5%84%E6%BA%90/1.png', 1, 1, 1, 1, 0, '2022-03-06 17:21:53', '2022-03-06 17:23:26');
INSERT INTO `article` VALUES (4, '552903982717075456', '94dd9d02befd4dac9d6e708ff92f7d82', 3, 'Spring Cloud 再爆高危漏洞.... 赶紧修复！！', '<p><strong>大家好，我是不才陈某~</strong></p>\n<p>Log4j2 的核弹级漏洞刚告一段落，<strong>Spring Cloud Gateway</strong> 又突发高危漏洞，又得折腾了。。。</p>\n<p>2022年3月1日，Spring官方发布了关于Spring Cloud Gateway的两个CVE漏洞，分别为<strong>CVE-2022-22946</strong>与<strong>CVE-2022-22947</strong>：</p>\n<p><strong>版本/分支/tag： 3.4.X</strong><br><strong>问题描述</strong>：</p>\n<p><strong><img src=\"https://mmbiz.qpic.cn/mmbiz_png/AokYxdF6ctt1NeiayJzDScfIZZrNMaNAkIgMQMKP9OLVWa4hv9WFfXnfYjMLy4WAib31FW8cXMZ2BVSoYuYAia7EQ/640?wx_fmt=png\" alt=\"\"></strong></p>\n<p>Spring Cloud Gateway 是 Spring Cloud 下的一个项目，该项目是基于 Spring 5.0、Spring Boot 2.0 和 Project Reactor 等技术开发的网关，它旨在为微服务架构提供一种简单有效、统一的 API 路由管理方式。</p>\n<h2 id=\"h2--strong-1-strong-spring-cloud-gateway-cve-2022-22947-\"><a name=\"<strong>漏洞1</strong>：Spring Cloud Gateway 远程代码执行漏洞（CVE-2022-22947）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><strong>漏洞1</strong>：Spring Cloud Gateway 远程代码执行漏洞（CVE-2022-22947）</h2><p>3 月 1 日，VMware 官方发布安全公告，声明对 Spring Cloud Gateway 中的一处命令注入漏洞进行了修复，漏洞编号为 CVE-2022-22947：</p>\n<p><a href=\"https://tanzu.vmware.com/security/cve-2022-22947\">https://tanzu.vmware.com/security/cve-2022-22947</a></p>\n<p><strong>漏洞描述</strong></p>\n<p>使用 Spring Cloud Gateway 的应用如果对外暴露了 Gateway Actuator 端点时，则可能存在被 CVE-2022-22947 漏洞利用的风险。攻击者可通过利用此漏洞执行 SpEL 表达式，允许在远程主机上进行任意远程执行。，获取系统权限。</p>\n<p><strong>影响范围</strong></p>\n<p>漏洞利用的前置条件：</p>\n<ol>\n<li>除了 Spring Cloud Gateway 外，程序还用到了 Spring Boot Actuator 组件（它用于对外提供 /actuator/ 接口）；</li><li>Spring 配置对外暴露 gateway 接口，如 application.properties 配置为：</li></ol>\n<pre><code class=\"lang-properties\"># 默认为true\nmanagement.endpoint.gateway.enabled=true\n# 以逗号分隔的一系列值，默认为 health# 若包含 gateway 即表示对外提供 Spring Cloud Gateway 接口\nmanagement.endpoints.web.exposure.include=gateway\n</code></pre>\n<p>漏洞影响的 Spring Cloud Gateway 版本范围：</p>\n<ul>\n<li>Spring Cloud Gateway 3.1.x &lt; 3.1.1</li><li>Spring Cloud Gateway 3.0.x &lt; 3.0.7</li><li>其他旧的、不受支持的 Spring Cloud Gateway 版本</li></ul>\n<p><strong>解决方案</strong></p>\n<p>更新升级 Spring Cloud Gateway 到以下安全版本：</p>\n<ul>\n<li>Spring Cloud Gateway 3.1.1</li><li>Spring Cloud Gateway 3.0.7</li></ul>\n<p>或者在不考虑影响业务的情况下禁用 Gateway actuator 接口：</p>\n<p>在application.properties 中设置 ：</p>\n<pre><code class=\"lang-properties\">management.endpoint.gateway.enabled 为 false。\n</code></pre>\n<h2 id=\"h2--strong-2-strong-cve-2022-22946-spring-cloud-gateway-http2-trustmanager\"><a name=\"<strong>漏洞2</strong>：CVE-2022-22946：Spring Cloud Gateway HTTP2 不安全的 TrustManager\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><strong>漏洞2</strong>：CVE-2022-22946：Spring Cloud Gateway HTTP2 不安全的 TrustManager</h2><p><strong>漏洞描述</strong></p>\n<p>使用配置为启用 HTTP2 且未设置密钥存储或受信任证书的 Spring Cloud Gateway 的应用程序将被配置为使用不安全的 TrustManager。这使得网关能够使用无效或自定义证书连接到远程服务。</p>\n<p><strong>影响范围</strong></p>\n<p>Spring Cloud Gateway = 3.1.0</p>\n<p><strong>解决方案</strong></p>\n<p>官方已经发布安全版本，请升级到3.1.1+</p>\n<p><strong>参考资料</strong></p>\n<p>官方已经发布安全版本，请升级到3.1.1+</p>\n<ul>\n<li><a href=\"https://tanzu.vmware.com/security/cve-2022-22946\">https://tanzu.vmware.com/security/cve-2022-22946</a></li><li><a href=\"https://tanzu.vmware.com/security/cve-2022-22947\">https://tanzu.vmware.com/security/cve-2022-22947</a></li></ul>\n', 'Spring Cloud 再爆高危漏洞.... 赶紧修复！！', 1, 0, 'https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%BC%98%E8%B4%A8%E8%A7%86%E9%A2%91%E8%B5%84%E6%BA%90/1.png', 1, 1, 1, 1, 2, '2022-03-06 17:23:02', '2022-03-06 17:23:02');
INSERT INTO `article` VALUES (5, '552917751014883328', '94dd9d02befd4dac9d6e708ff92f7d82', 3, 'Spring Cloud 自定义授权模式', '<p><strong>大家好，我是不才陈某~</strong></p>\n<p>这是<a href=\"https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&amp;action=getalbum&amp;album_id=2042874937312346114&amp;scene=126#wechat_redirect\">《Spring Cloud 进阶》</a>第<strong>24</strong>篇文章，往期文章如下：</p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247493854&amp;idx=1&amp;sn=4b3fb7f7e17a76000733899f511ef915&amp;scene=21#wechat_redirect\">五十五张图告诉你微服务的灵魂摆渡者Nacos究竟有多强？</a></li><li><a href=\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247496653&amp;idx=1&amp;sn=7185077b3bdc1d094aef645d677ec472&amp;scene=21#wechat_redirect\">openFeign夺命连环9问，这谁受得了？</a></li><li><a href=\"https://mp.weixin.qq.com/s/S_8HQYHOG624Vzeu94CFSA\">阿里面试这样问：Nacos、Apollo、Config配置中心如何选型？这10个维度告诉你！</a></li><li><a href=\"https://mp.weixin.qq.com/s/YKzYdMu-7nwszEf9-1M3Uw\">阿里面试败北：5种微服务注册中心如何选型？这几个维度告诉你！</a></li><li><a href=\"https://mp.weixin.qq.com/s/Q7Xv8cypQFrrOQhbd9BOXw\">阿里限流神器Sentinel夺命连环 17 问？</a></li><li><a href=\"https://mp.weixin.qq.com/s/sXVSFqq2UZ6Pwwt7vx7vIA\">对比7种分布式事务方案，还是偏爱阿里开源的Seata，真香！(原理+实战)</a></li><li><a href=\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247499894&amp;idx=1&amp;sn=f1606e4c00fd15292269afe052f5bca2&amp;chksm=fcf71fbbcb8096ad349e6da50b0b9141964c2084d0a38eba977fe8baa3fbe8af3b20c7591110&amp;token=1887105114&amp;lang=zh_CN#rd\">Spring Cloud Gateway夺命连环10问？</a></li><li><a href=\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247500540&amp;idx=1&amp;sn=2967bf1f9fa2c4d5b94b7fe291b7869b&amp;chksm=fcf71d31cb8094271b5bbeca85cc03cf7d7c8bbf7c4d5b83a539e39c956e3f4015f91e7742b6&amp;token=2077958771&amp;lang=zh_CN#rd\">Spring Cloud Gateway 整合阿里 Sentinel网关限流实战！</a></li><li><a href=\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247500757&amp;idx=1&amp;sn=ef71f10d5736029c92287f7894c842ed&amp;chksm=fcf71c18cb80950ec3144d66957a9d2914b51b8af22cf59a1ca3f9e2b561a11aca359d50d5a1&amp;scene=178&amp;cur_album_id=2042874937312346114#rd\">分布式链路追踪之Spring Cloud Sleuth夺命连环9问？</a></li><li><a href=\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247501079&amp;idx=1&amp;sn=438ef3a3d65fb4919b61cf6972827bec&amp;chksm=fcf71adacb8093ccc4c3d6dfb8860ca07aefbc761c1ed5126eb4a4e87548441841198db1f8e3&amp;scene=178&amp;cur_album_id=2042874937312346114#rd\">链路追踪自从用了SkyWalking，睡的真香！</a></li><li><a href=\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247501590&amp;idx=1&amp;sn=149d1498504cda7cc391413f14cda9c2&amp;chksm=fcf718dbcb8091cd6907e86e148216bae0a2d5b1664b1e8cc2d3e2c96c38181cc778de5711b6&amp;scene=178&amp;cur_album_id=2042874937312346114#rd\">3本书了，7万+字，10篇文章，《Spring Cloud 进阶》基础版 PDF</a></li><li><a href=\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247502682&amp;idx=1&amp;sn=52a15b623ab6135c134b8262bd605946&amp;chksm=fcf71497cb809d81f1d2dbce76b3e00170f085306b2a2a67a807a6d9e2cf03bf1de3b8f203a2&amp;scene=178&amp;cur_album_id=2042874937312346114#rd\">妹子始终没搞懂OAuth2.0，今天整合Spring Cloud Security 一次说明白！</a></li><li><a href=\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247502801&amp;idx=1&amp;sn=56b1af09bfa25d5e44193a7d75dfa623&amp;chksm=fcf7141ccb809d0a1b0b2d7f6d9893c7d3e560dd8996296276f0274d2578236ee87e9124810d&amp;scene=178&amp;cur_album_id=2042874937312346114#rd\">OAuth2.0实战！使用JWT令牌认证！</a></li><li><a href=\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247502905&amp;idx=1&amp;sn=32ba3ae4e0a4097d238f64719c88b7f7&amp;chksm=fcf713f4cb809ae2ccb706b8e9f8184739d3c7b97d388467bfe9ff31a8c15768b6de05054f08&amp;scene=178&amp;cur_album_id=2042874937312346114#rd\">OAuth2.0实战！玩转认证、资源服务异常自定义这些骚操作！</a></li><li><a href=\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247503249&amp;idx=1&amp;sn=b33ae3ff70a08b17ee0779d6ccb30b53&amp;chksm=fcf7125ccb809b4aa4985da09e620e06c606754e6a72681c93dcc88bdc9aa7ba0cb64f52dbc3&amp;token=1286998820&amp;lang=zh_CN#rd\">实战干货！Spring Cloud Gateway 整合 OAuth2.0 实现分布式统一认证授权！</a></li><li><a href=\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247503263&amp;idx=1&amp;sn=edc475e36127792e35112c4746e53d37&amp;chksm=fcf71252cb809b44d7ae246e9503e1d6b91b29965c0cd7ebfc7da9c1a098fe186cd977736c40&amp;token=1144087588&amp;lang=zh_CN#rd\">字节面试这样问：跨库多表存在大量数据依赖问题有哪些解决方案？</a></li><li><a href=\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247504322&amp;idx=1&amp;sn=4b0a2488a4edcb025d0694604e86f840&amp;chksm=fcf70e0fcb808719b98a65891bc08e9490db09f07debd4521052978a319ab052f8a72b93c1a7&amp;token=284256295&amp;lang=zh_CN#rd\">实战！退出登录时如何借助外力使JWT令牌失效？</a></li><li><a href=\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247504442&amp;idx=1&amp;sn=48c1dd73c038e3d936db4e5134f7bbc2&amp;chksm=fcf70df7cb8084e1556cac092fdb68ffd6503cbb287485ef76e9941611d134258c38d03e890a&amp;token=780863812&amp;lang=zh_CN#rd\">实战！Spring Cloud Gateway集成 RBAC 权限模型实现动态权限控制！</a></li><li><a href=\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247504650&amp;idx=1&amp;sn=d7b3df7bcb8483a503749c863e0e0217&amp;chksm=fcf70cc7cb8085d11b46fd08613e6749ee5be6d25183f0f6c2561506e34954564cfe2d7fd46a&amp;token=439402375&amp;lang=zh_CN#rd\">实战！阿里神器 Seata 实现 TCC模式 解决分布式事务，真香！</a></li><li><a href=\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247504759&amp;idx=1&amp;sn=e50d5b44eb64debf43c6d644f55c68b5&amp;chksm=fcf70cbacb8085aca5cd88688973ed45cd8bd9a4642ae97727f3684b431f80316e5c073d6946&amp;scene=178&amp;cur_album_id=2042874937312346114#rd\">实战！openFeign如何实现全链路JWT令牌信息不丢失？</a></li><li><a href=\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247505342&amp;idx=1&amp;sn=3e701ee24e1a87ce3b438d840aa1c356&amp;chksm=fcf70a73cb80836547debd445832ae757e0b786ee71fc9b4229025d07a1eebd3ef219a4c2438&amp;scene=178&amp;cur_album_id=2042874937312346114#rd\">微服务下蓝绿发布、滚动发布、灰度发布等方案，必须懂！</a></li><li><a href=\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247505642&amp;idx=1&amp;sn=6e07461626c690dfeab4704941f1e55d&amp;chksm=fcf70927cb8080312ea2a942d99e27ea70b4466f36fdf115bf837a5226011048f50175b347ee&amp;scene=178&amp;cur_album_id=2042874937312346114#rd\">微服务如何聚合 API 文档？这波秀~</a></li><li><a href=\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247506116&amp;idx=1&amp;sn=a878dc620b4d850b540917a583ca12d8&amp;chksm=fcf70709cb808e1fe0db4a1e897e6bf5dc3b07a2fd6c2881920953cd9e19aed0ae049745ec0f&amp;scene=178&amp;cur_album_id=2042874937312346114#rd\">Spring Cloud 2021.0.1 正式发布，卷不动了~</a></li></ul>\n<p>本篇文章介绍一下Spring Security如何扩展新的授权类型，也是实际开发中非常重要的知识点。</p>\n<p>目录如下：</p>\n<p><img src=\"https://gitee.com/chenjiabing666/BlogImage/raw/master/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%88%E6%9D%83%E7%B1%BB%E5%9E%8B/13.png\" alt=\"\"></p>\n<h2 id=\"h2--\"><a name=\"为什么需要自定义授权类型？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>为什么需要自定义授权类型？</h2><p>前面介绍OAuth2.0的基础知识点时介绍过支持的4种授权类型，分别如下：</p>\n<ul>\n<li>授权码模式</li><li>简化模式</li><li>客户端模式</li><li>密码模式</li></ul>\n<p>关于上述4种授权类型不清楚的，可以看之前的文章：<a href=\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247502682&amp;idx=1&amp;sn=52a15b623ab6135c134b8262bd605946&amp;chksm=fcf71497cb809d81f1d2dbce76b3e00170f085306b2a2a67a807a6d9e2cf03bf1de3b8f203a2&amp;scene=178&amp;cur_album_id=2042874937312346114#rd\">妹子始终没搞懂OAuth2.0，今天整合Spring Cloud Security 一次说明白！</a></p>\n<p>实际生产中上述四种授权类型根本不够用，比如常见的授权类型如下：</p>\n<ul>\n<li>微信认证</li><li>QQ认证</li><li>手机号+验证码认证</li><li>图形验证码认证</li><li>邮箱认证</li></ul>\n<p>因此我们必须懂得OAuth2.0如何自定义授权类型，这也是本篇文章的重点。</p>\n<h2 id=\"h2-u5B9Eu73B0u601Du8DEF\"><a name=\"实现思路\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实现思路</h2><p>Spring Security 定制授权类型其实很简单，主要是掌握其中的思路，下面是密码模式的授权流程，如下图：</p>\n<p><img src=\"https://gitee.com/chenjiabing666/BlogImage/raw/master/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%88%E6%9D%83%E7%B1%BB%E5%9E%8B/1.jpg\" alt=\"\"></p>\n<p>根据上述流程图可以跟着源码进去看看，不难发现有几个如下重要点：</p>\n<ul>\n<li>每种授权类型都对应一个实现类<strong>TokenGranter</strong>，其中定义着授权类型</li><li>所有 <code>TokenGranter</code> 实现类都通过 <code>CompositeTokenGranter</code> 中的 <code>tokenGranters</code> 集合存起来。</li><li>然后通过判断 <code>grantType</code> 参数来定位具体使用那个 <code>TokenGranter</code> 实现类来处理授权。</li><li>每种授权方式都对应一个<strong>AuthenticationProvider</strong></li><li><code>TokenGranter</code> 类会 new 一个 <strong>AuthenticationToken</strong>实现类，如 <code>UsernamePasswordAuthenticationToken</code> 传给 <code>ProviderManager</code> 类。</li></ul>\n<p>因此想要自定义一个授权类型，必须构建自己的<strong>TokenGranter</strong>、<strong>AuthenticationProvider</strong>、<strong>AuthenticationToken</strong>。</p>\n<h2 id=\"h2-u4EE3u7801u5B9Eu73B0\"><a name=\"代码实现\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码实现</h2><p>下面就以<strong>手机号+密码</strong>的登录方式定义一个类型：<strong>mobile_pwd</strong>，剩下的自己照葫芦画瓢。</p>\n<h3 id=\"h3-1-userdetailservice\"><a name=\"1、自定义UserDetailService\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1、自定义UserDetailService</h3><p>这个和密码授权类型类似，要实现一个方法从数据库中根据手机号查询用户的详细信息。</p>\n<p>定义一个<strong>SmsCodeUserDetailService</strong>接口如下：</p>\n<p><img src=\"https://gitee.com/chenjiabing666/BlogImage/raw/master/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%88%E6%9D%83%E7%B1%BB%E5%9E%8B/2.png\" alt=\"\"></p>\n<p>主要就是一个 <strong>loadUserByMobile()</strong> 方法，实现类如下：</p>\n<p><img src=\"https://gitee.com/chenjiabing666/BlogImage/raw/master/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%88%E6%9D%83%E7%B1%BB%E5%9E%8B/3.png\" alt=\"\"></p>\n<h3 id=\"h3-2-authenticationtoken\"><a name=\"2、自定义AuthenticationToken\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2、自定义AuthenticationToken</h3><p>类似于密码模式的中<strong>UsernamePasswordAuthenticationToken</strong>，自定义一个<strong>MobilePasswordAuthenticationToken</strong>封装手机号和密码，如下：</p>\n<p><img src=\"https://gitee.com/chenjiabing666/BlogImage/raw/master/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%88%E6%9D%83%E7%B1%BB%E5%9E%8B/4.png\" alt=\"\"></p>\n<h3 id=\"h3-3-tokengranter\"><a name=\"3、自定义TokenGranter\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3、自定义TokenGranter</h3><p>每种授权类型都对应一种TokenGranter，其中会定义授权类型的名称，比如密码模式的<strong>ResourceOwnerPasswordTokenGranter</strong>，其中的GRANT_TYPE为password。</p>\n<p>自定义一个<strong>MobilePwdGranter</strong>，照葫芦画瓢，模仿着改改，代码如下：</p>\n<p><img src=\"https://gitee.com/chenjiabing666/BlogImage/raw/master/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%88%E6%9D%83%E7%B1%BB%E5%9E%8B/5.png\" alt=\"\"></p>\n<h3 id=\"h3-4-authenticationprovider\"><a name=\"4、自定义AuthenticationProvider\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4、自定义AuthenticationProvider</h3><p>这个类就是真正的处理类，经过TokenGranter后，会找到对应的AuthenticationProvider，然后取出参数从数据库（<strong>UserDetailService</strong>）中查询对应的信息进行匹配。</p>\n<p>自定义<strong>MobilePasswordAuthenticationProvider</strong>，代码如下：</p>\n<p><img src=\"https://gitee.com/chenjiabing666/BlogImage/raw/master/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%88%E6%9D%83%E7%B1%BB%E5%9E%8B/6.png\" alt=\"\"><img src=\"https://gitee.com/chenjiabing666/BlogImage/raw/master/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%88%E6%9D%83%E7%B1%BB%E5%9E%8B/7.png\" alt=\"\"></p>\n<blockquote>\n<p>案例源码已上传GitHub，关注公众号：<strong>码猿技术专栏</strong>，回复关键：<strong>9529</strong> 获取！</p>\n</blockquote>\n<h3 id=\"h3-5-mobilepasswordauthenticationprovider-ioc-\"><a name=\"5、将自定义的MobilePasswordAuthenticationProvider注入IOC容器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5、将自定义的MobilePasswordAuthenticationProvider注入IOC容器</h3><p>这里必须将自定义的MobilePasswordAuthenticationProvider注入到IOC容器，如果不注入，会报找不到能处理的AuthenticationProvider这个异常。</p>\n<p>新建<strong>SmsCodeSecurityConfig</strong>，代码如下：</p>\n<p><img src=\"https://gitee.com/chenjiabing666/BlogImage/raw/master/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%88%E6%9D%83%E7%B1%BB%E5%9E%8B/8.png\" alt=\"\"></p>\n<blockquote>\n<p>注意：由于使用的外部配置，因此必须在全局配置中指定</p>\n</blockquote>\n<h3 id=\"h3-6-security-smscodesecurityconfig\"><a name=\"6、Security的全局配置指定SmsCodeSecurityConfig\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6、Security的全局配置指定SmsCodeSecurityConfig</h3><p>由于是分开配置，因此必须在全局配置中指定才会生效，代码如下：</p>\n<p><img src=\"https://gitee.com/chenjiabing666/BlogImage/raw/master/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%88%E6%9D%83%E7%B1%BB%E5%9E%8B/9.png\" alt=\"\"></p>\n<h3 id=\"h3-7-compositetokengranter-\"><a name=\"7、加到CompositeTokenGranter集合中\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7、加到CompositeTokenGranter集合中</h3><p>需要将自定义的授权类型加到集合CompositeTokenGranter中，此处需要修改认证中心的配置类（<strong>AuthorizationServerConfig</strong>）中的代码，如下：</p>\n<p><img src=\"https://gitee.com/chenjiabing666/BlogImage/raw/master/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%88%E6%9D%83%E7%B1%BB%E5%9E%8B/10.png\" alt=\"\"></p>\n<h3 id=\"h3-8-oauth_client_details-\"><a name=\"8、oauth_client_details表中添加授权类型\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>8、oauth_client_details表中添加授权类型</h3><p><strong>oauth_client_details</strong>这个表是存储客户端的详细信息的，需要在对应的客户端资源那一行中的<strong>authorized_grant_types</strong>这个字段中添加自定义的授权类型，多个用逗号分隔。</p>\n<p><img src=\"https://gitee.com/chenjiabing666/BlogImage/raw/master/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%88%E6%9D%83%E7%B1%BB%E5%9E%8B/11.png\" alt=\"\"></p>\n<h2 id=\"h2-u6D4Bu8BD5\"><a name=\"测试\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>测试</h2><p>经过上述的步骤已经配置完成，下面来测试，启动服务，请求如下：</p>\n<p><img src=\"https://gitee.com/chenjiabing666/BlogImage/raw/master/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%88%E6%9D%83%E7%B1%BB%E5%9E%8B/12.jpg\" alt=\"\"></p>\n<h2 id=\"h2-u6E90u7801u83B7u53D6\"><a name=\"源码获取\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>源码获取</h2><p>授权类型主要是针对 <strong>认证中心（oauth2-cloud-auth-server）</strong> 的改动，改动的目录如下：</p>\n<p><img src=\"https://gitee.com/chenjiabing666/BlogImage/raw/master/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%88%E6%9D%83%E7%B1%BB%E5%9E%8B/12.png\" alt=\"\"></p>\n<p>陈某直接在之前网关整合<strong>Spring Security</strong>的源码上更改了一版。</p>\n<blockquote>\n<p>案例源码已上传GitHub，关注公众号：<strong>码猿技术专栏</strong>，回复关键：<strong>9529</strong> 获取！</p>\n</blockquote>\n<h2 id=\"h2--\"><a name=\"最后说一句（别白嫖，求关注）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>最后说一句（别白嫖，求关注）</h2><p>陈某每一篇文章都是精心输出，已经写了<strong>3个专栏</strong>，整理成<strong>PDF</strong>，获取方式如下：</p>\n<ol>\n<li><a href=\"https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&amp;action=getalbum&amp;album_id=2042874937312346114#wechat_redirect\">《Spring Cloud 进阶》</a>PDF：关注公众号：【<strong>码猿技术专栏</strong>】回复关键词 <strong>Spring Cloud 进阶</strong> 获取！</li><li><a href=\"https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&amp;action=getalbum&amp;album_id=1532834475389288449#wechat_redirect\">《Spring Boot 进阶》</a>PDF：关注公众号：【<strong>码猿技术专栏</strong>】回复关键词 <strong>Spring Boot进阶</strong> 获取！</li><li><a href=\"https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&amp;action=getalbum&amp;album_id=1500819225232343046#wechat_redirect\">《Mybatis 进阶》</a>PDF：关注公众号：【<strong>码猿技术专栏</strong>】回复关键词 <strong>Mybatis 进阶</strong> 获取！</li></ol>\n<p>如果这篇文章对你有所帮助，或者有所启发的话，帮忙<strong>点赞</strong>、<strong>在看</strong>、<strong>转发</strong>、<strong>收藏</strong>，你的支持就是我坚持下去的最大动力！</p>\n<p>关注公众号：<strong>【码猿技术专栏】</strong>，公众号内有超赞的粉丝福利，回复：<strong>加群</strong>，可以加入技术讨论群，和大家一起讨论技术，吹牛逼！</p>\n', 'Spring Cloud 自定义授权模式', 1, 0, 'https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%BC%98%E8%B4%A8%E8%A7%86%E9%A2%91%E8%B5%84%E6%BA%90/1.png', 1, 1, 1, 1, 2, '2022-03-06 18:17:45', '2022-03-06 18:21:54');
INSERT INTO `article` VALUES (6, '552917989473648640', '94dd9d02befd4dac9d6e708ff92f7d82', 2, 'SpringBoot 整合阿里中间件canal实现无感知增量同步', '<p><strong>大家好，我是不才陈某~</strong></p>\n<p>数据同步一直是一个令人头疼的问题。在业务量小，场景不多，数据量不大的情况下我们可能会选择在项目中直接写一些定时任务手动处理数据，例如从多个表将数据查出来，再汇总处理，再插入到相应的地方。</p>\n<p>但是随着业务量增大，数据量变多以及各种复杂场景下的分库分表的实现，使数据同步变得越来越困难。</p>\n<p>今天这篇文章使用<strong>阿里</strong>开源的中间件<strong>Canal</strong>解决数据增量同步的痛点。</p>\n<p>文章目录如下：</p>\n<p><img src=\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/204.png\" alt=\"\"></p>\n<h2 id=\"h2-canal-\"><a name=\"Canal是什么？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Canal是什么？</h2><p><strong>canal</strong>译意为水道/管道/沟渠，主要用途是基于 <strong>MySQL</strong> 数据库<strong>增量日志</strong>解析，提供增量数据订阅和消费。</p>\n<p>从这句话理解到了什么？</p>\n<p>基于MySQL，并且通过MySQL日志进行的增量解析，这也就意味着对原有的业务代码完全是无侵入性的。</p>\n<blockquote>\n<p>工作原理：解析MySQL的binlog日志，提供增量数据。</p>\n</blockquote>\n<p>基于日志增量订阅和消费的业务包括</p>\n<ul>\n<li>数据库镜像</li><li>数据库实时备份</li><li>索引构建和实时维护(拆分异构索引、倒排索引等)</li><li>业务 cache 刷新</li><li>带业务逻辑的增量数据处理</li></ul>\n<p>当前的 canal 支持源端 MySQL 版本包括 5.1.x , 5.5.x , 5.6.x , 5.7.x , 8.0.x。</p>\n<blockquote>\n<p>官方文档：<a href=\"https://github.com/alibaba/canal\">https://github.com/alibaba/canal</a></p>\n</blockquote>\n<h2 id=\"h2-canal-\"><a name=\"Canal数据如何传输？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Canal数据如何传输？</h2><p>先来一张官方图：</p>\n<p><img src=\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/196.png\" alt=\"\"></p>\n<p>Canal分为服务端和客户端，这也是阿里常用的套路，比如前面讲到的注册中心<strong>Nacos</strong>：</p>\n<ul>\n<li><strong>服务端</strong>：负责解析MySQL的binlog日志，传递增量数据给客户端或者消息中间件</li><li><strong>客户端</strong>：负责解析服务端传过来的数据，然后定制自己的业务处理。</li></ul>\n<p>目前为止支持的消息中间件很全面了，比如<strong>Kafka</strong>、<strong>RocketMQ</strong>，<strong>RabbitMQ</strong>。</p>\n<h2 id=\"h2--\"><a name=\"数据同步还有其他中间件吗？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>数据同步还有其他中间件吗？</h2><p>有，当然有，还有一些开源的中间件也是相当不错的，比如<strong>Bifrost</strong>。</p>\n<p>常见的几款中间件的区别如下：</p>\n<p><img src=\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/197.png\" alt=\"\"></p>\n<p>当然要我选择的话，首选阿里的中间件Canal。</p>\n<h2 id=\"h2-canal-\"><a name=\"Canal服务端安装\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Canal服务端安装</h2><p>服务端需要下载压缩包，下载地址：<a href=\"https://github.com/alibaba/canal/releases\">https://github.com/alibaba/canal/releases</a></p>\n<p>目前最新的是<strong>v1.1.5</strong>，点击下载：</p>\n<p><img src=\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/198.png\" alt=\"\"></p>\n<p>下载完成解压，目录如下：</p>\n<p><img src=\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/199.png\" alt=\"\"></p>\n<p>本文使用<strong>Canal+RabbitMQ</strong>进行数据的同步，因此下面步骤完全按照这个base进行。</p>\n<h3 id=\"h3--strong-1-mysql-binlog-strong-\"><a name=\"<strong>1、打开MySQL的binlog日志</strong>\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><strong>1、打开MySQL的binlog日志</strong></h3><p>修改MySQL的日志文件，my.cnf 配置如下：</p>\n<pre><code class=\"lang-properties\">[mysqld]\nlog-bin=mysql-bin # 开启 binlog\nbinlog-format=ROW # 选择 ROW 模式\nserver_id=1 # 配置 MySQL replaction 需要定义，不要和 canal 的 slaveId 重复\n</code></pre>\n<h3 id=\"h3--strong-2-mysql-strong-\"><a name=\"<strong>2、设置MySQL的配置</strong>\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><strong>2、设置MySQL的配置</strong></h3><p>需要设置服务端配置文件中的MySQL配置，这样Canal才能知道需要监听哪个库、哪个表的日志文件。</p>\n<p>一个 Server 可以配置多个实例监听 ，Canal 功能默认自带的有个 example 实例，本篇就用 example 实例 。如果增加实例，复制 example 文件夹内容到同级目录下，然后在 <code>canal.properties</code> 指定添加实例的名称。</p>\n<p><strong>修改canal.deployer-1.1.5\\conf\\example\\instance.properties配置文件</strong></p>\n<pre><code class=\"lang-properties\"># url\ncanal.instance.master.address=127.0.0.1:3306\n# username/password\ncanal.instance.dbUsername=root\ncanal.instance.dbPassword=root\n# 监听的数据库\ncanal.instance.defaultDatabaseName=test\n\n# 监听的表，可以指定，多个用逗号分割，这里正则是监听所有\ncanal.instance.filter.regex=.*\\\\..*\n</code></pre>\n<h3 id=\"h3--strong-3-rabbitmq-strong-\"><a name=\"<strong>3、设置RabbitMQ的配置</strong>\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><strong>3、设置RabbitMQ的配置</strong></h3><p>服务端默认的传输方式是<strong>tcp</strong>，需要在配置文件中设置<strong>MQ</strong>的相关信息。</p>\n<p>这里需要修改两处配置文件，如下；</p>\n<p><strong>1、canal.deployer-1.1.5\\conf\\canal.properties</strong></p>\n<p>这个配置文件主要是设置MQ相关的配置，比如URL，用户名、密码…</p>\n<pre><code class=\"lang-properties\"># 传输方式：tcp, kafka, rocketMQ, rabbitMQ\ncanal.serverMode = rabbitMQ\n##################################################\n#########             RabbitMQ         #############\n##################################################\nrabbitmq.host = 127.0.0.1\nrabbitmq.virtual.host =/\n# exchange\nrabbitmq.exchange =canal.exchange\n# 用户名、密码\nrabbitmq.username =guest\nrabbitmq.password =guest\n## 是否持久化\nrabbitmq.deliveryMode = 2\n</code></pre>\n<p>2、<strong>canal.deployer-1.1.5\\conf\\example\\instance.properties</strong></p>\n<p>这个文件设置MQ的路由KEY，这样才能路由到指定的队列中，如下：</p>\n<pre><code class=\"lang-properties\">canal.mq.topic=canal.routing.key\n</code></pre>\n<h3 id=\"h3--strong-4-rabbitmq-exchange-queue-strong-\"><a name=\"<strong>4、RabbitMQ新建exchange和Queue</strong>\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><strong>4、RabbitMQ新建exchange和Queue</strong></h3><p>在RabbitMQ中需要新建一个<strong>canal.exchange</strong>（必须和配置中的相同）的exchange和一个名称为 <strong>canal.queue</strong>（名称随意）的队列。</p>\n<p>其中绑定的路由KEY为：<strong>canal.routing.key</strong>（必须和配置中的相同），如下图：</p>\n<p><img src=\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/200.png\" alt=\"\"></p>\n<h3 id=\"h3--strong-5-strong-\"><a name=\"<strong>5、启动服务端</strong>\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><strong>5、启动服务端</strong></h3><p>点击bin目录下的脚本，windows直接双击<strong>startup.bat</strong>，启动成功如下：</p>\n<p><img src=\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/201.png\" alt=\"\"></p>\n<h3 id=\"h3--strong-6-strong-\"><a name=\"<strong>6、测试</strong>\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><strong>6、测试</strong></h3><p>在本地数据库<strong>test</strong>中的<strong>oauth_client_details</strong>插入一条数据，如下：</p>\n<pre><code class=\"lang-mysql\">INSERT INTO `oauth_client_details` VALUES (&#39;myjszl&#39;, &#39;res1&#39;, &#39;$2a$10$F1tQdeb0SEMdtjlO8X/0wO6Gqybu6vPC/Xg8OmP9/TL1i4beXdK9W&#39;, &#39;all&#39;, &#39;password,refresh_token,authorization_code,client_credentials,implicit&#39;, &#39;http://www.baidu.com&#39;, NULL, 1000, 1000, NULL, &#39;false&#39;);\n</code></pre>\n<p>此时查看MQ中的<strong>canal.queue</strong>已经有了数据，如下：</p>\n<p><img src=\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/202.png\" alt=\"\"></p>\n<p>其实就是一串JSON数据，这个JSON如下：</p>\n<pre><code class=\"lang-json\">{\n    &quot;data&quot;: [{\n        &quot;client_id&quot;: &quot;myjszl&quot;,\n        &quot;resource_ids&quot;: &quot;res1&quot;,\n        &quot;client_secret&quot;: &quot;$2a$10$F1tQdeb0SEMdtjlO8X/0wO6Gqybu6vPC/Xg8OmP9/TL1i4beXdK9W&quot;,\n        &quot;scope&quot;: &quot;all&quot;,\n        &quot;authorized_grant_types&quot;: &quot;password,refresh_token,authorization_code,client_credentials,implicit&quot;,\n        &quot;web_server_redirect_uri&quot;: &quot;http://www.baidu.com&quot;,\n        &quot;authorities&quot;: null,\n        &quot;access_token_validity&quot;: &quot;1000&quot;,\n        &quot;refresh_token_validity&quot;: &quot;1000&quot;,\n        &quot;additional_information&quot;: null,\n        &quot;autoapprove&quot;: &quot;false&quot;\n    }],\n    &quot;database&quot;: &quot;test&quot;,\n    &quot;es&quot;: 1640337532000,\n    &quot;id&quot;: 7,\n    &quot;isDdl&quot;: false,\n    &quot;mysqlType&quot;: {\n        &quot;client_id&quot;: &quot;varchar(48)&quot;,\n        &quot;resource_ids&quot;: &quot;varchar(256)&quot;,\n        &quot;client_secret&quot;: &quot;varchar(256)&quot;,\n        &quot;scope&quot;: &quot;varchar(256)&quot;,\n        &quot;authorized_grant_types&quot;: &quot;varchar(256)&quot;,\n        &quot;web_server_redirect_uri&quot;: &quot;varchar(256)&quot;,\n        &quot;authorities&quot;: &quot;varchar(256)&quot;,\n        &quot;access_token_validity&quot;: &quot;int(11)&quot;,\n        &quot;refresh_token_validity&quot;: &quot;int(11)&quot;,\n        &quot;additional_information&quot;: &quot;varchar(4096)&quot;,\n        &quot;autoapprove&quot;: &quot;varchar(256)&quot;\n    },\n    &quot;old&quot;: null,\n    &quot;pkNames&quot;: [&quot;client_id&quot;],\n    &quot;sql&quot;: &quot;&quot;,\n    &quot;sqlType&quot;: {\n        &quot;client_id&quot;: 12,\n        &quot;resource_ids&quot;: 12,\n        &quot;client_secret&quot;: 12,\n        &quot;scope&quot;: 12,\n        &quot;authorized_grant_types&quot;: 12,\n        &quot;web_server_redirect_uri&quot;: 12,\n        &quot;authorities&quot;: 12,\n        &quot;access_token_validity&quot;: 4,\n        &quot;refresh_token_validity&quot;: 4,\n        &quot;additional_information&quot;: 12,\n        &quot;autoapprove&quot;: 12\n    },\n    &quot;table&quot;: &quot;oauth_client_details&quot;,\n    &quot;ts&quot;: 1640337532520,\n    &quot;type&quot;: &quot;INSERT&quot;\n}\n</code></pre>\n<p>每个字段的意思已经很清楚了，有表名称、方法、参数、参数类型、参数值…..</p>\n<p><strong>客户端要做的就是监听MQ获取JSON数据，然后将其解析出来，处理自己的业务逻辑。</strong></p>\n<h2 id=\"h2-canal-\"><a name=\"Canal客户端搭建\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Canal客户端搭建</h2><p>客户端很简单实现，要做的就是消费Canal服务端传递过来的消息，监听<strong>canal.queue</strong>这个队列。</p>\n<h3 id=\"h3--strong-1-strong-\"><a name=\"<strong>1、创建消息实体类</strong>\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><strong>1、创建消息实体类</strong></h3><p>MQ传递过来的是JSON数据，当然要创建个实体类接收数据，如下：</p>\n<pre><code class=\"lang-java\">/**\n * @author 公众号 码猿技术专栏\n * Canal消息接收实体类\n */\n@NoArgsConstructor\n@Data\npublic class CanalMessage&lt;T&gt; {\n    @JsonProperty(&quot;type&quot;)\n    private String type;\n\n    @JsonProperty(&quot;table&quot;)\n    private String table;\n\n    @JsonProperty(&quot;data&quot;)\n    private List&lt;T&gt; data;\n\n    @JsonProperty(&quot;database&quot;)\n    private String database;\n\n    @JsonProperty(&quot;es&quot;)\n    private Long es;\n\n    @JsonProperty(&quot;id&quot;)\n    private Integer id;\n\n    @JsonProperty(&quot;isDdl&quot;)\n    private Boolean isDdl;\n\n    @JsonProperty(&quot;old&quot;)\n    private List&lt;T&gt; old;\n\n    @JsonProperty(&quot;pkNames&quot;)\n    private List&lt;String&gt; pkNames;\n\n    @JsonProperty(&quot;sql&quot;)\n    private String sql;\n\n    @JsonProperty(&quot;ts&quot;)\n    private Long ts;\n}\n</code></pre>\n<h3 id=\"h3--strong-2-mq-strong-\"><a name=\"<strong>2、MQ消息监听业务</strong>\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><strong>2、MQ消息监听业务</strong></h3><p>接下来就是监听队列，一旦有Canal服务端有数据推送能够及时的消费。</p>\n<p>代码很简单，只是给出个接收的案例，具体的业务逻辑可以根据业务实现，如下：</p>\n<pre><code class=\"lang-java\">import cn.hutool.json.JSONUtil;\nimport cn.myjszl.middle.ware.canal.mq.rabbit.model.CanalMessage;\nimport lombok.RequiredArgsConstructor;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.amqp.rabbit.annotation.Exchange;\nimport org.springframework.amqp.rabbit.annotation.Queue;\nimport org.springframework.amqp.rabbit.annotation.QueueBinding;\nimport org.springframework.amqp.rabbit.annotation.RabbitListener;\nimport org.springframework.stereotype.Component;\n\n/**\n * 监听MQ获取Canal增量的数据消息\n */\n@Component\n@Slf4j\n@RequiredArgsConstructor\npublic class CanalRabbitMQListener {\n\n    @RabbitListener(bindings = {\n            @QueueBinding(\n                    value = @Queue(value = &quot;canal.queue&quot;, durable = &quot;true&quot;),\n                    exchange = @Exchange(value = &quot;canal.exchange&quot;),\n                    key = &quot;canal.routing.key&quot;\n            )\n    })\n    public void handleDataChange(String message) {\n        //将message转换为CanalMessage\n        CanalMessage canalMessage = JSONUtil.toBean(message, CanalMessage.class);\n        String tableName = canalMessage.getTable();\n        log.info(&quot;Canal 监听 {} 发生变化；明细：{}&quot;, tableName, message);\n        //TODO 业务逻辑自己完善...............\n    }\n}\n</code></pre>\n<h3 id=\"h3--strong-3-strong-\"><a name=\"<strong>3、测试</strong>\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><strong>3、测试</strong></h3><p>下面向表中插入数据，看下接收的消息是什么样的，SQL如下：</p>\n<pre><code class=\"lang-sql\">INSERT INTO `oauth_client_details`\nVALUES\n    ( &#39;myjszl&#39;, &#39;res1&#39;, &#39;$2a$10$F1tQdeb0SEMdtjlO8X/0wO6Gqybu6vPC/Xg8OmP9/TL1i4beXdK9W&#39;, &#39;all&#39;, &#39;password,refresh_token,authorization_code,client_credentials,implicit&#39;, &#39;http://www.baidu.com&#39;, NULL, 1000, 1000, NULL, &#39;false&#39; );\n</code></pre>\n<p>客户端转换后的消息如下图：</p>\n<p><img src=\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/203.png\" alt=\"\"></p>\n<p>上图可以看出所有的数据都已经成功接收到，只需要根据数据完善自己的业务逻辑即可。</p>\n<blockquote>\n<p>客户端案例源码已经上传GitHub，关注公众号：<strong>码猿技术专栏</strong>，回复关键词：<strong>9530</strong> 获取！</p>\n</blockquote>\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>数据增量同步的开源工具并不只有Canal一种，根据自己的业务需要选择合适的组件。</p>\n<h2 id=\"h2--\"><a name=\"最后说一句（别白嫖，求关注）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>最后说一句（别白嫖，求关注）</h2><p>陈某每一篇文章都是精心输出，已经写了<strong>3个专栏</strong>，整理成<strong>PDF</strong>，获取方式如下：</p>\n<ol>\n<li><a href=\"https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&amp;action=getalbum&amp;album_id=2042874937312346114#wechat_redirect\">《Spring Cloud 进阶》</a>PDF：关注公众号：【<strong>码猿技术专栏</strong>】回复关键词 <strong>Spring Cloud 进阶</strong> 获取！</li><li><a href=\"https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&amp;action=getalbum&amp;album_id=1532834475389288449#wechat_redirect\">《Spring Boot 进阶》</a>PDF：关注公众号：【<strong>码猿技术专栏</strong>】回复关键词 <strong>Spring Boot进阶</strong> 获取！</li><li><a href=\"https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&amp;action=getalbum&amp;album_id=1500819225232343046#wechat_redirect\">《Mybatis 进阶》</a>PDF：关注公众号：【<strong>码猿技术专栏</strong>】回复关键词 <strong>Mybatis 进阶</strong> 获取！</li></ol>\n<p>如果这篇文章对你有所帮助，或者有所启发的话，帮忙<strong>点赞</strong>、<strong>在看</strong>、<strong>转发</strong>、<strong>收藏</strong>，你的支持就是我坚持下去的最大动力！</p>\n<p>关注公众号：<strong>【码猿技术专栏】</strong>，公众号内有超赞的粉丝福利，回复：<strong>加群</strong>，可以加入技术讨论群，和大家一起讨论技术，吹牛逼！</p>\n', 'SpringBoot 整合阿里中间件canal实现无感知增量同步', 1, 0, 'https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%BC%98%E8%B4%A8%E8%A7%86%E9%A2%91%E8%B5%84%E6%BA%90/1.png', 1, 1, 1, 1, 2, '2022-03-06 18:18:41', '2022-03-06 18:21:55');
INSERT INTO `article` VALUES (7, '552918342474661888', '94dd9d02befd4dac9d6e708ff92f7d82', 2, 'Springboot 日志、配置文件、接口数据如何脱敏？老鸟们都是这样玩的！', '<h2 id=\"h2--\"><a name=\"一、前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、前言</h2><p>核心隐私数据无论对于企业还是用户来说尤其重要，因此要想办法杜绝各种隐私数据的泄漏。下面陈某带大家从以下三个方面讲解一下隐私数据如何脱敏，也是日常开发中需要注意的：</p>\n<ol>\n<li>配置文件数据脱敏</li><li>接口返回数据脱敏</li><li>日志文件数据脱敏</li></ol>\n<p>文章目录如下：</p>\n<p><img src=\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F/6.png\" alt=\"\"></p>\n<h2 id=\"h2--\"><a name=\"二、配置文件如何脱敏？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、配置文件如何脱敏？</h2><p>经常会遇到这样一种情况：项目的配置文件中总有一些敏感信息，比如数据源的url、用户名、密码….这些信息一旦被暴露那么整个数据库都将会被泄漏，那么如何将这些配置隐藏呢？</p>\n<p>以前都是手动将加密之后的配置写入到配置文件中，提取的时候再手动解密，当然这是一种思路，也能解决问题，但是每次都要手动加密、解密不觉得麻烦吗？</p>\n<p><img src=\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F/7.jpg\" alt=\"\"></p>\n<p>今天介绍一种方案，让你在无感知的情况下实现配置文件的加密、解密。利用一款开源插件：<code>jasypt-spring-boot</code>。项目地址如下：</p>\n<pre><code class=\"lang-java\">https://github.com/ulisesbocchio/jasypt-spring-boot\n</code></pre>\n<p>使用方法很简单，整合Spring Boot 只需要添加一个<code>starter</code>。</p>\n<h3 id=\"h3-1-\"><a name=\"1. 添加依赖\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 添加依赖</h3><pre><code class=\"lang-xml\">&lt;dependency&gt;\n        &lt;groupId&gt;com.github.ulisesbocchio&lt;/groupId&gt;\n        &lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt;\n        &lt;version&gt;3.0.3&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h3 id=\"h3-2-\"><a name=\"2. 配置秘钥\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 配置秘钥</h3><p>在配置文件中添加一个加密的秘钥（任意），如下：</p>\n<pre><code class=\"lang-yaml\">jasypt:\n  encryptor:\n    password: Y6M9fAJQdU7jNp5MW\n</code></pre>\n<p>当然将秘钥直接放在配置文件中也是不安全的，我们可以在项目启动的时候配置秘钥，命令如下：</p>\n<pre><code class=\"lang-shell\">java -jar xxx.jar  -Djasypt.encryptor.password=Y6M9fAJQdU7jNp5MW\n</code></pre>\n<h3 id=\"h3-3-\"><a name=\"3. 生成加密后的数据\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 生成加密后的数据</h3><p>这一步骤是将配置明文进行加密，代码如下：</p>\n<pre><code class=\"lang-java\">@SpringBootTest\n@RunWith(SpringRunner.class)\npublic class SpringbootJasyptApplicationTests {\n\n    /**\n     * 注入加密方法\n     */\n    @Autowired\n    private StringEncryptor encryptor;\n\n    /**\n     * 手动生成密文，此处演示了url，user，password\n     */\n    @Test\n    public void encrypt() {\n        String url = encryptor.encrypt(&quot;jdbc\\\\:mysql\\\\://127.0.0.1\\\\:3306/test?useUnicode\\\\=true&amp;characterEncoding\\\\=UTF-8&amp;zeroDateTimeBehavior\\\\=convertToNull&amp;useSSL\\\\=false&amp;allowMultiQueries\\\\=true&amp;serverTimezone=Asia/Shanghai&quot;);\n        String name = encryptor.encrypt(&quot;root&quot;);\n        String password = encryptor.encrypt(&quot;123456&quot;);\n        System.out.println(&quot;database url: &quot; + url);\n        System.out.println(&quot;database name: &quot; + name);\n        System.out.println(&quot;database password: &quot; + password);\n        Assert.assertTrue(url.length() &gt; 0);\n        Assert.assertTrue(name.length() &gt; 0);\n        Assert.assertTrue(password.length() &gt; 0);\n    }\n}\n</code></pre>\n<p>上述代码对数据源的url、user、password进行了明文加密，输出的结果如下：</p>\n<pre><code class=\"lang-properties\">database url: szkFDG56WcAOzG2utv0m2aoAvNFH5g3DXz0o6joZjT26Y5WNA+1Z+pQFpyhFBokqOp2jsFtB+P9b3gB601rfas3dSfvS8Bgo3MyP1nojJgVp6gCVi+B/XUs0keXPn+pbX/19HrlUN1LeEweHS/LCRZslhWJCsIXTwZo1PlpXRv3Vyhf2OEzzKLm3mIAYj51CrEaN3w5cMiCESlwvKUhpAJVz/uXQJ1spLUAMuXCKKrXM/6dSRnWyTtdFRost5cChEU9uRjw5M+8HU3BLemtcK0vM8iYDjEi5zDbZtwxD3hA=\n\ndatabase name: L8I2RqYPptEtQNL4x8VhRVakSUdlsTGzEND/3TOnVTYPWe0ZnWsW0/5JdUsw9ulm\n\ndatabase password: EJYCSbBL8Pmf2HubIH7dHhpfDZcLyJCEGMR9jAV3apJtvFtx9TVdhUPsAxjQ2pnJ\n</code></pre>\n<h3 id=\"h3-4-\"><a name=\"4. 将加密后的密文写入配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 将加密后的密文写入配置</h3><p><code>jasypt</code>默认使用<code>ENC()</code>包裹，此时的数据源配置如下：</p>\n<pre><code class=\"lang-yaml\">spring:\n  datasource:\n    #   数据源基本配置\n    username: ENC(L8I2RqYPptEtQNL4x8VhRVakSUdlsTGzEND/3TOnVTYPWe0ZnWsW0/5JdUsw9ulm)\n    password: ENC(EJYCSbBL8Pmf2HubIH7dHhpfDZcLyJCEGMR9jAV3apJtvFtx9TVdhUPsAxjQ2pnJ)\n    driver-class-name: com.mysql.jdbc.Driver\n    url: ENC(szkFDG56WcAOzG2utv0m2aoAvNFH5g3DXz0o6joZjT26Y5WNA+1Z+pQFpyhFBokqOp2jsFtB+P9b3gB601rfas3dSfvS8Bgo3MyP1nojJgVp6gCVi+B/XUs0keXPn+pbX/19HrlUN1LeEweHS/LCRZslhWJCsIXTwZo1PlpXRv3Vyhf2OEzzKLm3mIAYj51CrEaN3w5cMiCESlwvKUhpAJVz/uXQJ1spLUAMuXCKKrXM/6dSRnWyTtdFRost5cChEU9uRjw5M+8HU3BLemtcK0vM8iYDjEi5zDbZtwxD3hA=)\n    type: com.alibaba.druid.pool.DruidDataSource\n</code></pre>\n<p>上述配置是使用默认的<code>prefix=ENC(</code>、<code>suffix=)</code>，当然我们可以根据自己的要求更改，只需要在配置文件中更改即可，如下：</p>\n<pre><code class=\"lang-yaml\">jasypt:\n  encryptor:\n    ## 指定前缀、后缀\n    property:\n      prefix: &#39;PASS(&#39;\n      suffix: &#39;)&#39;\n</code></pre>\n<p>那么此时的配置就必须使用<code>PASS()</code>包裹才会被解密，如下：</p>\n<pre><code class=\"lang-yaml\">spring:\n  datasource:\n    #   数据源基本配置\n    username: PASS(L8I2RqYPptEtQNL4x8VhRVakSUdlsTGzEND/3TOnVTYPWe0ZnWsW0/5JdUsw9ulm)\n    password: PASS(EJYCSbBL8Pmf2HubIH7dHhpfDZcLyJCEGMR9jAV3apJtvFtx9TVdhUPsAxjQ2pnJ)\n    driver-class-name: com.mysql.jdbc.Driver\n    url: PASS(szkFDG56WcAOzG2utv0m2aoAvNFH5g3DXz0o6joZjT26Y5WNA+1Z+pQFpyhFBokqOp2jsFtB+P9b3gB601rfas3dSfvS8Bgo3MyP1nojJgVp6gCVi+B/XUs0keXPn+pbX/19HrlUN1LeEweHS/LCRZslhWJCsIXTwZo1PlpXRv3Vyhf2OEzzKLm3mIAYj51CrEaN3w5cMiCESlwvKUhpAJVz/uXQJ1spLUAMuXCKKrXM/6dSRnWyTtdFRost5cChEU9uRjw5M+8HU3BLemtcK0vM8iYDjEi5zDbZtwxD3hA=)\n    type: com.alibaba.druid.pool.DruidDataSource\n</code></pre>\n<h3 id=\"h3-5-\"><a name=\"5. 总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5. 总结</h3><p>jasypt还有许多高级用法，比如可以自己配置加密算法，具体的操作可以参考Github上的文档。</p>\n<h2 id=\"h2--\"><a name=\"三、接口返回数据如何脱敏？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、接口返回数据如何脱敏？</h2><p>通常接口返回值中的一些敏感数据也是要脱敏的，比如身份证号、手机号码、地址…..通常的手段就是用<code>*</code>隐藏一部分数据，当然也可以根据自己需求定制。</p>\n<p>言归正传，如何优雅的实现呢？有两种实现方案，如下：</p>\n<ul>\n<li><p>整合Mybatis插件，在查询的时候针对特定的字段进行脱敏</p>\n</li><li><p>整合Jackson，在序列化阶段对特定字段进行脱敏</p>\n</li><li><p>基于<code>Sharding Sphere</code>实现数据脱敏，查看之前的文章：<a href=\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247493021&amp;idx=2&amp;sn=f27a4eeb6dd3eb5b1551eabf6e31739e&amp;chksm=fcf73a50cb80b3465e6f7cf1fd841bfec098fcde47c587a2c35e7793bad3b33ebe8f2433d3ff&amp;token=1439687168&amp;lang=zh_CN#rd\">基于Sharding Sphere实现数据“一键脱敏”</a></p>\n</li></ul>\n<p>第一种方案网上很多实现方式，下面演示第二种，整合Jackson。</p>\n<h3 id=\"h3-1-jackson-\"><a name=\"1. 自定义一个Jackson注解\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 自定义一个Jackson注解</h3><p>需要自定义一个脱敏注解，一旦有属性被标注，则进行对应得脱敏，如下：</p>\n<pre><code class=\"lang-java\">/**\n * 自定义jackson注解，标注在属性上\n */\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.FIELD)\n@JacksonAnnotationsInside\n@JsonSerialize(using = SensitiveJsonSerializer.class)\npublic @interface Sensitive {\n    //脱敏策略\n    SensitiveStrategy strategy();\n}\n</code></pre>\n<h3 id=\"h3-2-\"><a name=\"2. 定制脱敏策略\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 定制脱敏策略</h3><p>针对项目需求，定制不同字段的脱敏规则，比如手机号中间几位用<code>*</code>替代，如下：</p>\n<pre><code class=\"lang-java\">/**\n * 脱敏策略，枚举类，针对不同的数据定制特定的策略\n */\npublic enum SensitiveStrategy {\n    /**\n     * 用户名\n     */\n    USERNAME(s -&gt; s.replaceAll(&quot;(\\\\S)\\\\S(\\\\S*)&quot;, &quot;$1*$2&quot;)),\n    /**\n     * 身份证\n     */\n    ID_CARD(s -&gt; s.replaceAll(&quot;(\\\\d{4})\\\\d{10}(\\\\w{4})&quot;, &quot;$1****$2&quot;)),\n    /**\n     * 手机号\n     */\n    PHONE(s -&gt; s.replaceAll(&quot;(\\\\d{3})\\\\d{4}(\\\\d{4})&quot;, &quot;$1****$2&quot;)),\n    /**\n     * 地址\n     */\n    ADDRESS(s -&gt; s.replaceAll(&quot;(\\\\S{3})\\\\S{2}(\\\\S*)\\\\S{2}&quot;, &quot;$1****$2****&quot;));\n\n\n    private final Function&lt;String, String&gt; desensitizer;\n\n    SensitiveStrategy(Function&lt;String, String&gt; desensitizer) {\n        this.desensitizer = desensitizer;\n    }\n\n    public Function&lt;String, String&gt; desensitizer() {\n        return desensitizer;\n    }\n}\n</code></pre>\n<p>以上只是提供了部分，具体根据自己项目要求进行配置。</p>\n<h3 id=\"h3-3-json-\"><a name=\"3. 定制JSON序列化实现\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 定制JSON序列化实现</h3><p>下面将是重要实现，对标注注解<code><a href=\"https://github.com/Sensitive\" title=\"&#64;Sensitive\" class=\"at-link\">@Sensitive</a></code>的字段进行脱敏，实现如下：</p>\n<pre><code class=\"lang-java\">/**\n * 序列化注解自定义实现\n * JsonSerializer&lt;String&gt;：指定String 类型，serialize()方法用于将修改后的数据载入\n */\npublic class SensitiveJsonSerializer extends JsonSerializer&lt;String&gt; implements ContextualSerializer {\n    private SensitiveStrategy strategy;\n\n    @Override\n    public void serialize(String value, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n        gen.writeString(strategy.desensitizer().apply(value));\n    }\n\n    /**\n     * 获取属性上的注解属性\n     */\n    @Override\n    public JsonSerializer&lt;?&gt; createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException {\n\n        Sensitive annotation = property.getAnnotation(Sensitive.class);\n        if (Objects.nonNull(annotation)&amp;&amp;Objects.equals(String.class, property.getType().getRawClass())) {\n            this.strategy = annotation.strategy();\n            return this;\n        }\n        return prov.findValueSerializer(property.getType(), property);\n\n    }\n}\n</code></pre>\n<h3 id=\"h3-4-person-\"><a name=\"4. 定义Person类，对其数据脱敏\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 定义Person类，对其数据脱敏</h3><p>使用注解<code><a href=\"https://github.com/Sensitive\" title=\"&#64;Sensitive\" class=\"at-link\">@Sensitive</a></code>注解进行数据脱敏，代码如下：</p>\n<pre><code class=\"lang-java\">@Data\npublic class Person {\n    /**\n     * 真实姓名\n     */\n    @Sensitive(strategy = SensitiveStrategy.USERNAME)\n    private String realName;\n    /**\n     * 地址\n     */\n    @Sensitive(strategy = SensitiveStrategy.ADDRESS)\n    private String address;\n    /**\n     * 电话号码\n     */\n    @Sensitive(strategy = SensitiveStrategy.PHONE)\n    private String phoneNumber;\n    /**\n     * 身份证号码\n     */\n    @Sensitive(strategy = SensitiveStrategy.ID_CARD)\n    private String idCard;\n}\n</code></pre>\n<h3 id=\"h3-5-\"><a name=\"5. 模拟接口测试\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5. 模拟接口测试</h3><p>以上4个步骤完成了数据脱敏的Jackson注解，下面写个controller进行测试，代码如下：</p>\n<pre><code class=\"lang-java\">@RestController\npublic class TestController {\n    @GetMapping(&quot;/test&quot;)\n    public Person test(){\n        Person user = new Person();\n        user.setRealName(&quot;不才陈某&quot;);\n        user.setPhoneNumber(&quot;19796328206&quot;);\n        user.setAddress(&quot;浙江省杭州市温州市....&quot;);\n        user.setIdCard(&quot;4333333333334334333&quot;);\n        return user;\n    }\n}\n</code></pre>\n<p>调用接口查看数据有没有正常脱敏，结果如下：</p>\n<pre><code class=\"lang-json\">{\n    &quot;realName&quot;: &quot;不*陈某&quot;,\n    &quot;address&quot;: &quot;浙江省****市温州市..****&quot;,\n    &quot;phoneNumber&quot;: &quot;197****8206&quot;,\n    &quot;idCard&quot;: &quot;4333****34333&quot;\n}\n</code></pre>\n<h3 id=\"h3-6-\"><a name=\"6. 总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6. 总结</h3><p>数据脱敏有很多种实现方式，关键是哪种更加适合，哪种更加优雅…..</p>\n<h2 id=\"h2--\"><a name=\"四、日志文件如何数据脱敏？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、日志文件如何数据脱敏？</h2><p>上面讲了配置文件、接口返回值的数据脱敏，现在总该轮到日志脱敏了。项目中总避免不了打印日志，肯定会涉及到一些敏感数据被明文打印出来，那么此时就需要过滤掉这些敏感数据（身份证、号码、用户名…..）。</p>\n<p>关于Spring Boot 日志方面的问题有不理解的可以看我之前的文章：<a href=\"https://mp.weixin.qq.com/s/5hyGi6X6BhfCC5kTEvUyFg\">Spring Boot第三弹，一文带你搞懂日志如何配置？</a>、<a href=\"https://mp.weixin.qq.com/s/ute0JxWgqPe4VvKMbUQMNw\">Spring Boot第二弹，配置文件怎么造？</a>。</p>\n<p>下面以<strong>log4j2</strong>这款日志为例讲解一下日志如何脱敏，其他日志框架大致思路一样。</p>\n<h3 id=\"h3-1-log4j2-\"><a name=\"1. 添加log4j2日志依赖\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 添加log4j2日志依赖</h3><p>Spring Boot 默认日志框架是logback，但是我们可以切换到log4j2，依赖如下：</p>\n<pre><code class=\"lang-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n    &lt;!-- 去掉springboot默认配置 --&gt;\n    &lt;exclusions&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n    &lt;/exclusions&gt;\n&lt;/dependency&gt;\n&lt;!--使用log4j2替换 LogBack--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h3 id=\"h3-2-resource-log4j2-xml-\"><a name=\"2. 在/resource目录下新建log4j2.xml配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 在/resource目录下新建log4j2.xml配置</h3><p>log4j2的日志配置很简单，只需要在<code>/resource</code>文件夹下新建一个<code>log4j2.xml</code>配置文件，内容如下图：</p>\n<p><img src=\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F/1.png\" alt=\"\"></p>\n<p><img src=\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F/2.png\" alt=\"\"></p>\n<p>关于每个节点如何配置，含义是什么，在我上面的两篇文章中有详细的介绍。</p>\n<blockquote>\n<p>上图的配置并没有实现数据脱敏，这是普通的配置，使用的是<strong>PatternLayout</strong></p>\n</blockquote>\n<h3 id=\"h3-3-patternlayout-\"><a name=\"3.  自定义PatternLayout实现数据脱敏\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.  自定义PatternLayout实现数据脱敏</h3><p><strong>步骤</strong>2中的配置使用的是<code>PatternLayout</code>实现日志的格式，那么我们也可以自定义一个PatternLayout来实现日志的过滤脱敏。</p>\n<p>PatternLayout的类图继承关系如下：</p>\n<p><img src=\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F/3.png\" alt=\"\"></p>\n<p>从上图中可以清楚的看出来，PatternLayout继承了一个抽象类<code>AbstractStringLayout</code>，因此想要自定义只需要继承这个抽象类即可。</p>\n<p><strong>1、创建CustomPatternLayout，继承抽象类AbstractStringLayout</strong></p>\n<p>代码如下：</p>\n<pre><code class=\"lang-java\">/**\n * log4j2 脱敏插件\n * 继承AbstractStringLayout\n **/\n@Plugin(name = &quot;CustomPatternLayout&quot;, category = Node.CATEGORY, elementType = Layout.ELEMENT_TYPE, printObject = true)\npublic class CustomPatternLayout extends AbstractStringLayout {\n\n\n    public final static Logger logger = LoggerFactory.getLogger(CustomPatternLayout.class);\n    private PatternLayout patternLayout;\n\n\n    protected CustomPatternLayout(Charset charset, String pattern) {\n        super(charset);\n        patternLayout = PatternLayout.newBuilder().withPattern(pattern).build();\n        initRule();\n    }\n\n    /**\n     * 要匹配的正则表达式map\n     */\n    private static Map&lt;String, Pattern&gt; REG_PATTERN_MAP = new HashMap&lt;&gt;();\n    private static Map&lt;String, String&gt; KEY_REG_MAP = new HashMap&lt;&gt;();\n\n\n    private void initRule() {\n        try {\n            if (MapUtils.isEmpty(Log4j2Rule.regularMap)) {\n                return;\n            }\n            Log4j2Rule.regularMap.forEach((a, b) -&gt; {\n                if (StringUtils.isNotBlank(a)) {\n                    Map&lt;String, String&gt; collect = Arrays.stream(a.split(&quot;,&quot;)).collect(Collectors.toMap(c -&gt; c, w -&gt; b, (key1, key2) -&gt; key1));\n                    KEY_REG_MAP.putAll(collect);\n                }\n                Pattern compile = Pattern.compile(b);\n                REG_PATTERN_MAP.put(b, compile);\n            });\n\n        } catch (Exception e) {\n            logger.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt; 初始化日志脱敏规则失败 ERROR：{}&quot;, e);\n        }\n\n    }\n\n    /**\n     * 处理日志信息，进行脱敏\n     * 1.判断配置文件中是否已经配置需要脱敏字段\n     * 2.判断内容是否有需要脱敏的敏感信息\n     * 2.1 没有需要脱敏信息直接返回\n     * 2.2 处理: 身份证 ,姓名,手机号敏感信息\n     */\n    public String hideMarkLog(String logStr) {\n        try {\n            //1.判断配置文件中是否已经配置需要脱敏字段\n            if (StringUtils.isBlank(logStr) || MapUtils.isEmpty(KEY_REG_MAP) || MapUtils.isEmpty(REG_PATTERN_MAP)) {\n                return logStr;\n            }\n            //2.判断内容是否有需要脱敏的敏感信息\n            Set&lt;String&gt; charKeys = KEY_REG_MAP.keySet();\n            for (String key : charKeys) {\n                if (logStr.contains(key)) {\n                    String regExp = KEY_REG_MAP.get(key);\n                    logStr = matchingAndEncrypt(logStr, regExp, key);\n                }\n            }\n            return logStr;\n        } catch (Exception e) {\n            logger.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 脱敏处理异常 ERROR:{}&quot;, e);\n            //如果抛出异常为了不影响流程，直接返回原信息\n            return logStr;\n        }\n    }\n\n    /**\n     * 正则匹配对应的对象。\n     *\n     * @param msg\n     * @param regExp\n     * @return\n     */\n    private static String matchingAndEncrypt(String msg, String regExp, String key) {\n        Pattern pattern = REG_PATTERN_MAP.get(regExp);\n        if (pattern == null) {\n            logger.info(&quot;&gt;&gt;&gt; logger 没有匹配到对应的正则表达式 &quot;);\n            return msg;\n        }\n        Matcher matcher = pattern.matcher(msg);\n        int length = key.length() + 5;\n        boolean contains = Log4j2Rule.USER_NAME_STR.contains(key);\n        String hiddenStr = &quot;&quot;;\n        while (matcher.find()) {\n            String originStr = matcher.group();\n            if (contains) {\n                // 计算关键词和需要脱敏词的距离小于5。\n                int i = msg.indexOf(originStr);\n                if (i &lt; 0) {\n                    continue;\n                }\n                int span = i - length;\n                int startIndex = span &gt;= 0 ? span : 0;\n                String substring = msg.substring(startIndex, i);\n                if (StringUtils.isBlank(substring) ||  !substring.contains(key)) {\n                    continue;\n                }\n                hiddenStr = hideMarkStr(originStr);\n                msg = msg.replace(originStr, hiddenStr);\n            } else {\n                hiddenStr = hideMarkStr(originStr);\n                msg = msg.replace(originStr, hiddenStr);\n            }\n\n        }\n        return msg;\n    }\n\n    /**\n     * 标记敏感文字规则\n     *\n     * @param needHideMark\n     * @return\n     */\n    private static String hideMarkStr(String needHideMark) {\n        if (StringUtils.isBlank(needHideMark)) {\n            return &quot;&quot;;\n        }\n        int startSize = 0, endSize = 0, mark = 0, length = needHideMark.length();\n\n        StringBuffer hideRegBuffer = new StringBuffer(&quot;(\\\\S{&quot;);\n        StringBuffer replaceSb = new StringBuffer(&quot;$1&quot;);\n\n        if (length &gt; 4) {\n            int i = length / 3;\n            startSize = i;\n            endSize = i;\n        } else {\n            startSize = 1;\n            endSize = 0;\n        }\n\n        mark = length - startSize - endSize;\n        for (int i = 0; i &lt; mark; i++) {\n            replaceSb.append(&quot;*&quot;);\n        }\n        hideRegBuffer.append(startSize).append(&quot;})\\\\S*(\\\\S{&quot;).append(endSize).append(&quot;})&quot;);\n        replaceSb.append(&quot;$2&quot;);\n        needHideMark = needHideMark.replaceAll(hideRegBuffer.toString(), replaceSb.toString());\n        return needHideMark;\n    }\n\n\n    /**\n     * 创建插件\n     */\n    @PluginFactory\n    public static Layout createLayout(@PluginAttribute(value = &quot;pattern&quot;) final String pattern,\n                                      @PluginAttribute(value = &quot;charset&quot;) final Charset charset) {\n        return new CustomPatternLayout(charset, pattern);\n    }\n\n\n    @Override\n    public String toSerializable(LogEvent event) {\n        return hideMarkLog(patternLayout.toSerializable(event));\n    }\n\n}\n</code></pre>\n<p>关于其中的一些细节，比如<code><a href=\"https://github.com/Plugin\" title=\"&#64;Plugin\" class=\"at-link\">@Plugin</a></code>、<code><a href=\"https://github.com/PluginFactory\" title=\"&#64;PluginFactory\" class=\"at-link\">@PluginFactory</a></code>这两个注解什么意思？log4j2如何实现自定义一个插件，这里不再详细介绍，不是本文重点，有兴趣的可以查看<code>log4j2</code>的官方文档。</p>\n<p><strong>2、自定义自己的脱敏规则</strong></p>\n<p>上述代码中的<code>Log4j2Rule</code>则是脱敏规则静态类，我这里是直接放在了静态类中配置，实际项目中可以设置到配置文件中，代码如下：</p>\n<pre><code class=\"lang-java\">/**\n * 现在拦截加密的日志有三类:\n * 1，身份证\n * 2，姓名\n * 3，身份证号\n * 加密的规则后续可以优化在配置文件中\n **/\npublic class Log4j2Rule {\n\n    /**\n     * 正则匹配 关键词 类别\n     */\n    public static Map&lt;String, String&gt; regularMap = new HashMap&lt;&gt;();\n    /**\n     * TODO  可配置\n     * 此项可以后期放在配置项中\n     */\n    public static final String USER_NAME_STR = &quot;Name,name,联系人,姓名&quot;;\n    public static final String USER_IDCARD_STR = &quot;empCard,idCard,身份证,证件号&quot;;\n    public static final String USER_PHONE_STR = &quot;mobile,Phone,phone,电话,手机&quot;;\n\n    /**\n     * 正则匹配，自己根据业务要求自定义\n     */\n    private static String IDCARD_REGEXP = &quot;(\\\\d{17}[0-9Xx]|\\\\d{14}[0-9Xx])&quot;;\n    private static String USERNAME_REGEXP = &quot;[\\\\u4e00-\\\\u9fa5]{2,4}&quot;;\n    private static String PHONE_REGEXP = &quot;(?&lt;!\\\\d)(?:(?:1[3456789]\\\\d{9})|(?:861[356789]\\\\d{9}))(?!\\\\d)&quot;;\n\n    static {\n        regularMap.put(USER_NAME_STR, USERNAME_REGEXP);\n        regularMap.put(USER_IDCARD_STR, IDCARD_REGEXP);\n        regularMap.put(USER_PHONE_STR, PHONE_REGEXP);\n    }\n\n}\n</code></pre>\n<p>经过上述两个步骤，自定义的<code>PatternLayout</code>已经完成，下面将是改写<code>log4j2.xml</code>这个配置文件了。</p>\n<h3 id=\"h3-4-log4j2-xml-\"><a name=\"4. 修改log4j2.xml配置文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 修改log4j2.xml配置文件</h3><p>其实这里修改很简单，原配置文件是直接使用<code>PatternLayout</code>进行日志格式化的，那么只需要将默认的<code>&lt;PatternLayout/&gt;</code>这个节点替换成<code>&lt;CustomPatternLayout/&gt;</code>，如下图：</p>\n<p><img src=\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F/4.png\" alt=\"\"></p>\n<p>直接全局替换掉即可，至此，这个配置文件就修改完成了。</p>\n<h3 id=\"h3-5-\"><a name=\"5. 演示效果\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5. 演示效果</h3><p>在<strong>步骤3</strong>这边自定义了脱敏规则静态类<code>Log4j2Rule</code>，其中定义了姓名、身份证、号码这三个脱敏规则，如下：</p>\n<p><img src=\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F/5.png\" alt=\"\"></p>\n<p>下面就来演示这三个规则能否正确脱敏，直接使用日志打印，代码如下：</p>\n<pre><code class=\"lang-java\">@Test\npublic void test3(){\n    log.debug(&quot;身份证：{}，姓名：{}，电话：{}&quot;,&quot;320829112334566767&quot;,&quot;不才陈某&quot;,&quot;19896327106&quot;);\n}\n</code></pre>\n<p>控制台打印的日志如下：</p>\n<pre><code class=\"lang-java\">身份证：320829******566767，姓名：不***，电话：198*****106\n</code></pre>\n<p>哦豁，成功了，so easy！！！</p>\n<h3 id=\"h3-6-\"><a name=\"6. 总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6. 总结</h3><p>日志脱敏的方案很多，陈某也只是介绍一种常用的，有兴趣的可以研究一下。</p>\n<h2 id=\"h2--\"><a name=\"五、总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、总结</h2><p>本篇文章从三个维度介绍了隐私数据的脱敏实现方案，码字不易，赶紧点赞收藏吧！！！</p>\n<blockquote>\n<p>源码已经上传GitHub，需要的公众号码猿技术专栏，回复关键词<code>数据脱敏</code>获取。</p>\n</blockquote>\n', 'Springboot 日志、配置文件、接口数据如何脱敏？老鸟们都是这样玩的！', 1, 0, 'https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%BC%98%E8%B4%A8%E8%A7%86%E9%A2%91%E8%B5%84%E6%BA%90/1.png', 1, 1, 1, 1, 2, '2022-03-06 18:20:06', '2022-03-06 18:21:59');
INSERT INTO `article` VALUES (8, '552955219609124864', '94dd9d02befd4dac9d6e708ff92f7d82', 2, 'Spring Boot 第 十二弹，Spring Boot整合多点套路，少走点弯路！！！', '<h2 id=\"h2--\"><a name=\"持续原创输出，点击上方蓝字关注我\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>持续原创输出，点击上方蓝字关注我</h2><p><img src=\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%BC%B9%EF%BC%8CSpring%20Boot%E6%95%B4%E5%90%88%E5%A4%9A%E7%82%B9%E5%A5%97%E8%B7%AF%EF%BC%8C%E5%B0%91%E8%B5%B0%E5%BC%AF%E8%B7%AF%EF%BC%81%EF%BC%81%EF%BC%81/1.jpg\" alt=\"\"></p>\n<blockquote>\n<p>个人原创博客+1，<a href=\"https://chenjiabing666.github.io/\">点击前往，查看更多</a></p>\n</blockquote>\n<h2 id=\"h2-u76EEu5F55\"><a name=\"目录\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>目录</h2><ul>\n<li>前言</li><li>Spring Boot 版本</li><li><ol>\n<li>找到自动配置类</li></ol>\n</li><li><ol>\n<li>注意<code><a href=\"https://github.com/Conditionalxxx\" title=\"&#64;Conditionalxxx\" class=\"at-link\"><a href=\"https://github.com/Conditionalxxx\" title=\"&#64;Conditionalxxx\" class=\"at-link\">@Conditionalxxx</a></a></code>注解</li></ol>\n</li><li><ol>\n<li>注意<code>EnableConfigurationProperties</code>注解</li></ol>\n</li><li><ol>\n<li>注意<code><a href=\"https://github.com/Import\" title=\"&#64;Import\" class=\"at-link\"><a href=\"https://github.com/Import\" title=\"&#64;Import\" class=\"at-link\">@Import</a></a></code>注解</li></ol>\n</li><li><ol>\n<li>注意<code><a href=\"https://github.com/AutoConfigurexxx\" title=\"&#64;AutoConfigurexxx\" class=\"at-link\"><a href=\"https://github.com/AutoConfigurexxx\" title=\"&#64;AutoConfigurexxx\" class=\"at-link\">@AutoConfigurexxx</a></a></code>注解</li></ol>\n</li><li><ol>\n<li>注意内部静态配置类</li></ol>\n</li><li>总结</li></ul>\n<h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>网上有很多文章都在说<code>Spring Boot 如何整合 xxx</code>，有文章教你为什么这么整合吗？整合了千万个框架，其实套路就那么几个，干嘛要学千万个，不如来这学习几个套路轻松整合，它不香吗？？？</p>\n<p>今天写这篇文章的目的就是想从思想上教给大家几个套路，不用提到整合什么就去百度了，自己尝试去亲手整合一个。</p>\n<h2 id=\"h2-spring-boot-\"><a name=\"Spring Boot 版本\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Spring Boot 版本</h2><p>本文基于的Spring Boot的版本是<code>2.3.4.RELEASE</code>。</p>\n<h2 id=\"h2-1-\"><a name=\"1. 找到自动配置类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 找到自动配置类</h2><p>Spring Boot 在整合任何一个组件的时候都会先添加一个依赖<code>starter</code>，比如整合的Mybatis有一个<code>mybatis-spring-boot-starter</code>，依赖如下：</p>\n<pre><code class=\"lang-xml\">&lt;dependency&gt;\n         &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;\n         &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;\n        &lt;version&gt;2.0.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>每一个<code>starter</code>基本都会有一个自动配置类，命名方式也是类似的，格式为：<code>xxxAutoConfiguration</code>，比如Mybatis的自动配置类就是<code>MybatisAutoConfiguration</code>，<code>Redis</code>的自动配置类是<code>RedisAutoConfiguration</code>，<code>WEB</code>模块的自动配置类是<code>WebMvcAutoConfiguration</code>。</p>\n<h2 id=\"h2-2-conditionalxxx-\"><a name=\"2. 注意@Conditionalxxx注解\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 注意<a href=\"https://github.com/Conditionalxxx\" title=\"&#64;Conditionalxxx\" class=\"at-link\">@Conditionalxxx</a>注解</h2><p><code><a href=\"https://github.com/Conditionalxxx\" title=\"&#64;Conditionalxxx\" class=\"at-link\">@Conditionalxxx</a></code>标注在配置类上或者结合<code><a href=\"https://github.com/Bean\" title=\"&#64;Bean\" class=\"at-link\">@Bean</a></code>标注在方法上，究竟是什么意思，在上一篇文章<a href=\"https://mp.weixin.qq.com/s/BoujdCIHPK79jT9RKAmyug\">这类注解都不知道，还好意思说会Spring Boot</a>已经从表层到底层深入的讲了一遍，不理解的可以查阅一下。</p>\n<blockquote>\n<p>首先需要注意自动配置类上的<code><a href=\"https://github.com/Conditionalxxx\" title=\"&#64;Conditionalxxx\" class=\"at-link\">@Conditionalxxx</a></code>注解，这个是自动配置类生效的条件。</p>\n</blockquote>\n<p>比如<code>WebMvcAutoConfiguration</code>类上标了一个如下注解：</p>\n<pre><code class=\"lang-java\">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)\n</code></pre>\n<p>以上这行代码的意思就是当前IOC容器中没有<code>WebMvcConfigurationSupport</code>这个类的实例时自动配置类才会生效，这也就是在配置类上标注<code><a href=\"https://github.com/EnableWebMvc\" title=\"&#64;EnableWebMvc\" class=\"at-link\">@EnableWebMvc</a></code>会导致自动配置类<code>WebMvcAutoConfiguration</code>失效的原因。</p>\n<blockquote>\n<p>其次需要注意方法上的<code><a href=\"https://github.com/Conditionalxxx\" title=\"&#64;Conditionalxxx\" class=\"at-link\">@Conditionalxxx</a></code>注解，Spring Boot会在自动配置类中结合<code><a href=\"https://github.com/Bean\" title=\"&#64;Bean\" class=\"at-link\">@Bean</a></code>和<code><a href=\"https://github.com/Conditionalxxx\" title=\"&#64;Conditionalxxx\" class=\"at-link\">@Conditionalxxx</a></code>注解提供一些组件运行的默认配置，但是利用<code><a href=\"https://github.com/Conditionalxxx\" title=\"&#64;Conditionalxxx\" class=\"at-link\">@Conditionalxxx</a></code>（在特定条件下生效）注解的<code>条件性</code>，方便开发者覆盖这些配置。</p>\n</blockquote>\n<p>比如在Mybatis的自动配置类<code>MybatisAutoConfiguration</code>中有如下一个方法：</p>\n<pre><code class=\"lang-java\">  @Bean\n  @ConditionalOnMissingBean\n  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {}\n</code></pre>\n<p>以上这个方法不用看方法体的内容，只看方法上的注解。<code><a href=\"https://github.com/Bean\" title=\"&#64;Bean\" class=\"at-link\">@Bean</a></code>这个注解的意思是注入一个<code>Bean</code>到<code>IOC容器</code>中，<code><a href=\"https://github.com/ConditionalOnMissingBean\" title=\"&#64;ConditionalOnMissingBean\" class=\"at-link\">@ConditionalOnMissingBean</a></code>这个注解就是一个条件判断了，表示当<code>SqlSessionFactory</code>类型的对象在<code>IOC容器</code>中不存在才会注入。</p>\n<p>哦？领悟到了吧，<strong>言外之意就是如果开发者需要定制<code>SqlSessionFactory</code>，则可以自己的创建一个<code>SqlSessionFactory</code>类型的对象并且注入到IOC容器中即能覆盖自动配置类中的</strong>。比如在Mybatis配置多数据源的时候就需要定制一个<code>SqlSessionFactory</code>而不是使用自动配置类中的。</p>\n<blockquote>\n<p>总之，一定要注意自动配置类上或者方法上的<code><a href=\"https://github.com/Conditionalxxx\" title=\"&#64;Conditionalxxx\" class=\"at-link\">@Conditionalxxx</a></code>注解，这个注解表示某种特定条件。</p>\n</blockquote>\n<p>下面列出了常用的几种注解，如下：</p>\n<ol>\n<li><code><a href=\"https://github.com/ConditionalOnBean\" title=\"&#64;ConditionalOnBean\" class=\"at-link\">@ConditionalOnBean</a></code>：当容器中有指定Bean的条件下进行实例化。</li><li><code><a href=\"https://github.com/ConditionalOnMissingBean\" title=\"&#64;ConditionalOnMissingBean\" class=\"at-link\">@ConditionalOnMissingBean</a></code>：当容器里没有指定Bean的条件下进行实例化。</li><li><code><a href=\"https://github.com/ConditionalOnClass\" title=\"&#64;ConditionalOnClass\" class=\"at-link\">@ConditionalOnClass</a></code>：当classpath类路径下有指定类的条件下进行实例化。</li><li><code><a href=\"https://github.com/ConditionalOnMissingClass\" title=\"&#64;ConditionalOnMissingClass\" class=\"at-link\">@ConditionalOnMissingClass</a></code>：当类路径下没有指定类的条件下进行实例化。</li><li><code><a href=\"https://github.com/ConditionalOnWebApplication\" title=\"&#64;ConditionalOnWebApplication\" class=\"at-link\">@ConditionalOnWebApplication</a></code>：当项目是一个Web项目时进行实例化。</li><li><code><a href=\"https://github.com/ConditionalOnNotWebApplication\" title=\"&#64;ConditionalOnNotWebApplication\" class=\"at-link\">@ConditionalOnNotWebApplication</a></code>：当项目不是一个Web项目时进行实例化。</li><li><code><a href=\"https://github.com/ConditionalOnProperty\" title=\"&#64;ConditionalOnProperty\" class=\"at-link\">@ConditionalOnProperty</a></code>：当指定的属性有指定的值时进行实例化。</li><li><code><a href=\"https://github.com/ConditionalOnExpression\" title=\"&#64;ConditionalOnExpression\" class=\"at-link\">@ConditionalOnExpression</a></code>：基于SpEL表达式的条件判断。</li><li><code><a href=\"https://github.com/ConditionalOnJava\" title=\"&#64;ConditionalOnJava\" class=\"at-link\">@ConditionalOnJava</a></code>：当JVM版本为指定的版本范围时触发实例化。</li><li><code><a href=\"https://github.com/ConditionalOnResource\" title=\"&#64;ConditionalOnResource\" class=\"at-link\">@ConditionalOnResource</a></code>：当类路径下有指定的资源时触发实例化。</li><li><code><a href=\"https://github.com/ConditionalOnJndi\" title=\"&#64;ConditionalOnJndi\" class=\"at-link\">@ConditionalOnJndi</a></code>：在JNDI存在的条件下触发实例化。</li><li><code><a href=\"https://github.com/ConditionalOnSingleCandidate\" title=\"&#64;ConditionalOnSingleCandidate\" class=\"at-link\">@ConditionalOnSingleCandidate</a></code>：当指定的Bean在容器中只有一个，或者有多个但是指定了首选的Bean时触发实例化。</li></ol>\n<h2 id=\"h2-3-enableconfigurationproperties-\"><a name=\"3. 注意EnableConfigurationProperties注解\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 注意EnableConfigurationProperties注解</h2><p><code>EnableConfigurationProperties</code>这个注解常标注在配置类上，使得<code><a href=\"https://github.com/ConfigurationProperties\" title=\"&#64;ConfigurationProperties\" class=\"at-link\">@ConfigurationProperties</a></code>标注的配置文件生效，这样就可以在全局配置文件（<code>application.xxx</code>）配置指定前缀的属性了。</p>\n<p>在Redis的自动配置类<code>RedisAutoConfiguration</code>上方标注如下一行代码：</p>\n<pre><code class=\"lang-java\">@EnableConfigurationProperties(RedisProperties.class)\n</code></pre>\n<p>这行代码有意思了，我们可以看看<code>RedisProperties</code>的源码，如下：</p>\n<pre><code class=\"lang-java\">@ConfigurationProperties(prefix = &quot;spring.redis&quot;)\npublic class RedisProperties {\n    private int database = 0;\n    private String url;\n    private String host = &quot;localhost&quot;;\n    private String password;\n  .....\n</code></pre>\n<p><code><a href=\"https://github.com/ConfigurationProperties\" title=\"&#64;ConfigurationProperties\" class=\"at-link\">@ConfigurationProperties</a></code>这个注解指定了全局配置文件中以<code>spring.redis.xxx</code>为前缀的配置都会映射到<code>RedisProperties</code>的指定属性中，其实<code>RedisProperties</code>这个类中定义了Redis的一些所需属性，比如<code>host</code>，<code>IP地址</code>，<code>密码</code>等等。</p>\n<p><strong><code><a href=\"https://github.com/EnableConfigurationProperties\" title=\"&#64;EnableConfigurationProperties\" class=\"at-link\">@EnableConfigurationProperties</a></code>注解就是使得指定的配置生效，能够将全局配置文件中配置的属性映射到相关类的属性中。</strong></p>\n<p><strong>为什么要注意<code><a href=\"https://github.com/EnableConfigurationProperties\" title=\"&#64;EnableConfigurationProperties\" class=\"at-link\">@EnableConfigurationProperties</a></code>这个注解呢？</strong></p>\n<blockquote>\n<p>引入一个组件后往往需要改些配置，我们都知道在全局配置文件中可以修改，但是不知道前缀是什么，可以改哪些属性，因此找到<code><a href=\"https://github.com/EnableConfigurationProperties\" title=\"&#64;EnableConfigurationProperties\" class=\"at-link\">@EnableConfigurationProperties</a></code>这个注解后就能找到对应的配置前缀以及可以修改的属性了。</p>\n</blockquote>\n<h2 id=\"h2-4-import-\"><a name=\"4. 注意@Import注解\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 注意<a href=\"https://github.com/Import\" title=\"&#64;Import\" class=\"at-link\">@Import</a>注解</h2><p>这个注解有点牛逼了，<code>Spring 3.x</code>中就已经有的一个注解，大致的意思的就是快速导入一个Bean或者配置类到IOC容器中。这个注解有很多妙用，后续会单独写篇文章介绍下。</p>\n<blockquote>\n<p><code><a href=\"https://github.com/Import\" title=\"&#64;Import\" class=\"at-link\">@Import</a></code>这个注解通常标注在自动配置类上方，并且一般都是导入一个或者多个配置类。</p>\n</blockquote>\n<p>比如<code>RabbitMQ</code>的自动配置类<code>RabbitAutoConfiguration</code>上有如下一行代码：</p>\n<pre><code class=\"lang-java\">@Import(RabbitAnnotationDrivenConfiguration.class)\n</code></pre>\n<p>这行代码的作用就是添加了<code>RabbitAnnotationDrivenConfiguration</code>这个配置类，使得Spring Boot在加载到自动配置类的时候能够一起加载。</p>\n<p>比如Redis的自动配置类<code>RedisAutoConfiguration</code>上有如下一行代码：</p>\n<pre><code class=\"lang-java\">@Import({ LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class })\n</code></pre>\n<p>这个<code><a href=\"https://github.com/Import\" title=\"&#64;Import\" class=\"at-link\">@Import</a></code>同时引入了<code>Lettuce</code>和<code>Jedis</code>两个配置类了，因此如果你的Redis需要使用Jedis作为连接池的话，想要知道Jedis都要配置什么，此时就应该看看<code>JedisConnectionConfiguration</code>这个配置类了。</p>\n<blockquote>\n<p><strong>总结</strong>：<code><a href=\"https://github.com/Import\" title=\"&#64;Import\" class=\"at-link\">@Import</a></code>标注在自动配置类上方，一般都是快速导入一个或者多个配置类，因此如果自动配置类没有配置一些东西时，一定要看看<code><a href=\"https://github.com/Import\" title=\"&#64;Import\" class=\"at-link\">@Import</a></code>这个注解导入的配置类。</p>\n</blockquote>\n<h2 id=\"h2-5-autoconfigurexxx-\"><a name=\"5. 注意@AutoConfigurexxx注解\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5. 注意<a href=\"https://github.com/AutoConfigurexxx\" title=\"&#64;AutoConfigurexxx\" class=\"at-link\">@AutoConfigurexxx</a>注解</h2><p><code><a href=\"https://github.com/AutoConfigurexxx\" title=\"&#64;AutoConfigurexxx\" class=\"at-link\">@AutoConfigurexxx</a></code>这类注解决定了自动配置类的加载顺序，比如<code>AutoConfigureAfter</code>（在指定自动配置类之后）、<code>AutoConfigureBefore</code>（在指定自动配置类之前）、<code>AutoConfigureOrder</code>（指定自动配置类的优先级）。</p>\n<blockquote>\n<p>为什么要注意顺序呢？因为某些组件往往之间是相互依赖的，比如<code>Mybatis</code>和<code>DataSource</code>，肯定要先将数据源相关的东西配置成功才能配置<code>Mybatis</code>吧。<code><a href=\"https://github.com/AutoConfigurexxx\" title=\"&#64;AutoConfigurexxx\" class=\"at-link\">@AutoConfigurexxx</a></code>这类注解正是解决了组件之间相互依赖的问题。</p>\n</blockquote>\n<p>比如<code>MybatisAutoConfiguration</code>上方标注了如下一行代码：</p>\n<pre><code class=\"lang-java\">@AutoConfigureAfter(DataSourceAutoConfiguration.class)\n</code></pre>\n<p>这个行代码意思很简单，就是<code>MybatisAutoConfiguration</code>这个自动配置在<code>DataSourceAutoConfiguration</code>这个之后加载，因为你需要我，多么简单的理由。</p>\n<p>好了，这下明白了吧，以后别犯傻问：<strong>为什么Mybatis配置好了，启动会报错</strong>？这个问题先看看数据源有没有配置成功吧。</p>\n<h2 id=\"h2-6-\"><a name=\"6. 注意内部静态配置类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6. 注意内部静态配置类</h2><p>有些自动配置类比较简单没那么多套路，比如<code>RedisAutoConfiguration</code>这个自动配置类中就定义了两个注入Bean的方法，其他的没了。</p>\n<p>但是有些自动配置类就没那么单纯了，中间能嵌套<code>n</code>个静态配置类，比如<code>WebMvcAutoConfiguration</code>，类中还嵌套了<code>WebMvcAutoConfigurationAdapter</code>、<code>EnableWebMvcConfiguration</code>、<code>ResourceChainCustomizerConfiguration</code>这三个配置类。如果你光看<code>WebMvcAutoConfiguration</code>这个自动配置类好像没配置什么，但是其内部却是大有乾坤啊。</p>\n<blockquote>\n<p><strong>总结</strong>：一定要自动配置类的内部嵌套的配置类，真是大有乾坤啊。</p>\n</blockquote>\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>以上总结了六条整合的套路，希望能够帮助读者摆脱百度，自己也能独立整合组件。</p>\n<p>总之，Spring Boot整合xxx组件的文章很多，相信大家也看的比较懵，其实套路都是一样，学会陈某分享的套路，让你少走弯路！！！</p>\n<p><img src=\"https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png\" alt=\"\"></p>\n', 'Spring Boot 第 十二弹，Spring Boot整合多点套路，少走点弯路！！！', 1, 0, 'https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%BC%98%E8%B4%A8%E8%A7%86%E9%A2%91%E8%B5%84%E6%BA%90/1.png', 1, 1, 1, 1, 2, '2022-03-06 20:46:38', '2022-03-06 20:46:38');
INSERT INTO `article` VALUES (9, '552955376010526720', '94dd9d02befd4dac9d6e708ff92f7d82', 2, 'Spring Boot 第二弹，配置文件怎么造？', '<h2 id=\"h2--\"><a name=\"持续原创输出，点击上方蓝字关注我吧\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>持续原创输出，点击上方蓝字关注我吧</h2><p><img src=\"https://gitee.com/chenjiabing666/Blog-file/raw/master/springBoot%E7%AC%AC%E4%BA%8C%E5%BC%B9%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%80%8E%E4%B9%88%E9%80%A0%EF%BC%9F/1.jpeg\" alt=\"\"></p>\n<h2 id=\"h2-u76EEu5F55\"><a name=\"目录\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>目录</h2><ul>\n<li>前言</li><li>properties格式简介</li><li>YML格式简介<ul>\n<li>如何使用</li><li>总结</li></ul>\n</li><li>如何从配置文件取值？<ul>\n<li><a href=\"https://github.com/ConfigurationProperties\" title=\"&#64;ConfigurationProperties\" class=\"at-link\"><a href=\"https://github.com/ConfigurationProperties\" title=\"&#64;ConfigurationProperties\" class=\"at-link\">@ConfigurationProperties</a></a></li><li><a href=\"https://github.com/Value\" title=\"&#64;Value\" class=\"at-link\"><a href=\"https://github.com/Value\" title=\"&#64;Value\" class=\"at-link\">@Value</a></a></li></ul>\n</li><li>如何从自定义配置文件中取值？</li></ul>\n<h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>自从用了Spring Boot，个人最喜欢的就是Spring Boot的配置文件了，和Spring比起，Spring Boot更加灵活，修改的某些配置也是更加得心应手。</p>\n<p>Spring Boot 官方提供了两种常用的配置文件格式，分别是<code>properties</code>、<code>YML</code>格式。相比于<code>properties</code>来说，<code>YML</code>更加年轻，层级也是更加分明。</p>\n<p>今天这篇文章就来介绍一下Spring Boot的配置文件的语法以及如何从配置文件中取值。</p>\n<h2 id=\"h2-properties-\"><a name=\"properties格式简介\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>properties格式简介</h2><p>常见的一种配置文件格式，Spring中也是用这种格式，语法结构很简单，结构为：<code>key=value</code>。具体如下：</p>\n<pre><code class=\"lang-properties\">userinfo.name=myjszl\nuserinfo.age=25\nuserinfo.active=true\nuserinfo.created-date=2018/03/31 16:54:30\nuserinfo.map.k1=v1\nuserinfo.map.k2=v2\n</code></pre>\n<p>上述配置文件中对应的实体类如下：</p>\n<pre><code class=\"lang-java\">@Data\n@ToString\npublic class UserInfo {\n    private String name;\n    private Integer age;\n    private Boolean active;\n    private Map&lt;String,Object&gt; map;\n    private Date createdDate;\n    private List&lt;String&gt; hobbies;\n}\n</code></pre>\n<p>结构很简单，无非就是<code>key=value</code>这种形式，也是在开发中用的比较多的一种格式。</p>\n<h2 id=\"h2-yml-\"><a name=\"YML格式简介\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>YML格式简介</h2><p>以空格的缩进程度来控制层级关系。空格的个数并不重要，只要左边空格对齐则视为同一个层级。注意不能用<code>tab</code>代替空格。且大小写敏感。支持字面值，对象，数组三种数据结构，也支持复合结构。</p>\n<p><strong>字面值</strong>：字符串，布尔类型，数值，日期。字符串默认不加引号，单引号会转义特殊字符。日期格式支持<code>yyyy/MM/dd HH:mm:ss</code></p>\n<p><strong>对象</strong>：由键值对组成，形如 key:(空格)value 的数据组成。冒号后面的空格是必须要有的，每组键值对占用一行，且缩进的程度要一致，也可以使用行内写法：<code>{k1: v1, ....kn: vn}</code></p>\n<p><strong>数组</strong>：由形如 -(空格)value 的数据组成。短横线后面的空格是必须要有的，每组数据占用一行，且缩进的程度要一致，也可以使用行内写法：<code>[1,2,...n]</code></p>\n<p><strong>复合结构</strong>：上面三种数据结构任意组合</p>\n<h3 id=\"h3-u5982u4F55u4F7Fu7528\"><a name=\"如何使用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>如何使用</h3><p>在<code>src/resources</code>文件夹下创建一个<code>application.yml</code>文件。支持的类型主要有字符串，带特殊字符的字符串，布尔类型，数值，集合，行内集合，行内对象，集合对象这几种常用的数据格式。</p>\n<p>具体的示例如下：</p>\n<pre><code class=\"lang-yml\">userinfo:\n    age: 25\n    name: myjszl\n    active: true\n    created-date: 2018/03/31 16:54:30\n    map: {k1: v1,k2: v2}\n    hobbies:\n      - one\n      - two\n      - three\n</code></pre>\n<p>上述配置文件对应的实体类如下：</p>\n<pre><code class=\"lang-java\">@Data\n@ToString\npublic class UserInfo {\n    private String name;\n    private Integer age;\n    private Boolean active;\n    private Map&lt;String,Object&gt; map;\n    private Date createdDate;\n    private List&lt;String&gt; hobbies;\n}\n</code></pre>\n<h3 id=\"h3-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h3><p>YML是一种新式的格式，层级鲜明，个人比较喜欢使用的一种格式，注意如下：</p>\n<ol>\n<li><strong>字符串可以不加引号，若加双引号则输出特殊字符，若不加或加单引号则转义特殊字符</strong></li><li><strong>数组类型，短横线后面要有空格；对象类型，冒号后面要有空格</strong></li><li><strong>YAML是以空格缩进的程度来控制层级关系，但不能用tab键代替空格，大小写敏感</strong></li></ol>\n<h2 id=\"h2--\"><a name=\"如何从配置文件取值？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>如何从配置文件取值？</h2><p>一切的配置都是为了取值，Spring Boot也是提供了几种取值的方式，下面一一介绍。</p>\n<h3 id=\"h3--configurationproperties\"><a name=\"@ConfigurationProperties\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><a href=\"https://github.com/ConfigurationProperties\" title=\"&#64;ConfigurationProperties\" class=\"at-link\">@ConfigurationProperties</a></h3><p>这个注解用于从配置文件中取值，支持复杂的数据类型，但是不支持<code>SPEL</code>表达式。</p>\n<p>该注解中有一个属性<code>prefix</code>，用于指定获配置的前缀，毕竟配置文件中的属性很多，也有很多重名的，必须用一个前缀来区分下。</p>\n<p><strong>该注解可以标注在类上也可以标注在方法上，这也注定了它有两种获取值的方式。</strong></p>\n<h4 id=\"h4-1-\"><a name=\"1. 标注在实体类上\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 标注在实体类上</h4><p>这种方式用于从实体类上取值，并且赋值到对应的属性。使用如下：</p>\n<pre><code class=\"lang-java\">/**\n * @Component ：注入到IOC容器中\n * @ConfigurationProperties：从配置文件中读取文件\n */\n@Component\n@ConfigurationProperties(prefix = &quot;userinfo&quot;)\n@Data\n@ToString\npublic class UserInfo {\n    private String name;\n    private Integer age;\n    private Boolean active;\n    private Map&lt;String,Object&gt; map;\n    private Date createdDate;\n    private List&lt;String&gt; hobbies;\n}\n</code></pre>\n<h4 id=\"h4-u6807u6CE8u5728u914Du7F6Eu7C7Bu4E2Du7684u65B9u6CD5u4E0A\"><a name=\"标注在配置类中的方法上\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>标注在配置类中的方法上</h4><p>标注在配置类上的方法上，同样是从配置文件中取值赋值到返回值的属性中。使用如下：</p>\n<pre><code class=\"lang-java\">    /**\n     * @Bean : 将返回的结果注入到IOC容器中\n     * @ConfigurationProperties ：从配置文件中取值\n     * @return\n     */\n    @ConfigurationProperties(prefix = &quot;userinfo&quot;)\n    @Bean\n    public UserInfo userInfo(){\n        return new UserInfo();\n    }\n</code></pre>\n<h4 id=\"h4-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h4><p><code><a href=\"https://github.com/ConfigurationProperties\" title=\"&#64;ConfigurationProperties\" class=\"at-link\">@ConfigurationProperties</a></code>注解能够很轻松的从配置文件中取值，优点如下：</p>\n<ol>\n<li>支持批量的注入属性，只需要指定一个前缀<code>prefix</code></li><li>支持复杂的数据类型，比如<code>List</code>、<code>Map</code></li><li>对属性名匹配的要求较低，比如<code>user-name</code>，<code>user_name</code>，<code>userName</code>，<code>USER_NAME</code>都可以取值</li><li>支持JAVA的JSR303数据校验</li></ol>\n<p><strong>注意：<code><a href=\"https://github.com/ConfigurationProperties\" title=\"&#64;ConfigurationProperties\" class=\"at-link\">@ConfigurationProperties</a></code>这个注解仅仅是支持从Spring Boot的默认配置文件中取值，比如<code>application.properties</code>、<code>application.yml</code>。</strong></p>\n<h3 id=\"h3--value\"><a name=\"@Value\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><a href=\"https://github.com/Value\" title=\"&#64;Value\" class=\"at-link\">@Value</a></h3><p><code><a href=\"https://github.com/Value\" title=\"&#64;Value\" class=\"at-link\">@Value</a></code>这个注解估计很熟悉了，Spring中从属性取值的注解，支持<code>SPEL</code>表达式，不支持复杂的数据类型，比如<code>List</code>。使用如下：</p>\n<pre><code class=\"lang-java\">    @Value(&quot;${userinfo.name}&quot;)\n    private String UserName;\n</code></pre>\n<h2 id=\"h2--\"><a name=\"如何从自定义配置文件中取值？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>如何从自定义配置文件中取值？</h2><p>Spring Boot在启动的时候会自动加载<code>application.xxx</code>和<code>bootsrap.xxx</code>，但是为了区分，有时候需要自定义一个配置文件，那么如何从自定义的配置文件中取值呢？此时就需要配合<code><a href=\"https://github.com/PropertySource\" title=\"&#64;PropertySource\" class=\"at-link\">@PropertySource</a></code>这个注解使用了。</p>\n<p>只需要在配置类上标注<code><a href=\"https://github.com/PropertySource\" title=\"&#64;PropertySource\" class=\"at-link\">@PropertySource</a></code>并指定你自定义的配置文件即可完成。如下：</p>\n<pre><code class=\"lang-java\">@SpringBootApplication\n@PropertySource(value = {&quot;classpath:custom.properties&quot;})\npublic class DemoApplication {\n</code></pre>\n<p><strong><code>value</code>属性是一个数组，可以指定多个配置文件同时引入。</strong></p>\n<p><strong><code><a href=\"https://github.com/PropertySource\" title=\"&#64;PropertySource\" class=\"at-link\">@PropertySource</a></code>默认加载<code>xxx.properties</code>类型的配置文件，不能加载<code>YML</code>格式的配置文件，怎么破？？？</strong></p>\n<h3 id=\"h3--yml-\"><a name=\"如何加载自定义YML格式的配置文件？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>如何加载自定义YML格式的配置文件？</h3><p><code><a href=\"https://github.com/PropertySource\" title=\"&#64;PropertySource\" class=\"at-link\">@PropertySource</a></code>注解有一个属性<code>factory</code>，默认值是<code>PropertySourceFactory.class</code>，这个就是用来加载<code>properties</code>格式的配置文件，我们可以自定义一个用来加载<code>YML</code>格式的配置文件，如下：</p>\n<pre><code class=\"lang-java\">import org.springframework.beans.factory.config.YamlPropertiesFactoryBean;\nimport org.springframework.core.env.PropertiesPropertySource;\nimport org.springframework.core.env.PropertySource;\nimport org.springframework.core.io.support.DefaultPropertySourceFactory;\nimport org.springframework.core.io.support.EncodedResource;\n\nimport java.io.IOException;\nimport java.util.Properties;\n\npublic class YmlConfigFactory extends DefaultPropertySourceFactory {\n    @Override\n    public PropertySource&lt;?&gt; createPropertySource(String name, EncodedResource resource) throws IOException {\n        String sourceName = name != null ? name : resource.getResource().getFilename();\n        if (!resource.getResource().exists()) {\n            return new PropertiesPropertySource(sourceName, new Properties());\n        } else if (sourceName.endsWith(&quot;.yml&quot;) || sourceName.endsWith(&quot;.yaml&quot;)) {\n            Properties propertiesFromYaml = loadYml(resource);\n            return new PropertiesPropertySource(sourceName, propertiesFromYaml);\n        } else {\n            return super.createPropertySource(name, resource);\n        }\n    }\n\n    private Properties loadYml(EncodedResource resource) throws IOException {\n        YamlPropertiesFactoryBean factory = new YamlPropertiesFactoryBean();\n        factory.setResources(resource.getResource());\n        factory.afterPropertiesSet();\n        return factory.getObject();\n    }\n\n}\n</code></pre>\n<p>此时只需要将<code>factory</code>属性指定为<code>YmlConfigFactory</code>即可，如下：</p>\n<pre><code class=\"lang-java\">@SpringBootApplication\n@PropertySource(value = {&quot;classpath:custom.yml&quot;},factory = YmlConfigFactory.class)\npublic class DemoApplication {\n</code></pre>\n<h3 id=\"h3-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h3><p><code><a href=\"https://github.com/PropertySource\" title=\"&#64;PropertySource\" class=\"at-link\">@PropertySource</a></code>指定加载自定义的配置文件，默认只能加载<code>properties</code>格式，但是可以指定<code>factory</code>属性来加载<code>YML</code>格式的配置文件。</p>\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>以上内容介绍了Spring Boot中的配置文件的语法以及如何从配置文件中取值，这个内容很重要，作者也是尽可能讲的通俗易懂，希望读者能够有所收获。</p>\n<p>好了，肝了两个多小时，每一篇文章都是作者精心原创制作，读者朋友们的每一个点赞分享都是对我莫大的支持，谢谢！！！<br><img src=\"https://gitee.com/chenjiabing666/Blog-file/raw/master/myjszl_log.png\" alt=\"\"></p>\n', 'Spring Boot 第二弹，配置文件怎么造？', 1, 0, 'https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%BC%98%E8%B4%A8%E8%A7%86%E9%A2%91%E8%B5%84%E6%BA%90/1.png', 1, 1, 1, 1, 2, '2022-03-06 20:47:15', '2022-03-06 20:47:15');
INSERT INTO `article` VALUES (10, '552955802348945408', '94dd9d02befd4dac9d6e708ff92f7d82', 2, 'Spring Boot 第二十三弹，自定义启动器', '<h3 id=\"h3--\"><a name=\"持续原创输出,点击上方蓝字关注我\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>持续原创输出,点击上方蓝字关注我</h3><p><img src=\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%AF%E5%8A%A8%E5%99%A8/2.jpeg\" alt=\"\"></p>\n<h3 id=\"h3-u76EEu5F55\"><a name=\"目录\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>目录</h3><ul>\n<li>前言</li><li>如何自定义一个starter？<ul>\n<li>准备自己的自动配置类</li><li>将自动配置类设置在spring.factories</li><li>如何指定自动配置类的执行顺序？<ul>\n<li>分享一个经典的误区</li><li>源码分析自动配置类如何排序？</li></ul>\n</li><li>总结<h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2>日常工作中对于<code>Spring Boot</code> 提供的一些启动器可能已经足够使用了，但是不可避免的需要自定义启动器，比如整合一个陌生的组件，也想要达到开箱即用的效果。</li></ul>\n</li></ul>\n<p>在上一章节从底层源码介绍了<code>Spring Boot</code> 的自动配置的原理，未读过的朋友建议看一下：<a href=\"https://mp.weixin.qq.com/s/cEBvxQ4iDo3QOMYWvwE6nw\">Spring Boot 自动配置源码解析</a></p>\n<p>这篇文章将会介绍如何自定义一个启动器，同时对于自动配置类的执行顺序做一个详细的分析。</p>\n<h2 id=\"h2--starter-\"><a name=\"如何自定义一个starter？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>如何自定义一个starter？</h2><p>启动器的核心其实就是自动配置类，在自动配置源码分析的章节已经介绍过，<code>AutoConfigurationImportSelector</code>是从<code>spring.factories</code>中加载自动配置类，因此只需要将自定义的自动配置类设置在该文件中即可。</p>\n<p>读过源码的朋友都知道自动配置类常用的一些注解，总结如下：</p>\n<ol>\n<li><code><a href=\"https://github.com/Configuration\" title=\"&#64;Configuration\" class=\"at-link\">@Configuration</a></code>： 该注解标志这是一个配置类，<strong>自动配置类可以不加该注解</strong>。</li><li><code><a href=\"https://github.com/EnableConfigurationProperties\" title=\"&#64;EnableConfigurationProperties\" class=\"at-link\">@EnableConfigurationProperties</a></code>：这个配置也是经常使用了，使得指定的属性配置生效。一般自动配置类都需要从全局属性配置中读取自定义的配置，这就是一个开关。</li><li><code><a href=\"https://github.com/ConditionalOnXxxx\" title=\"&#64;ConditionalOnXxxx\" class=\"at-link\">@ConditionalOnXxxx</a></code>：该注解是自动配置类的核心了，自动配置类既要启动时自动配置，又要保证用户用户自定义的配置覆盖掉自动配置，该注解就是一个条件语句，只有当指定条件成立才会执行某操作。不理解的，请看作者前面的一篇文章：<a href=\"https://mp.weixin.qq.com/s/BoujdCIHPK79jT9RKAmyug\">这类注解都不知道，还说用过Spring Boot~</a></li><li><code><a href=\"https://github.com/AutoConfigureAfter\" title=\"&#64;AutoConfigureAfter\" class=\"at-link\">@AutoConfigureAfter</a></code>：指定自动配置类的执行先后顺序，下文详细介绍。</li><li><code><a href=\"https://github.com/AutoConfigureBefore\" title=\"&#64;AutoConfigureBefore\" class=\"at-link\">@AutoConfigureBefore</a></code>：指定自动配置列的执行先后顺序，下文详细介绍。</li><li><code><a href=\"https://github.com/AutoConfigureOrder\" title=\"&#64;AutoConfigureOrder\" class=\"at-link\">@AutoConfigureOrder</a></code>：指定自动配置类的优先级，下文详细介绍。</li></ol>\n<p>有了以上准备，自定义一个<code>starter</code>非常简单，分为两个步骤。</p>\n<h3 id=\"h3-1-\"><a name=\"1. 准备自己的自动配置类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 准备自己的自动配置类</h3><p>启动器的灵魂核心就是自动配置类，因此需要首先创建一个自动配置类，如下：</p>\n<pre><code class=\"lang-java\">@Configuration\n@AutoConfigureAfter(DataSourceAutoConfiguration.class)\n@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE+5)\n@ConditionalOnProperty(prefix = &quot;my.auto&quot;,name = &quot;enabled&quot;,havingValue = &quot;true&quot;,matchIfMissing = true)\npublic class MyCustomAutoConfiguration {\n\n}\n</code></pre>\n<p>以上自动配置类只是作者简单的按照格式随手写了一个，真实开发中需要根据启动器的业务做默认配置。</p>\n<h3 id=\"h3-2-spring-factories\"><a name=\"2. 将自动配置类设置在spring.factories\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 将自动配置类设置在spring.factories</h3><p>标注了<code><a href=\"https://github.com/Configuration\" title=\"&#64;Configuration\" class=\"at-link\">@Configuration</a></code>注解的自动配置类如果不放在<code>spring.factories</code>文件中，仅仅是一个普通的配置类而已。想要其成为自动配置类，需要在<code>spring.factories</code>文件中设置，如下：</p>\n<pre><code class=\"lang-java\"># Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\ncom.example.autoconfig.MyCustomAutoConfiguration\n</code></pre>\n<p>经过以上的配置，粗略的启动器完成了，只需要打包，然后<code>Maven</code>引入即可工作。</p>\n<h2 id=\"h2--\"><a name=\"如何指定自动配置类的执行顺序？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>如何指定自动配置类的执行顺序？</h2><p>自动配置类需要定义执行顺序吗？答案：肯定的。比如<code>Mybatis</code>的自动配置类，肯定要在数据源的自动配置类之后执行，否则如何创建<code>SqlSessionFactory</code>？</p>\n<p>如何自定义自动配置类的执行顺序呢？此时就需要用到上文提到的三个注解，如下：</p>\n<ol>\n<li><code><a href=\"https://github.com/AutoConfigureAfter\" title=\"&#64;AutoConfigureAfter\" class=\"at-link\">@AutoConfigureAfter</a></code>： 当前配置类在指定配置类之后执行</li><li><code><a href=\"https://github.com/AutoConfigureBefore\" title=\"&#64;AutoConfigureBefore\" class=\"at-link\">@AutoConfigureBefore</a></code>： 当前配置类在指定配置类之前执行</li><li><code><a href=\"https://github.com/AutoConfigureOrder\" title=\"&#64;AutoConfigureOrder\" class=\"at-link\">@AutoConfigureOrder</a></code>：指定优先级，数值越小，优先级越高。</li></ol>\n<h3 id=\"h3-u5206u4EABu4E00u4E2Au7ECFu5178u7684u8BEFu533A\"><a name=\"分享一个经典的误区\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>分享一个经典的误区</h3><p>对于<code>Spring Boot</code>不是很了解的人写出的代码真是<strong>不堪入目</strong>，曾经看过有人在<strong>普通的配置类</strong>上使用<code><a href=\"https://github.com/AutoConfigurexxx\" title=\"&#64;AutoConfigurexxx\" class=\"at-link\">@AutoConfigurexxx</a></code>注解，如下；</p>\n<pre><code class=\"lang-java\">@Configuration\n@AutoConfigureBefore(Config2.class)\npublic class Config1{}\n\n@Configuration\npublic class Config2{}\n</code></pre>\n<p>是不是感觉很爽，原来还能这么指定配置类的执行顺序…..（此处省略一万字）</p>\n<blockquote>\n<p>可能有时候走了狗屎运给你一种错觉还真的配置成功了。实际上这种方式是不可行的，以上三个注解只有针对自动配置类才会生效。</p>\n</blockquote>\n<h3 id=\"h3--\"><a name=\"源码分析自动配置类如何排序？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>源码分析自动配置类如何排序？</h3><p>其实关键的代码还是在<code>AutoConfigurationImportSelector</code>中，将自动配置类从<code>spring.factories</code>加载出来之后会根据条件排序，在<code>selectImports()</code>方法中最后一行代码如下：</p>\n<pre><code class=\"lang-java\">return sortAutoConfigurations(processedConfigurations, getAutoConfigurationMetadata()).stream()\n                    .map((importClassName) -&gt; new Entry(this.entries.get(importClassName), importClassName))\n                    .collect(Collectors.toList());\n</code></pre>\n<p>上面的代码则是将排序好的自动配置类返回，跟进代码，发现最终的实现都在<code>AutoConfigurationSorter.getInPriorityOrder()</code>方法中，逻辑如下图：</p>\n<p><img src=\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%AF%E5%8A%A8%E5%99%A8/1.png\" alt=\"\"></p>\n<p>具体的流程如上图，排序也是按照先后顺序，如下：</p>\n<ol>\n<li>先按照字母排序</li><li>按照<code><a href=\"https://github.com/AutoConfigureOrder\" title=\"&#64;AutoConfigureOrder\" class=\"at-link\">@AutoConfigureOrder</a></code>优先级排序</li><li>最终按照<code><a href=\"https://github.com/AutoConfigureAfter\" title=\"&#64;AutoConfigureAfter\" class=\"at-link\">@AutoConfigureAfter</a></code>、<code><a href=\"https://github.com/AutoConfigureBefore\" title=\"&#64;AutoConfigureBefore\" class=\"at-link\">@AutoConfigureBefore</a></code>排序</li></ol>\n<blockquote>\n<p>从上面配置的顺序可以知道，最终决定权还是在<code><a href=\"https://github.com/AutoConfigureAfter\" title=\"&#64;AutoConfigureAfter\" class=\"at-link\">@AutoConfigureAfter</a></code>、<code><a href=\"https://github.com/AutoConfigureBefore\" title=\"&#64;AutoConfigureBefore\" class=\"at-link\">@AutoConfigureBefore</a></code>这两个注解。</p>\n</blockquote>\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>本文介绍了如何自定义一个启动器以及指定自动配置类的执行顺序，通过作者的介绍，希望读者们能够理解并灵活运用。</p>\n<p>另外作者的第一本<code>PDF</code>书籍已经整理好了，由浅入深的详细介绍了Mybatis基础以及底层源码，有需要的朋友公众号回复关键词<strong>Mybatis进阶</strong>即可获取，目录如下：</p>\n<p><img src=\"https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E8%BF%9B%E9%98%B6PDF/2.png\" alt=\"\"></p>\n<p><img src=\"https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png\" alt=\"\"></p>\n', 'Spring Boot 第二十三弹，自定义启动器', 1, 0, 'https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%BC%98%E8%B4%A8%E8%A7%86%E9%A2%91%E8%B5%84%E6%BA%90/1.png', 1, 1, 1, 1, 2, '2022-03-06 20:48:57', '2022-03-06 20:48:57');
INSERT INTO `article` VALUES (11, '552956006712213504', '94dd9d02befd4dac9d6e708ff92f7d82', 2, 'Spring Boot第九弹，满屏的try-catch，你不瘆得慌？', '<h2 id=\"h2--\"><a name=\"持续原创输出，点击上方蓝字关注我\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>持续原创输出，点击上方蓝字关注我</h2><p><img src=\"https://gitee.com/chenjiabing666/Blog-file/raw/master/Spring%20Boot%E7%AC%AC%E5%85%AB%E5%BC%B9%EF%BC%8C%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8/2.jpeg\" alt=\"\"></p>\n<h2 id=\"h2-u76EEu5F55\"><a name=\"目录\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>目录</h2><ul>\n<li>前言</li><li>Spring Boot 版本</li><li>全局统一异常处理的前世今生</li><li>Spring Boot的异常如何分类？</li><li>如何统一异常处理？</li><li>异常匹配的顺序是什么？</li><li>总结</li></ul>\n<h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>软件开发过程中难免遇到各种的BUG，各种的异常，一直就是在解决异常的路上永不停歇，如果你的代码中再出现<code>try(){...}catch(){...}finally{...}</code>代码块，你还有心情看下去吗？自己不觉得恶心吗？</p>\n<p>冗余的代码往往回丧失写代码的动力，每天搬砖似的写代码，真的很难受。今天这篇文章教你如何去掉满屏的<code>try(){...}catch(){...}finally{...}</code>，解放你的双手。</p>\n<h2 id=\"h2-spring-boot-\"><a name=\"Spring Boot 版本\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Spring Boot 版本</h2><p>本文基于的Spring Boot的版本是<code>2.3.4.RELEASE</code>。</p>\n<h2 id=\"h2-u5168u5C40u7EDFu4E00u5F02u5E38u5904u7406u7684u524Du4E16u4ECAu751F\"><a name=\"全局统一异常处理的前世今生\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>全局统一异常处理的前世今生</h2><p>早在<code>Spring 3.x</code>就已经提出了<code><a href=\"https://github.com/ControllerAdvice\" title=\"&#64;ControllerAdvice\" class=\"at-link\">@ControllerAdvice</a></code>，可以与<code><a href=\"https://github.com/ExceptionHandler\" title=\"&#64;ExceptionHandler\" class=\"at-link\">@ExceptionHandler</a></code>、<code><a href=\"https://github.com/InitBinder\" title=\"&#64;InitBinder\" class=\"at-link\">@InitBinder</a></code>、<code><a href=\"https://github.com/ModelAttribute\" title=\"&#64;ModelAttribute\" class=\"at-link\">@ModelAttribute</a></code> 等注解注解配套使用，这几个此处就不再详细解释了。</p>\n<p>这几个注解小眼一瞟只有<code><a href=\"https://github.com/ExceptionHandler\" title=\"&#64;ExceptionHandler\" class=\"at-link\">@ExceptionHandler</a></code>与异常有关啊，翻译过来就是<code>异常处理器</code>。<strong>其实异常的处理可以分为两类，分别是<code>局部异常处理</code>和<code>全局异常处理</code></strong>。</p>\n<p><strong><code>局部异常处理</code></strong>：<code><a href=\"https://github.com/ExceptionHandler\" title=\"&#64;ExceptionHandler\" class=\"at-link\">@ExceptionHandler</a></code>和<code><a href=\"https://github.com/Controller\" title=\"&#64;Controller\" class=\"at-link\">@Controller</a></code>注解搭配使用，只有指定的controller层出现了异常才会被<code><a href=\"https://github.com/ExceptionHandler\" title=\"&#64;ExceptionHandler\" class=\"at-link\">@ExceptionHandler</a></code>捕获到，实际生产中怕是有成百上千个controller了吧，显然这种方式不合适。</p>\n<p><strong><code>全局异常处理</code></strong>：既然局部异常处理不合适了，自然有人站出来解决问题了，于是就有了<code><a href=\"https://github.com/ControllerAdvice\" title=\"&#64;ControllerAdvice\" class=\"at-link\">@ControllerAdvice</a></code>这个注解的横空出世了，<code><a href=\"https://github.com/ControllerAdvice\" title=\"&#64;ControllerAdvice\" class=\"at-link\">@ControllerAdvice</a></code>搭配<code><a href=\"https://github.com/ExceptionHandler\" title=\"&#64;ExceptionHandler\" class=\"at-link\">@ExceptionHandler</a></code>彻底解决了全局统一异常处理。当然后面还出现了<code><a href=\"https://github.com/RestControllerAdvice\" title=\"&#64;RestControllerAdvice\" class=\"at-link\">@RestControllerAdvice</a></code>这个注解，其实就是<code><a href=\"https://github.com/ControllerAdvice\" title=\"&#64;ControllerAdvice\" class=\"at-link\">@ControllerAdvice</a></code>和<code><a href=\"https://github.com/ResponseBody\" title=\"&#64;ResponseBody\" class=\"at-link\">@ResponseBody</a></code>结晶。</p>\n<h2 id=\"h2-spring-boot-\"><a name=\"Spring Boot的异常如何分类？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Spring Boot的异常如何分类？</h2><p>Java中的异常就很多，更别说Spring Boot中的异常了，这里不再根据传统意义上Java的异常进行分类了，而是按照<code>controller</code>进行分类，分为<code>进入controller前的异常</code>和<code>业务层的异常</code>，如下图：</p>\n<p><img src=\"https://gitee.com/chenjiabing666/Blog-file/raw/master/Spring%20Boot%E7%AC%AC%E5%85%AB%E5%BC%B9%EF%BC%8C%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8/1.png\" alt=\"\"></p>\n<p>进入controller之前异常一般是<code>javax.servlet.ServletException</code>类型的异常，因此在全局异常处理的时候需要统一处理。几个常见的异常如下：</p>\n<ol>\n<li><code>NoHandlerFoundException</code>：客户端的请求没有找到对应的controller，将会抛出<code>404</code>异常。</li><li><code>HttpRequestMethodNotSupportedException</code>：若匹配到了（匹配结果是一个列表，不同的是http方法不同，如：Get、Post等），则尝试将请求的http方法与列表的控制器做匹配，若没有对应http方法的控制器，则抛该异常</li><li><code>HttpMediaTypeNotSupportedException</code>：然后再对请求头与控制器支持的做比较，比如<code>content-type</code>请求头，若控制器的参数签名包含注解<code><a href=\"https://github.com/RequestBody\" title=\"&#64;RequestBody\" class=\"at-link\">@RequestBody</a></code>，但是请求的<code>content-type</code>请求头的值没有包含<code>application/json</code>，那么会抛该异常（当然，不止这种情况会抛这个异常）</li><li><code>MissingPathVariableException</code>：未检测到路径参数。比如url为：/user/{userId}，参数签名包含<code><a href=\"https://github.com/PathVariable\" title=\"&#64;PathVariable\" class=\"at-link\">@PathVariable</a>(&quot;userId&quot;)</code>，当请求的url为/user，在没有明确定义url为/user的情况下，会被判定为：缺少路径参数</li></ol>\n<h2 id=\"h2--\"><a name=\"如何统一异常处理？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>如何统一异常处理？</h2><p>在统一异常处理之前其实还有许多东西需要优化的，比如统一结果返回的形式。当然这里不再细说了，不属于本文范畴。</p>\n<p><strong>统一异常处理很简单，这里以前后端分离的项目为例，步骤如下</strong>：</p>\n<ol>\n<li>新建一个统一异常处理的一个类</li><li>类上标注<code><a href=\"https://github.com/RestControllerAdvice\" title=\"&#64;RestControllerAdvice\" class=\"at-link\">@RestControllerAdvice</a></code>这一个注解，或者同时标注<code><a href=\"https://github.com/ControllerAdvice\" title=\"&#64;ControllerAdvice\" class=\"at-link\">@ControllerAdvice</a></code>和<code><a href=\"https://github.com/ResponseBody\" title=\"&#64;ResponseBody\" class=\"at-link\">@ResponseBody</a></code>这两个注解。</li><li>在方法上标注<code><a href=\"https://github.com/ExceptionHandler\" title=\"&#64;ExceptionHandler\" class=\"at-link\">@ExceptionHandler</a></code>注解，并且指定需要捕获的异常，可以同时捕获多个。</li></ol>\n<p>下面是作者随便配置一个demo，如下：</p>\n<pre><code class=\"lang-java\">/**\n * 全局统一的异常处理，简单的配置下，根据自己的业务要求详细配置\n */\n@RestControllerAdvice\n@Slf4j\npublic class GlobalExceptionHandler {\n\n\n    /**\n     * 重复请求的异常\n     * @param ex\n     * @return\n     */\n    @ExceptionHandler(RepeatSubmitException.class)\n    public ResultResponse onException(RepeatSubmitException ex){\n        //打印日志\n        log.error(ex.getMessage());\n        //todo 日志入库等等操作\n\n        //统一结果返回\n        return new ResultResponse(ResultCodeEnum.CODE_NOT_REPEAT_SUBMIT);\n    }\n\n\n    /**\n     * 自定义的业务上的异常\n     */\n    @ExceptionHandler(ServiceException.class)\n    public ResultResponse onException(ServiceException ex){\n        //打印日志\n        log.error(ex.getMessage());\n        //todo 日志入库等等操作\n\n        //统一结果返回\n        return new ResultResponse(ResultCodeEnum.CODE_SERVICE_FAIL);\n    }\n\n\n    /**\n     * 捕获一些进入controller之前的异常，有些4xx的状态码统一设置为200\n     * @param ex\n     * @return\n     */\n    @ExceptionHandler({HttpRequestMethodNotSupportedException.class,\n            HttpMediaTypeNotSupportedException.class, HttpMediaTypeNotAcceptableException.class,\n            MissingPathVariableException.class, MissingServletRequestParameterException.class,\n            ServletRequestBindingException.class, ConversionNotSupportedException.class,\n            TypeMismatchException.class, HttpMessageNotReadableException.class,\n            HttpMessageNotWritableException.class,\n            MissingServletRequestPartException.class, BindException.class,\n            NoHandlerFoundException.class, AsyncRequestTimeoutException.class})\n    public ResultResponse onException(Exception ex){\n        //打印日志\n        log.error(ex.getMessage());\n        //todo 日志入库等等操作\n\n        //统一结果返回\n        return new ResultResponse(ResultCodeEnum.CODE_FAIL);\n    }\n}\n</code></pre>\n<p><strong>注意</strong>：<strong>上面的只是一个例子，实际开发中还有许多的异常需要捕获，比如<code>TOKEN失效</code>、<code>过期</code>等等异常，如果整合了其他的框架，还要注意这些框架抛出的异常，比如<code>Shiro</code>，<code>Spring Security</code>等等框架。</strong></p>\n<h2 id=\"h2--\"><a name=\"异常匹配的顺序是什么？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>异常匹配的顺序是什么？</h2><p>有些朋友可能疑惑了，如果我同时捕获了父类和子类，那么到底能够被那个异常处理器捕获呢？比如<code>Exception</code>和<code>ServiceException</code>。<br><img src=\"https://gitee.com/chenjiabing666/Blog-file/raw/master/Spring%20Boot%E7%AC%AC%E5%85%AB%E5%BC%B9%EF%BC%8C%E5%A6%82%E4%BD%95%E6%89%A9%E5%B1%95%E5%85%A8%E9%9D%A2%E6%8E%A5%E5%8F%A3MVC/1.jpg\" alt=\"\"></p>\n<p>此时可能就疑惑了，<strong>这里先揭晓一下答案，当然是<code>ServiceException</code>的异常处理器捕获了，精确匹配，如果没有<code>ServiceException</code>的异常处理器才会轮到它的<code>父亲</code>，<code>父亲</code>没有才会到<code>祖父</code>。总之一句话，精准匹配，找那个关系最近的。</strong></p>\n<p>为什么呢？这可不是凭空瞎说的，源码为证，出处<code>org.springframework.web.method.annotation.ExceptionHandlerMethodResolver#getMappedMethod</code>，如下：</p>\n<pre><code class=\"lang-java\">@Nullable\n    private Method getMappedMethod(Class&lt;? extends Throwable&gt; exceptionType) {\n        List&lt;Class&lt;? extends Throwable&gt;&gt; matches = new ArrayList&lt;&gt;();\n    //遍历异常处理器中定义的异常类型\n        for (Class&lt;? extends Throwable&gt; mappedException : this.mappedMethods.keySet()) {\n      //是否是抛出异常的父类，如果是添加到集合中\n            if (mappedException.isAssignableFrom(exceptionType)) {    \n        //添加到集合中\n                matches.add(mappedException);  \n            }\n        }\n    //如果集合不为空，则按照规则进行排序\n        if (!matches.isEmpty()) {\n            matches.sort(new ExceptionDepthComparator(exceptionType));\n      //取第一个\n            return this.mappedMethods.get(matches.get(0));\n        }\n        else {\n            return null;\n        }\n    }\n</code></pre>\n<p><strong>在初次异常处理的时候会执行上述的代码找到最匹配的那个异常处理器方法，后续都是直接从缓存中（一个<code>Map</code>结构，<code>key</code>是异常类型，<code>value</code>是异常处理器方法）。</strong></p>\n<p>别着急，上面代码最精华的地方就是对<code>matches</code>进行排序的代码了，我们来看看<code>ExceptionDepthComparator</code>这个比较器的关键代码，如下：</p>\n<pre><code class=\"lang-java\">//递归调用，获取深度，depth值越小越精准匹配\nprivate int getDepth(Class&lt;?&gt; declaredException, Class&lt;?&gt; exceptionToMatch, int depth) {\n    //如果匹配了，返回\n        if (exceptionToMatch.equals(declaredException)) {\n            // Found it!\n            return depth;\n        }\n        // 递归结束的条件，最大限度了\n        if (exceptionToMatch == Throwable.class) {\n            return Integer.MAX_VALUE;\n        }\n    //继续匹配父类\n        return getDepth(declaredException, exceptionToMatch.getSuperclass(), depth + 1);\n    }\n</code></pre>\n<p><strong>精髓全在这里了，一个递归搞定，计算深度，<code>depth</code>初始值为0。值越小，匹配度越高越精准。</strong></p>\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>全局异常的文章万万千，能够讲清楚的能有几篇呢？<strong>只出最精的文章，做最野的程序员</strong>，如果觉得不错的，关注分享走一波，谢谢支持！！！</p>\n<p><strong>另外作者的第一本PDF书籍已经整理好了，由浅入深的详细介绍了Mybatis基础以及底层源码，有需要的朋友公众号回复关键词<code>Mybatis进阶</code>即可获取，目录如下：</strong></p>\n<p><img src=\"https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E8%BF%9B%E9%98%B6PDF/2.png\" alt=\"\"></p>\n<p><img src=\"https://gitee.com/chenjiabing666/Blog-file/raw/master/myjszl_log.png\" alt=\"\"></p>\n', 'Spring Boot第九弹，满屏的try-catch，你不瘆得慌？', 1, 0, 'https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%BC%98%E8%B4%A8%E8%A7%86%E9%A2%91%E8%B5%84%E6%BA%90/1.png', 1, 1, 0, 1, 2, '2022-03-06 20:49:45', '2022-03-06 20:49:45');
INSERT INTO `article` VALUES (12, '552956313429082112', '94dd9d02befd4dac9d6e708ff92f7d82', 2, 'Spring Boot第七弹，过滤器如何配置，一波梭哈~', '<h2 id=\"h2--\"><a name=\"持续原创输出，点击上方蓝字关注我\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>持续原创输出，点击上方蓝字关注我</h2><p><img src=\"https://gitee.com/chenjiabing666/Blog-file/raw/master/Spring%20Boot%E7%AC%AC%E4%B8%83%E5%BC%B9%EF%BC%8C%E8%BF%87%E6%BB%A4%E5%99%A8%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE/3.jpeg\" alt=\"\"></p>\n<h2 id=\"h2-u76EEu5F55\"><a name=\"目录\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>目录</h2><ul>\n<li>前言</li><li>Spring Boot 版本</li><li>什么是过滤器？</li><li>Filter的执行原理</li><li>如何自定义一个Filter？</li><li>Spring Boot如何配置Filter？<ul>\n<li>配置类中使用<a href=\"https://github.com/Bean\" title=\"&#64;Bean\" class=\"at-link\"><a href=\"https://github.com/Bean\" title=\"&#64;Bean\" class=\"at-link\">@Bean</a></a>注入【推荐使用】</li><li>使用<a href=\"https://github.com/WebFilter\" title=\"&#64;WebFilter\" class=\"at-link\"><a href=\"https://github.com/WebFilter\" title=\"&#64;WebFilter\" class=\"at-link\">@WebFilter</a></a></li></ul>\n</li><li>举个栗子</li><li>总结</li></ul>\n<h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>上篇文章介绍了Spring Boot中如何配置拦截器，今天这篇文章就来讲讲类似于拦截器的一个组件：过滤器。</p>\n<p>其实在实际开发中过滤器真的接触的不多，但是在应用中却是不可或缺的角色，值得花费一个章节专门介绍一下。</p>\n<h2 id=\"h2-spring-boot-\"><a name=\"Spring Boot 版本\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Spring Boot 版本</h2><p>本文基于的Spring Boot的版本是<code>2.3.4.RELEASE</code>。</p>\n<h2 id=\"h2--\"><a name=\"什么是过滤器？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是过滤器？</h2><p><code>Filter</code>也称之为过滤器，它是Servlet技术中最实用的技术，WEB开发人员通过Filter技术，对web服务器管理的所有web资源：例如JSP，Servlet，静态图片文件或静态HTML文件进行拦截，从而实现一些特殊功能。例如实现<code>URL级别的权限控制</code>、<code>过滤敏感词汇</code>、<code>压缩响应信息</code>等一些高级功能。</p>\n<h2 id=\"h2-filter-\"><a name=\"Filter的执行原理\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Filter的执行原理</h2><p>当客户端发出Web资源的请求时，Web服务器根据应用程序配置文件设置的过滤规则进行检查，若客户请求满足过滤规则，则对客户请求／响应进行拦截，对请求头和请求数据进行检查或改动，并依次通过过滤器链，最后把请求／响应交给请求的Web资源处理。请求信息在过滤器链中可以被修改，也可以根据条件让请求不发往资源处理器，并直接向客户机发回一个响应。当资源处理器完成了对资源的处理后，响应信息将逐级逆向返回。同样在这个过程中，用户可以修改响应信息，从而完成一定的任务，如下图：</p>\n<p><img src=\"https://gitee.com/chenjiabing666/Blog-file/raw/master/Spring%20Boot%E7%AC%AC%E4%B8%83%E5%BC%B9%EF%BC%8C%E8%BF%87%E6%BB%A4%E5%99%A8%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE/1.png\" alt=\"\"></p>\n<p>服务器会按照过滤器定义的先后循序组装成<code>一条链</code>，然后一次执行其中的<code>doFilter()</code>方法。（注：这一点<code>Filter</code>和<code>Servlet</code>是不一样的）执行的顺序就如下图所示，执行第一个过滤器的<code>chain.doFilter()</code>之前的代码，第二个过滤器的<code>chain.doFilter()</code>之前的代码，请求的资源，第二个过滤器的<code>chain.doFilter()</code>之后的代码，第一个过滤器的<code>chain.doFilter()</code>之后的代码，最后返回响应。</p>\n<p><img src=\"https://gitee.com/chenjiabing666/Blog-file/raw/master/Spring%20Boot%E7%AC%AC%E4%B8%83%E5%BC%B9%EF%BC%8C%E8%BF%87%E6%BB%A4%E5%99%A8%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE/2.jpg\" alt=\"\"></p>\n<h2 id=\"h2--filter-\"><a name=\"如何自定义一个Filter？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>如何自定义一个Filter？</h2><p>这个问题其实不是Spring Boot这个章节应该介绍的了，在Spring MVC中就应该会的内容，只需要实现<code>javax.servlet.Filter</code>这个接口，重写其中的方法。实例如下：</p>\n<pre><code class=\"lang-java\">@Component\npublic class CrosFilter implements Filter {\n\n    //重写其中的doFilter方法\n    @Override\n    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {\n        //继续执行下一个过滤器\n        chain.doFilter(req, response);\n    }\n</code></pre>\n<h2 id=\"h2-spring-boot-filter-\"><a name=\"Spring Boot如何配置Filter？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Spring Boot如何配置Filter？</h2><p>自定义好了过滤器当然要使其在Spring Boot中生效了，Spring Boot配置Filter有两种方式，其实都很简单，下面一一介绍。</p>\n<h3 id=\"h3--bean-\"><a name=\"配置类中使用@Bean注入【推荐使用】\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>配置类中使用<a href=\"https://github.com/Bean\" title=\"&#64;Bean\" class=\"at-link\">@Bean</a>注入【推荐使用】</h3><p>其实很简单，只需要将<code>FilterRegistrationBean</code>这个实例注入到IOC容器中即可，如下：</p>\n<pre><code class=\"lang-java\">@Configuration\npublic class FilterConfig {\n    @Autowired\n    private Filter1 filter1;\n\n    @Autowired\n    private Filter2 filter2;\n\n\n    /**\n     * 注入Filter1\n     * @return\n     */\n    @Bean\n    public FilterRegistrationBean filter1() {\n        FilterRegistrationBean registration = new FilterRegistrationBean();\n        registration.setFilter(filter1);\n        registration.addUrlPatterns(&quot;/*&quot;);\n        registration.setName(&quot;filter1&quot;);\n        //设置优先级别\n        registration.setOrder(1);\n        return registration;\n    }\n\n    /**\n     * 注入Filter2\n     * @return\n     */\n    @Bean\n    public FilterRegistrationBean filter2() {\n        FilterRegistrationBean registration = new FilterRegistrationBean();\n        registration.setFilter(filter2);\n        registration.addUrlPatterns(&quot;/*&quot;);\n        registration.setName(&quot;filter2&quot;);\n        //设置优先级别\n        registration.setOrder(2);\n        return registration;\n    }\n}\n</code></pre>\n<p><strong>注意：设置的优先级别决定了过滤器的执行顺序。</strong></p>\n<h3 id=\"h3--webfilter\"><a name=\"使用@WebFilter\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>使用<a href=\"https://github.com/WebFilter\" title=\"&#64;WebFilter\" class=\"at-link\">@WebFilter</a></h3><p><code><a href=\"https://github.com/WebFilter\" title=\"&#64;WebFilter\" class=\"at-link\">@WebFilter</a></code>是Servlet3.0的一个注解，用于标注一个Filter，Spring Boot也是支持这种方式，只需要在自定义的Filter上标注该注解即可，如下：</p>\n<pre><code class=\"lang-java\">@WebFilter(filterName = &quot;crosFilter&quot;,urlPatterns = {&quot;/*&quot;})\npublic class CrosFilter implements Filter {\n\n    //重写其中的doFilter方法\n    @Override\n    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {\n        //继续执行下一个过滤器\n        chain.doFilter(req, response);\n    }\n}\n</code></pre>\n<p><strong>要想<code><a href=\"https://github.com/WebFilter\" title=\"&#64;WebFilter\" class=\"at-link\">@WebFilter</a></code>注解生效，需要在配置类上标注另外一个注解<code><a href=\"https://github.com/ServletComponentScan\" title=\"&#64;ServletComponentScan\" class=\"at-link\">@ServletComponentScan</a></code>用于扫描使其生效</strong>，如下：</p>\n<pre><code class=\"lang-java\">@SpringBootApplication\n@ServletComponentScan(value = {&quot;com.example.springbootintercept.filter&quot;})\npublic class SpringbootApplication {}\n</code></pre>\n<p>至此，配置就完成了，启动项目，即可正常运行。</p>\n<h2 id=\"h2-u4E3Eu4E2Au6817u5B50\"><a name=\"举个栗子\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>举个栗子</h2><p>对于前后端分离的项目来说跨域是一个难题，什么是跨域问题？如何造成的？这个不是本章的重点。</p>\n<p>对于跨域问题有多中解决方案，比如JSONP，网关支持等等。<strong>关于跨域的问题以及Spring Boot如何优雅的解决跨域问题？将会在后续文章中介绍</strong>。今天主要介绍如何使用过滤器来解决跨域问题。</p>\n<p>其实原理很简单，只需要在请求头中添加相应支持跨域的内容即可，如下代码仅仅是简单的演示下，针对细致的内容还需自己完善，比如白名单等等。</p>\n<pre><code class=\"lang-java\">@Component\npublic class CrosFilter implements Filter {\n\n    //重写其中的doFilter方法\n    @Override\n    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {\n        HttpServletResponse response = (HttpServletResponse) res;\n        response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);\n        response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);\n        response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, DELETE&quot;);\n        response.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;);\n        response.setHeader(&quot;Access-Control-Allow-Headers&quot;,&quot; Origin, X-Requested-With, Content-Type, Accept&quot;);\n        //继续执行下一个过滤器\n        chain.doFilter(req, response);\n    }\n}\n</code></pre>\n<p>配置类中注入<code>FilterRegistrationBean</code>，如下代码：</p>\n<pre><code class=\"lang-java\">@Configuration\npublic class FilterConfig {\n    @Autowired\n    private CrosFilter crosFilter;\n\n    /**\n     * 注入crosFilter\n     * @return\n     */\n    @Bean\n    public FilterRegistrationBean crosFilter() {\n        FilterRegistrationBean registration = new FilterRegistrationBean();\n        registration.setFilter(crosFilter);\n        registration.addUrlPatterns(&quot;/*&quot;);\n        registration.setName(&quot;crosFilter&quot;);\n        //设置优先级别\n        registration.setOrder(Ordered.HIGHEST_PRECEDENCE);\n        return registration;\n    }\n}\n</code></pre>\n<p>至此，配置完成，相关细致功能还需自己润色。</p>\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>过滤器内容相对简单些，但是在实际开发中不可或缺，比如常用的权限控制框架<code>Shiro</code>，<code>Spring Security</code>，内部都是使用过滤器，了解一下对以后的深入学习有着固本的作用。</p>\n<p><strong>另外作者的第一本PDF书籍已经整理好了，由浅入深的详细介绍了Mybatis基础以及底层源码，有需要的朋友公众号回复关键词<code>Mybatis进阶</code>即可获取，目录如下：</strong></p>\n<p><img src=\"https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E8%BF%9B%E9%98%B6PDF/2.png\" alt=\"\"></p>\n<p>如果有所收获，不妨关注在看支持一下，持续连载中…..</p>\n<p><img src=\"https://gitee.com/chenjiabing666/Blog-file/raw/master/myjszl_log.png\" alt=\"\"></p>\n', 'Spring Boot第七弹，过滤器如何配置，一波梭哈~', 1, 0, 'https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%BC%98%E8%B4%A8%E8%A7%86%E9%A2%91%E8%B5%84%E6%BA%90/1.png', 0, 1, 1, 1, 2, '2022-03-06 20:50:59', '2022-03-06 20:50:59');

-- ----------------------------
-- Table structure for mq_msg
-- ----------------------------
DROP TABLE IF EXISTS `mq_msg`;
CREATE TABLE `mq_msg`  (
  `id` bigint(11) NOT NULL AUTO_INCREMENT COMMENT '唯一ID',
  `msg` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL COMMENT '消息体',
  `create_time` datetime(0) NULL DEFAULT NULL,
  `update_time` timestamp(0) NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP(0),
  `status` int(1) NULL DEFAULT NULL COMMENT '1 已发送 0 发送失败  2发送成功 3未送达队列',
  `exchange` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'exchange的名字',
  `queue` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '队列的名字',
  `routing_key` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '路由键',
  `send_num` int(11) NULL DEFAULT 1 COMMENT '发送次数',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 16 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = 'MQ消息记录表' ROW_FORMAT = Compact;

-- ----------------------------
-- Records of mq_msg
-- ----------------------------
INSERT INTO `mq_msg` VALUES (1, '{\"articleId\":\"552893733540986880\",\"authorId\":\"94dd9d02befd4dac9d6e708ff92f7d82\",\"content\":\"<p><strong>大家好，我是不才陈某~</strong></p>\\n<p>Log4j2 的核弹级漏洞刚告一段落，<strong>Spring Cloud Gateway</strong> 又突发高危漏洞，又得折腾了。。。</p>\\n<p>2022年3月1日，Spring官方发布了关于Spring Cloud Gateway的两个CVE漏洞，分别为<strong>CVE-2022-22946</strong>与<strong>CVE-2022-22947</strong>：</p>\\n<p><strong>版本/分支/tag： 3.4.X</strong><br><strong>问题描述</strong>：</p>\\n<p><strong><img src=\\\"https://mmbiz.qpic.cn/mmbiz_png/AokYxdF6ctt1NeiayJzDScfIZZrNMaNAkIgMQMKP9OLVWa4hv9WFfXnfYjMLy4WAib31FW8cXMZ2BVSoYuYAia7EQ/640?wx_fmt=png\\\" alt=\\\"\\\"></strong></p>\\n<p>Spring Cloud Gateway 是 Spring Cloud 下的一个项目，该项目是基于 Spring 5.0、Spring Boot 2.0 和 Project Reactor 等技术开发的网关，它旨在为微服务架构提供一种简单有效、统一的 API 路由管理方式。</p>\\n<h2 id=\\\"h2--strong-1-strong-spring-cloud-gateway-cve-2022-22947-\\\"><a name=\\\"<strong>漏洞1</strong>：Spring Cloud Gateway 远程代码执行漏洞（CVE-2022-22947）\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span><strong>漏洞1</strong>：Spring Cloud Gateway 远程代码执行漏洞（CVE-2022-22947）</h2><p>3 月 1 日，VMware 官方发布安全公告，声明对 Spring Cloud Gateway 中的一处命令注入漏洞进行了修复，漏洞编号为 CVE-2022-22947：</p>\\n<p><a href=\\\"https://tanzu.vmware.com/security/cve-2022-22947\\\">https://tanzu.vmware.com/security/cve-2022-22947</a></p>\\n<p><strong>漏洞描述</strong></p>\\n<p>使用 Spring Cloud Gateway 的应用如果对外暴露了 Gateway Actuator 端点时，则可能存在被 CVE-2022-22947 漏洞利用的风险。攻击者可通过利用此漏洞执行 SpEL 表达式，允许在远程主机上进行任意远程执行。，获取系统权限。</p>\\n<p><strong>影响范围</strong></p>\\n<p>漏洞利用的前置条件：</p>\\n<ol>\\n<li>除了 Spring Cloud Gateway 外，程序还用到了 Spring Boot Actuator 组件（它用于对外提供 /actuator/ 接口）；</li><li>Spring 配置对外暴露 gateway 接口，如 application.properties 配置为：</li></ol>\\n<pre><code class=\\\"lang-properties\\\"># 默认为true\\nmanagement.endpoint.gateway.enabled=true\\n# 以逗号分隔的一系列值，默认为 health# 若包含 gateway 即表示对外提供 Spring Cloud Gateway 接口\\nmanagement.endpoints.web.exposure.include=gateway\\n</code></pre>\\n<p>漏洞影响的 Spring Cloud Gateway 版本范围：</p>\\n<ul>\\n<li>Spring Cloud Gateway 3.1.x &lt; 3.1.1</li><li>Spring Cloud Gateway 3.0.x &lt; 3.0.7</li><li>其他旧的、不受支持的 Spring Cloud Gateway 版本</li></ul>\\n<p><strong>解决方案</strong></p>\\n<p>更新升级 Spring Cloud Gateway 到以下安全版本：</p>\\n<ul>\\n<li>Spring Cloud Gateway 3.1.1</li><li>Spring Cloud Gateway 3.0.7</li></ul>\\n<p>或者在不考虑影响业务的情况下禁用 Gateway actuator 接口：</p>\\n<p>在application.properties 中设置 ：</p>\\n<pre><code class=\\\"lang-properties\\\">management.endpoint.gateway.enabled 为 false。\\n</code></pre>\\n<h2 id=\\\"h2--strong-2-strong-cve-2022-22946-spring-cloud-gateway-http2-trustmanager\\\"><a name=\\\"<strong>漏洞2</strong>：CVE-2022-22946：Spring Cloud Gateway HTTP2 不安全的 TrustManager\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span><strong>漏洞2</strong>：CVE-2022-22946：Spring Cloud Gateway HTTP2 不安全的 TrustManager</h2><p><strong>漏洞描述</strong></p>\\n<p>使用配置为启用 HTTP2 且未设置密钥存储或受信任证书的 Spring Cloud Gateway 的应用程序将被配置为使用不安全的 TrustManager。这使得网关能够使用无效或自定义证书连接到远程服务。</p>\\n<p><strong>影响范围</strong></p>\\n<p>Spring Cloud Gateway = 3.1.0</p>\\n<p><strong>解决方案</strong></p>\\n<p>官方已经发布安全版本，请升级到3.1.1+</p>\\n<p><strong>参考资料</strong></p>\\n<p>官方已经发布安全版本，请升级到3.1.1+</p>\\n<ul>\\n<li><a href=\\\"https://tanzu.vmware.com/security/cve-2022-22946\\\">https://tanzu.vmware.com/security/cve-2022-22946</a></li><li><a href=\\\"https://tanzu.vmware.com/security/cve-2022-22947\\\">https://tanzu.vmware.com/security/cve-2022-22947</a></li></ul>\\n\",\"createTime\":1646556138338,\"describe\":\"Spring Cloud 再爆高危漏洞.... 赶紧修复！！\",\"flag\":1,\"id\":1,\"imgUrl\":\"https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%BC%98%E8%B4%A8%E8%A7%86%E9%A2%91%E8%B5%84%E6%BA%90/1.png\",\"isAppreciate\":1,\"isComment\":1,\"isExplain\":1,\"isRecommend\":1,\"source\":1,\"status\":2,\"title\":\"Spring Cloud 再爆高危漏洞.... 赶紧修复！！\",\"typeId\":3,\"updateTime\":1646556138338,\"viewNum\":0}', '2022-03-06 16:42:18', '2022-03-06 16:43:16', 2, 'article_exchange', NULL, 'article_key', 2);
INSERT INTO `mq_msg` VALUES (2, '{\"articleId\":\"552893733540986880\",\"flag\":3}', '2022-03-06 17:10:40', '2022-03-06 17:11:38', 2, 'article_exchange', NULL, 'article_key', 2);
INSERT INTO `mq_msg` VALUES (3, '{\"articleId\":\"552903405278855168\",\"authorId\":\"94dd9d02befd4dac9d6e708ff92f7d82\",\"content\":\"<p><strong>大家好，我是不才陈某~</strong></p>\\n<p>Log4j2 的核弹级漏洞刚告一段落，<strong>Spring Cloud Gateway</strong> 又突发高危漏洞，又得折腾了。。。</p>\\n<p>2022年3月1日，Spring官方发布了关于Spring Cloud Gateway的两个CVE漏洞，分别为<strong>CVE-2022-22946</strong>与<strong>CVE-2022-22947</strong>：</p>\\n<p><strong>版本/分支/tag： 3.4.X</strong><br><strong>问题描述</strong>：</p>\\n<p><strong><img src=\\\"https://mmbiz.qpic.cn/mmbiz_png/AokYxdF6ctt1NeiayJzDScfIZZrNMaNAkIgMQMKP9OLVWa4hv9WFfXnfYjMLy4WAib31FW8cXMZ2BVSoYuYAia7EQ/640?wx_fmt=png\\\" alt=\\\"\\\"></strong></p>\\n<p>Spring Cloud Gateway 是 Spring Cloud 下的一个项目，该项目是基于 Spring 5.0、Spring Boot 2.0 和 Project Reactor 等技术开发的网关，它旨在为微服务架构提供一种简单有效、统一的 API 路由管理方式。</p>\\n<h2 id=\\\"h2--strong-1-strong-spring-cloud-gateway-cve-2022-22947-\\\"><a name=\\\"<strong>漏洞1</strong>：Spring Cloud Gateway 远程代码执行漏洞（CVE-2022-22947）\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span><strong>漏洞1</strong>：Spring Cloud Gateway 远程代码执行漏洞（CVE-2022-22947）</h2><p>3 月 1 日，VMware 官方发布安全公告，声明对 Spring Cloud Gateway 中的一处命令注入漏洞进行了修复，漏洞编号为 CVE-2022-22947：</p>\\n<p><a href=\\\"https://tanzu.vmware.com/security/cve-2022-22947\\\">https://tanzu.vmware.com/security/cve-2022-22947</a></p>\\n<p><strong>漏洞描述</strong></p>\\n<p>使用 Spring Cloud Gateway 的应用如果对外暴露了 Gateway Actuator 端点时，则可能存在被 CVE-2022-22947 漏洞利用的风险。攻击者可通过利用此漏洞执行 SpEL 表达式，允许在远程主机上进行任意远程执行。，获取系统权限。</p>\\n<p><strong>影响范围</strong></p>\\n<p>漏洞利用的前置条件：</p>\\n<ol>\\n<li>除了 Spring Cloud Gateway 外，程序还用到了 Spring Boot Actuator 组件（它用于对外提供 /actuator/ 接口）；</li><li>Spring 配置对外暴露 gateway 接口，如 application.properties 配置为：</li></ol>\\n<pre><code class=\\\"lang-properties\\\"># 默认为true\\nmanagement.endpoint.gateway.enabled=true\\n# 以逗号分隔的一系列值，默认为 health# 若包含 gateway 即表示对外提供 Spring Cloud Gateway 接口\\nmanagement.endpoints.web.exposure.include=gateway\\n</code></pre>\\n<p>漏洞影响的 Spring Cloud Gateway 版本范围：</p>\\n<ul>\\n<li>Spring Cloud Gateway 3.1.x &lt; 3.1.1</li><li>Spring Cloud Gateway 3.0.x &lt; 3.0.7</li><li>其他旧的、不受支持的 Spring Cloud Gateway 版本</li></ul>\\n<p><strong>解决方案</strong></p>\\n<p>更新升级 Spring Cloud Gateway 到以下安全版本：</p>\\n<ul>\\n<li>Spring Cloud Gateway 3.1.1</li><li>Spring Cloud Gateway 3.0.7</li></ul>\\n<p>或者在不考虑影响业务的情况下禁用 Gateway actuator 接口：</p>\\n<p>在application.properties 中设置 ：</p>\\n<pre><code class=\\\"lang-properties\\\">management.endpoint.gateway.enabled 为 false。\\n</code></pre>\\n<h2 id=\\\"h2--strong-2-strong-cve-2022-22946-spring-cloud-gateway-http2-trustmanager\\\"><a name=\\\"<strong>漏洞2</strong>：CVE-2022-22946：Spring Cloud Gateway HTTP2 不安全的 TrustManager\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span><strong>漏洞2</strong>：CVE-2022-22946：Spring Cloud Gateway HTTP2 不安全的 TrustManager</h2><p><strong>漏洞描述</strong></p>\\n<p>使用配置为启用 HTTP2 且未设置密钥存储或受信任证书的 Spring Cloud Gateway 的应用程序将被配置为使用不安全的 TrustManager。这使得网关能够使用无效或自定义证书连接到远程服务。</p>\\n<p><strong>影响范围</strong></p>\\n<p>Spring Cloud Gateway = 3.1.0</p>\\n<p><strong>解决方案</strong></p>\\n<p>官方已经发布安全版本，请升级到3.1.1+</p>\\n<p><strong>参考资料</strong></p>\\n<p>官方已经发布安全版本，请升级到3.1.1+</p>\\n<ul>\\n<li><a href=\\\"https://tanzu.vmware.com/security/cve-2022-22946\\\">https://tanzu.vmware.com/security/cve-2022-22946</a></li><li><a href=\\\"https://tanzu.vmware.com/security/cve-2022-22947\\\">https://tanzu.vmware.com/security/cve-2022-22947</a></li></ul>\\n\",\"createTime\":1646558444267,\"describe\":\"Spring Cloud 再爆高危漏洞.... 赶紧修复！！\",\"flag\":1,\"id\":2,\"imgUrl\":\"https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%BC%98%E8%B4%A8%E8%A7%86%E9%A2%91%E8%B5%84%E6%BA%90/1.png\",\"isAppreciate\":1,\"isComment\":1,\"isExplain\":1,\"isRecommend\":1,\"source\":1,\"status\":2,\"title\":\"Spring Cloud 再爆高危漏洞.... 赶紧修复！！\",\"typeId\":3,\"updateTime\":1646558444267,\"viewNum\":0}', '2022-03-06 17:20:44', '2022-03-06 17:21:42', 2, 'article_exchange', NULL, 'article_key', 2);
INSERT INTO `mq_msg` VALUES (4, '{\"articleId\":\"552903405278855168\",\"flag\":3}', '2022-03-06 17:21:12', '2022-03-06 17:22:09', 2, 'article_exchange', NULL, 'article_key', 2);
INSERT INTO `mq_msg` VALUES (5, '{\"articleId\":\"552903693322682368\",\"authorId\":\"94dd9d02befd4dac9d6e708ff92f7d82\",\"content\":\"<p><strong>大家好，我是不才陈某~</strong></p>\\n<p>Log4j2 的核弹级漏洞刚告一段落，<strong>Spring Cloud Gateway</strong> 又突发高危漏洞，又得折腾了。。。</p>\\n<p>2022年3月1日，Spring官方发布了关于Spring Cloud Gateway的两个CVE漏洞，分别为<strong>CVE-2022-22946</strong>与<strong>CVE-2022-22947</strong>：</p>\\n<p><strong>版本/分支/tag： 3.4.X</strong><br><strong>问题描述</strong>：</p>\\n<p><strong><img src=\\\"https://mmbiz.qpic.cn/mmbiz_png/AokYxdF6ctt1NeiayJzDScfIZZrNMaNAkIgMQMKP9OLVWa4hv9WFfXnfYjMLy4WAib31FW8cXMZ2BVSoYuYAia7EQ/640?wx_fmt=png\\\" alt=\\\"\\\"></strong></p>\\n<p>Spring Cloud Gateway 是 Spring Cloud 下的一个项目，该项目是基于 Spring 5.0、Spring Boot 2.0 和 Project Reactor 等技术开发的网关，它旨在为微服务架构提供一种简单有效、统一的 API 路由管理方式。</p>\\n<h2 id=\\\"h2--strong-1-strong-spring-cloud-gateway-cve-2022-22947-\\\"><a name=\\\"<strong>漏洞1</strong>：Spring Cloud Gateway 远程代码执行漏洞（CVE-2022-22947）\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span><strong>漏洞1</strong>：Spring Cloud Gateway 远程代码执行漏洞（CVE-2022-22947）</h2><p>3 月 1 日，VMware 官方发布安全公告，声明对 Spring Cloud Gateway 中的一处命令注入漏洞进行了修复，漏洞编号为 CVE-2022-22947：</p>\\n<p><a href=\\\"https://tanzu.vmware.com/security/cve-2022-22947\\\">https://tanzu.vmware.com/security/cve-2022-22947</a></p>\\n<p><strong>漏洞描述</strong></p>\\n<p>使用 Spring Cloud Gateway 的应用如果对外暴露了 Gateway Actuator 端点时，则可能存在被 CVE-2022-22947 漏洞利用的风险。攻击者可通过利用此漏洞执行 SpEL 表达式，允许在远程主机上进行任意远程执行。，获取系统权限。</p>\\n<p><strong>影响范围</strong></p>\\n<p>漏洞利用的前置条件：</p>\\n<ol>\\n<li>除了 Spring Cloud Gateway 外，程序还用到了 Spring Boot Actuator 组件（它用于对外提供 /actuator/ 接口）；</li><li>Spring 配置对外暴露 gateway 接口，如 application.properties 配置为：</li></ol>\\n<pre><code class=\\\"lang-properties\\\"># 默认为true\\nmanagement.endpoint.gateway.enabled=true\\n# 以逗号分隔的一系列值，默认为 health# 若包含 gateway 即表示对外提供 Spring Cloud Gateway 接口\\nmanagement.endpoints.web.exposure.include=gateway\\n</code></pre>\\n<p>漏洞影响的 Spring Cloud Gateway 版本范围：</p>\\n<ul>\\n<li>Spring Cloud Gateway 3.1.x &lt; 3.1.1</li><li>Spring Cloud Gateway 3.0.x &lt; 3.0.7</li><li>其他旧的、不受支持的 Spring Cloud Gateway 版本</li></ul>\\n<p><strong>解决方案</strong></p>\\n<p>更新升级 Spring Cloud Gateway 到以下安全版本：</p>\\n<ul>\\n<li>Spring Cloud Gateway 3.1.1</li><li>Spring Cloud Gateway 3.0.7</li></ul>\\n<p>或者在不考虑影响业务的情况下禁用 Gateway actuator 接口：</p>\\n<p>在application.properties 中设置 ：</p>\\n<pre><code class=\\\"lang-properties\\\">management.endpoint.gateway.enabled 为 false。\\n</code></pre>\\n<h2 id=\\\"h2--strong-2-strong-cve-2022-22946-spring-cloud-gateway-http2-trustmanager\\\"><a name=\\\"<strong>漏洞2</strong>：CVE-2022-22946：Spring Cloud Gateway HTTP2 不安全的 TrustManager\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span><strong>漏洞2</strong>：CVE-2022-22946：Spring Cloud Gateway HTTP2 不安全的 TrustManager</h2><p><strong>漏洞描述</strong></p>\\n<p>使用配置为启用 HTTP2 且未设置密钥存储或受信任证书的 Spring Cloud Gateway 的应用程序将被配置为使用不安全的 TrustManager。这使得网关能够使用无效或自定义证书连接到远程服务。</p>\\n<p><strong>影响范围</strong></p>\\n<p>Spring Cloud Gateway = 3.1.0</p>\\n<p><strong>解决方案</strong></p>\\n<p>官方已经发布安全版本，请升级到3.1.1+</p>\\n<p><strong>参考资料</strong></p>\\n<p>官方已经发布安全版本，请升级到3.1.1+</p>\\n<ul>\\n<li><a href=\\\"https://tanzu.vmware.com/security/cve-2022-22946\\\">https://tanzu.vmware.com/security/cve-2022-22946</a></li><li><a href=\\\"https://tanzu.vmware.com/security/cve-2022-22947\\\">https://tanzu.vmware.com/security/cve-2022-22947</a></li></ul>\\n\",\"createTime\":1646558512942,\"describe\":\"Spring Cloud 再爆高危漏洞.... 赶紧修复！！\",\"flag\":1,\"id\":3,\"imgUrl\":\"https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%BC%98%E8%B4%A8%E8%A7%86%E9%A2%91%E8%B5%84%E6%BA%90/1.png\",\"isAppreciate\":1,\"isComment\":1,\"isExplain\":1,\"isRecommend\":1,\"source\":1,\"status\":1,\"title\":\"Spring Cloud 再爆高危漏洞.... 赶紧修复！！\",\"typeId\":3,\"updateTime\":1646558512942,\"viewNum\":0}', '2022-03-06 17:21:53', '2022-03-06 17:22:50', 2, 'article_exchange', NULL, 'article_key', 2);
INSERT INTO `mq_msg` VALUES (6, '{\"articleId\":\"552903693322682368\",\"flag\":3}', '2022-03-06 17:22:29', '2022-03-06 17:23:26', 2, 'article_exchange', NULL, 'article_key', 2);
INSERT INTO `mq_msg` VALUES (7, '{\"articleId\":\"552903982717075456\",\"authorId\":\"94dd9d02befd4dac9d6e708ff92f7d82\",\"content\":\"<p><strong>大家好，我是不才陈某~</strong></p>\\n<p>Log4j2 的核弹级漏洞刚告一段落，<strong>Spring Cloud Gateway</strong> 又突发高危漏洞，又得折腾了。。。</p>\\n<p>2022年3月1日，Spring官方发布了关于Spring Cloud Gateway的两个CVE漏洞，分别为<strong>CVE-2022-22946</strong>与<strong>CVE-2022-22947</strong>：</p>\\n<p><strong>版本/分支/tag： 3.4.X</strong><br><strong>问题描述</strong>：</p>\\n<p><strong><img src=\\\"https://mmbiz.qpic.cn/mmbiz_png/AokYxdF6ctt1NeiayJzDScfIZZrNMaNAkIgMQMKP9OLVWa4hv9WFfXnfYjMLy4WAib31FW8cXMZ2BVSoYuYAia7EQ/640?wx_fmt=png\\\" alt=\\\"\\\"></strong></p>\\n<p>Spring Cloud Gateway 是 Spring Cloud 下的一个项目，该项目是基于 Spring 5.0、Spring Boot 2.0 和 Project Reactor 等技术开发的网关，它旨在为微服务架构提供一种简单有效、统一的 API 路由管理方式。</p>\\n<h2 id=\\\"h2--strong-1-strong-spring-cloud-gateway-cve-2022-22947-\\\"><a name=\\\"<strong>漏洞1</strong>：Spring Cloud Gateway 远程代码执行漏洞（CVE-2022-22947）\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span><strong>漏洞1</strong>：Spring Cloud Gateway 远程代码执行漏洞（CVE-2022-22947）</h2><p>3 月 1 日，VMware 官方发布安全公告，声明对 Spring Cloud Gateway 中的一处命令注入漏洞进行了修复，漏洞编号为 CVE-2022-22947：</p>\\n<p><a href=\\\"https://tanzu.vmware.com/security/cve-2022-22947\\\">https://tanzu.vmware.com/security/cve-2022-22947</a></p>\\n<p><strong>漏洞描述</strong></p>\\n<p>使用 Spring Cloud Gateway 的应用如果对外暴露了 Gateway Actuator 端点时，则可能存在被 CVE-2022-22947 漏洞利用的风险。攻击者可通过利用此漏洞执行 SpEL 表达式，允许在远程主机上进行任意远程执行。，获取系统权限。</p>\\n<p><strong>影响范围</strong></p>\\n<p>漏洞利用的前置条件：</p>\\n<ol>\\n<li>除了 Spring Cloud Gateway 外，程序还用到了 Spring Boot Actuator 组件（它用于对外提供 /actuator/ 接口）；</li><li>Spring 配置对外暴露 gateway 接口，如 application.properties 配置为：</li></ol>\\n<pre><code class=\\\"lang-properties\\\"># 默认为true\\nmanagement.endpoint.gateway.enabled=true\\n# 以逗号分隔的一系列值，默认为 health# 若包含 gateway 即表示对外提供 Spring Cloud Gateway 接口\\nmanagement.endpoints.web.exposure.include=gateway\\n</code></pre>\\n<p>漏洞影响的 Spring Cloud Gateway 版本范围：</p>\\n<ul>\\n<li>Spring Cloud Gateway 3.1.x &lt; 3.1.1</li><li>Spring Cloud Gateway 3.0.x &lt; 3.0.7</li><li>其他旧的、不受支持的 Spring Cloud Gateway 版本</li></ul>\\n<p><strong>解决方案</strong></p>\\n<p>更新升级 Spring Cloud Gateway 到以下安全版本：</p>\\n<ul>\\n<li>Spring Cloud Gateway 3.1.1</li><li>Spring Cloud Gateway 3.0.7</li></ul>\\n<p>或者在不考虑影响业务的情况下禁用 Gateway actuator 接口：</p>\\n<p>在application.properties 中设置 ：</p>\\n<pre><code class=\\\"lang-properties\\\">management.endpoint.gateway.enabled 为 false。\\n</code></pre>\\n<h2 id=\\\"h2--strong-2-strong-cve-2022-22946-spring-cloud-gateway-http2-trustmanager\\\"><a name=\\\"<strong>漏洞2</strong>：CVE-2022-22946：Spring Cloud Gateway HTTP2 不安全的 TrustManager\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span><strong>漏洞2</strong>：CVE-2022-22946：Spring Cloud Gateway HTTP2 不安全的 TrustManager</h2><p><strong>漏洞描述</strong></p>\\n<p>使用配置为启用 HTTP2 且未设置密钥存储或受信任证书的 Spring Cloud Gateway 的应用程序将被配置为使用不安全的 TrustManager。这使得网关能够使用无效或自定义证书连接到远程服务。</p>\\n<p><strong>影响范围</strong></p>\\n<p>Spring Cloud Gateway = 3.1.0</p>\\n<p><strong>解决方案</strong></p>\\n<p>官方已经发布安全版本，请升级到3.1.1+</p>\\n<p><strong>参考资料</strong></p>\\n<p>官方已经发布安全版本，请升级到3.1.1+</p>\\n<ul>\\n<li><a href=\\\"https://tanzu.vmware.com/security/cve-2022-22946\\\">https://tanzu.vmware.com/security/cve-2022-22946</a></li><li><a href=\\\"https://tanzu.vmware.com/security/cve-2022-22947\\\">https://tanzu.vmware.com/security/cve-2022-22947</a></li></ul>\\n\",\"createTime\":1646558581939,\"describe\":\"Spring Cloud 再爆高危漏洞.... 赶紧修复！！\",\"flag\":1,\"id\":4,\"imgUrl\":\"https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%BC%98%E8%B4%A8%E8%A7%86%E9%A2%91%E8%B5%84%E6%BA%90/1.png\",\"isAppreciate\":1,\"isComment\":1,\"isExplain\":1,\"isRecommend\":1,\"source\":1,\"status\":2,\"title\":\"Spring Cloud 再爆高危漏洞.... 赶紧修复！！\",\"typeId\":3,\"updateTime\":1646558581939,\"viewNum\":0}', '2022-03-06 17:23:02', '2022-03-06 17:23:59', 2, 'article_exchange', NULL, 'article_key', 2);
INSERT INTO `mq_msg` VALUES (8, '{\"articleId\":\"552917751014883328\",\"authorId\":\"94dd9d02befd4dac9d6e708ff92f7d82\",\"content\":\"<p><strong>大家好，我是不才陈某~</strong></p>\\n<p>这是<a href=\\\"https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&amp;action=getalbum&amp;album_id=2042874937312346114&amp;scene=126#wechat_redirect\\\">《Spring Cloud 进阶》</a>第<strong>24</strong>篇文章，往期文章如下：</p>\\n<ul>\\n<li><a href=\\\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247493854&amp;idx=1&amp;sn=4b3fb7f7e17a76000733899f511ef915&amp;scene=21#wechat_redirect\\\">五十五张图告诉你微服务的灵魂摆渡者Nacos究竟有多强？</a></li><li><a href=\\\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247496653&amp;idx=1&amp;sn=7185077b3bdc1d094aef645d677ec472&amp;scene=21#wechat_redirect\\\">openFeign夺命连环9问，这谁受得了？</a></li><li><a href=\\\"https://mp.weixin.qq.com/s/S_8HQYHOG624Vzeu94CFSA\\\">阿里面试这样问：Nacos、Apollo、Config配置中心如何选型？这10个维度告诉你！</a></li><li><a href=\\\"https://mp.weixin.qq.com/s/YKzYdMu-7nwszEf9-1M3Uw\\\">阿里面试败北：5种微服务注册中心如何选型？这几个维度告诉你！</a></li><li><a href=\\\"https://mp.weixin.qq.com/s/Q7Xv8cypQFrrOQhbd9BOXw\\\">阿里限流神器Sentinel夺命连环 17 问？</a></li><li><a href=\\\"https://mp.weixin.qq.com/s/sXVSFqq2UZ6Pwwt7vx7vIA\\\">对比7种分布式事务方案，还是偏爱阿里开源的Seata，真香！(原理+实战)</a></li><li><a href=\\\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247499894&amp;idx=1&amp;sn=f1606e4c00fd15292269afe052f5bca2&amp;chksm=fcf71fbbcb8096ad349e6da50b0b9141964c2084d0a38eba977fe8baa3fbe8af3b20c7591110&amp;token=1887105114&amp;lang=zh_CN#rd\\\">Spring Cloud Gateway夺命连环10问？</a></li><li><a href=\\\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247500540&amp;idx=1&amp;sn=2967bf1f9fa2c4d5b94b7fe291b7869b&amp;chksm=fcf71d31cb8094271b5bbeca85cc03cf7d7c8bbf7c4d5b83a539e39c956e3f4015f91e7742b6&amp;token=2077958771&amp;lang=zh_CN#rd\\\">Spring Cloud Gateway 整合阿里 Sentinel网关限流实战！</a></li><li><a href=\\\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247500757&amp;idx=1&amp;sn=ef71f10d5736029c92287f7894c842ed&amp;chksm=fcf71c18cb80950ec3144d66957a9d2914b51b8af22cf59a1ca3f9e2b561a11aca359d50d5a1&amp;scene=178&amp;cur_album_id=2042874937312346114#rd\\\">分布式链路追踪之Spring Cloud Sleuth夺命连环9问？</a></li><li><a href=\\\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247501079&amp;idx=1&amp;sn=438ef3a3d65fb4919b61cf6972827bec&amp;chksm=fcf71adacb8093ccc4c3d6dfb8860ca07aefbc761c1ed5126eb4a4e87548441841198db1f8e3&amp;scene=178&amp;cur_album_id=2042874937312346114#rd\\\">链路追踪自从用了SkyWalking，睡的真香！</a></li><li><a href=\\\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247501590&amp;idx=1&amp;sn=149d1498504cda7cc391413f14cda9c2&amp;chksm=fcf718dbcb8091cd6907e86e148216bae0a2d5b1664b1e8cc2d3e2c96c38181cc778de5711b6&amp;scene=178&amp;cur_album_id=2042874937312346114#rd\\\">3本书了，7万+字，10篇文章，《Spring Cloud 进阶》基础版 PDF</a></li><li><a href=\\\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247502682&amp;idx=1&amp;sn=52a15b623ab6135c134b8262bd605946&amp;chksm=fcf71497cb809d81f1d2dbce76b3e00170f085306b2a2a67a807a6d9e2cf03bf1de3b8f203a2&amp;scene=178&amp;cur_album_id=2042874937312346114#rd\\\">妹子始终没搞懂OAuth2.0，今天整合Spring Cloud Security 一次说明白！</a></li><li><a href=\\\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247502801&amp;idx=1&amp;sn=56b1af09bfa25d5e44193a7d75dfa623&amp;chksm=fcf7141ccb809d0a1b0b2d7f6d9893c7d3e560dd8996296276f0274d2578236ee87e9124810d&amp;scene=178&amp;cur_album_id=2042874937312346114#rd\\\">OAuth2.0实战！使用JWT令牌认证！</a></li><li><a href=\\\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247502905&amp;idx=1&amp;sn=32ba3ae4e0a4097d238f64719c88b7f7&amp;chksm=fcf713f4cb809ae2ccb706b8e9f8184739d3c7b97d388467bfe9ff31a8c15768b6de05054f08&amp;scene=178&amp;cur_album_id=2042874937312346114#rd\\\">OAuth2.0实战！玩转认证、资源服务异常自定义这些骚操作！</a></li><li><a href=\\\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247503249&amp;idx=1&amp;sn=b33ae3ff70a08b17ee0779d6ccb30b53&amp;chksm=fcf7125ccb809b4aa4985da09e620e06c606754e6a72681c93dcc88bdc9aa7ba0cb64f52dbc3&amp;token=1286998820&amp;lang=zh_CN#rd\\\">实战干货！Spring Cloud Gateway 整合 OAuth2.0 实现分布式统一认证授权！</a></li><li><a href=\\\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247503263&amp;idx=1&amp;sn=edc475e36127792e35112c4746e53d37&amp;chksm=fcf71252cb809b44d7ae246e9503e1d6b91b29965c0cd7ebfc7da9c1a098fe186cd977736c40&amp;token=1144087588&amp;lang=zh_CN#rd\\\">字节面试这样问：跨库多表存在大量数据依赖问题有哪些解决方案？</a></li><li><a href=\\\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247504322&amp;idx=1&amp;sn=4b0a2488a4edcb025d0694604e86f840&amp;chksm=fcf70e0fcb808719b98a65891bc08e9490db09f07debd4521052978a319ab052f8a72b93c1a7&amp;token=284256295&amp;lang=zh_CN#rd\\\">实战！退出登录时如何借助外力使JWT令牌失效？</a></li><li><a href=\\\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247504442&amp;idx=1&amp;sn=48c1dd73c038e3d936db4e5134f7bbc2&amp;chksm=fcf70df7cb8084e1556cac092fdb68ffd6503cbb287485ef76e9941611d134258c38d03e890a&amp;token=780863812&amp;lang=zh_CN#rd\\\">实战！Spring Cloud Gateway集成 RBAC 权限模型实现动态权限控制！</a></li><li><a href=\\\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247504650&amp;idx=1&amp;sn=d7b3df7bcb8483a503749c863e0e0217&amp;chksm=fcf70cc7cb8085d11b46fd08613e6749ee5be6d25183f0f6c2561506e34954564cfe2d7fd46a&amp;token=439402375&amp;lang=zh_CN#rd\\\">实战！阿里神器 Seata 实现 TCC模式 解决分布式事务，真香！</a></li><li><a href=\\\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247504759&amp;idx=1&amp;sn=e50d5b44eb64debf43c6d644f55c68b5&amp;chksm=fcf70cbacb8085aca5cd88688973ed45cd8bd9a4642ae97727f3684b431f80316e5c073d6946&amp;scene=178&amp;cur_album_id=2042874937312346114#rd\\\">实战！openFeign如何实现全链路JWT令牌信息不丢失？</a></li><li><a href=\\\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247505342&amp;idx=1&amp;sn=3e701ee24e1a87ce3b438d840aa1c356&amp;chksm=fcf70a73cb80836547debd445832ae757e0b786ee71fc9b4229025d07a1eebd3ef219a4c2438&amp;scene=178&amp;cur_album_id=2042874937312346114#rd\\\">微服务下蓝绿发布、滚动发布、灰度发布等方案，必须懂！</a></li><li><a href=\\\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247505642&amp;idx=1&amp;sn=6e07461626c690dfeab4704941f1e55d&amp;chksm=fcf70927cb8080312ea2a942d99e27ea70b4466f36fdf115bf837a5226011048f50175b347ee&amp;scene=178&amp;cur_album_id=2042874937312346114#rd\\\">微服务如何聚合 API 文档？这波秀~</a></li><li><a href=\\\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247506116&amp;idx=1&amp;sn=a878dc620b4d850b540917a583ca12d8&amp;chksm=fcf70709cb808e1fe0db4a1e897e6bf5dc3b07a2fd6c2881920953cd9e19aed0ae049745ec0f&amp;scene=178&amp;cur_album_id=2042874937312346114#rd\\\">Spring Cloud 2021.0.1 正式发布，卷不动了~</a></li></ul>\\n<p>本篇文章介绍一下Spring Security如何扩展新的授权类型，也是实际开发中非常重要的知识点。</p>\\n<p>目录如下：</p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/BlogImage/raw/master/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%88%E6%9D%83%E7%B1%BB%E5%9E%8B/13.png\\\" alt=\\\"\\\"></p>\\n<h2 id=\\\"h2--\\\"><a name=\\\"为什么需要自定义授权类型？\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>为什么需要自定义授权类型？</h2><p>前面介绍OAuth2.0的基础知识点时介绍过支持的4种授权类型，分别如下：</p>\\n<ul>\\n<li>授权码模式</li><li>简化模式</li><li>客户端模式</li><li>密码模式</li></ul>\\n<p>关于上述4种授权类型不清楚的，可以看之前的文章：<a href=\\\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247502682&amp;idx=1&amp;sn=52a15b623ab6135c134b8262bd605946&amp;chksm=fcf71497cb809d81f1d2dbce76b3e00170f085306b2a2a67a807a6d9e2cf03bf1de3b8f203a2&amp;scene=178&amp;cur_album_id=2042874937312346114#rd\\\">妹子始终没搞懂OAuth2.0，今天整合Spring Cloud Security 一次说明白！</a></p>\\n<p>实际生产中上述四种授权类型根本不够用，比如常见的授权类型如下：</p>\\n<ul>\\n<li>微信认证</li><li>QQ认证</li><li>手机号+验证码认证</li><li>图形验证码认证</li><li>邮箱认证</li></ul>\\n<p>因此我们必须懂得OAuth2.0如何自定义授权类型，这也是本篇文章的重点。</p>\\n<h2 id=\\\"h2-u5B9Eu73B0u601Du8DEF\\\"><a name=\\\"实现思路\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>实现思路</h2><p>Spring Security 定制授权类型其实很简单，主要是掌握其中的思路，下面是密码模式的授权流程，如下图：</p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/BlogImage/raw/master/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%88%E6%9D%83%E7%B1%BB%E5%9E%8B/1.jpg\\\" alt=\\\"\\\"></p>\\n<p>根据上述流程图可以跟着源码进去看看，不难发现有几个如下重要点：</p>\\n<ul>\\n<li>每种授权类型都对应一个实现类<strong>TokenGranter</strong>，其中定义着授权类型</li><li>所有 <code>TokenGranter</code> 实现类都通过 <code>CompositeTokenGranter</code> 中的 <code>tokenGranters</code> 集合存起来。</li><li>然后通过判断 <code>grantType</code> 参数来定位具体使用那个 <code>TokenGranter</code> 实现类来处理授权。</li><li>每种授权方式都对应一个<strong>AuthenticationProvider</strong></li><li><code>TokenGranter</code> 类会 new 一个 <strong>AuthenticationToken</strong>实现类，如 <code>UsernamePasswordAuthenticationToken</code> 传给 <code>ProviderManager</code> 类。</li></ul>\\n<p>因此想要自定义一个授权类型，必须构建自己的<strong>TokenGranter</strong>、<strong>AuthenticationProvider</strong>、<strong>AuthenticationToken</strong>。</p>\\n<h2 id=\\\"h2-u4EE3u7801u5B9Eu73B0\\\"><a name=\\\"代码实现\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>代码实现</h2><p>下面就以<strong>手机号+密码</strong>的登录方式定义一个类型：<strong>mobile_pwd</strong>，剩下的自己照葫芦画瓢。</p>\\n<h3 id=\\\"h3-1-userdetailservice\\\"><a name=\\\"1、自定义UserDetailService\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>1、自定义UserDetailService</h3><p>这个和密码授权类型类似，要实现一个方法从数据库中根据手机号查询用户的详细信息。</p>\\n<p>定义一个<strong>SmsCodeUserDetailService</strong>接口如下：</p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/BlogImage/raw/master/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%88%E6%9D%83%E7%B1%BB%E5%9E%8B/2.png\\\" alt=\\\"\\\"></p>\\n<p>主要就是一个 <strong>loadUserByMobile()</strong> 方法，实现类如下：</p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/BlogImage/raw/master/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%88%E6%9D%83%E7%B1%BB%E5%9E%8B/3.png\\\" alt=\\\"\\\"></p>\\n<h3 id=\\\"h3-2-authenticationtoken\\\"><a name=\\\"2、自定义AuthenticationToken\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>2、自定义AuthenticationToken</h3><p>类似于密码模式的中<strong>UsernamePasswordAuthenticationToken</strong>，自定义一个<strong>MobilePasswordAuthenticationToken</strong>封装手机号和密码，如下：</p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/BlogImage/raw/master/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%88%E6%9D%83%E7%B1%BB%E5%9E%8B/4.png\\\" alt=\\\"\\\"></p>\\n<h3 id=\\\"h3-3-tokengranter\\\"><a name=\\\"3、自定义TokenGranter\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>3、自定义TokenGranter</h3><p>每种授权类型都对应一种TokenGranter，其中会定义授权类型的名称，比如密码模式的<strong>ResourceOwnerPasswordTokenGranter</strong>，其中的GRANT_TYPE为password。</p>\\n<p>自定义一个<strong>MobilePwdGranter</strong>，照葫芦画瓢，模仿着改改，代码如下：</p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/BlogImage/raw/master/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%88%E6%9D%83%E7%B1%BB%E5%9E%8B/5.png\\\" alt=\\\"\\\"></p>\\n<h3 id=\\\"h3-4-authenticationprovider\\\"><a name=\\\"4、自定义AuthenticationProvider\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>4、自定义AuthenticationProvider</h3><p>这个类就是真正的处理类，经过TokenGranter后，会找到对应的AuthenticationProvider，然后取出参数从数据库（<strong>UserDetailService</strong>）中查询对应的信息进行匹配。</p>\\n<p>自定义<strong>MobilePasswordAuthenticationProvider</strong>，代码如下：</p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/BlogImage/raw/master/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%88%E6%9D%83%E7%B1%BB%E5%9E%8B/6.png\\\" alt=\\\"\\\"><img src=\\\"https://gitee.com/chenjiabing666/BlogImage/raw/master/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%88%E6%9D%83%E7%B1%BB%E5%9E%8B/7.png\\\" alt=\\\"\\\"></p>\\n<blockquote>\\n<p>案例源码已上传GitHub，关注公众号：<strong>码猿技术专栏</strong>，回复关键：<strong>9529</strong> 获取！</p>\\n</blockquote>\\n<h3 id=\\\"h3-5-mobilepasswordauthenticationprovider-ioc-\\\"><a name=\\\"5、将自定义的MobilePasswordAuthenticationProvider注入IOC容器\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>5、将自定义的MobilePasswordAuthenticationProvider注入IOC容器</h3><p>这里必须将自定义的MobilePasswordAuthenticationProvider注入到IOC容器，如果不注入，会报找不到能处理的AuthenticationProvider这个异常。</p>\\n<p>新建<strong>SmsCodeSecurityConfig</strong>，代码如下：</p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/BlogImage/raw/master/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%88%E6%9D%83%E7%B1%BB%E5%9E%8B/8.png\\\" alt=\\\"\\\"></p>\\n<blockquote>\\n<p>注意：由于使用的外部配置，因此必须在全局配置中指定</p>\\n</blockquote>\\n<h3 id=\\\"h3-6-security-smscodesecurityconfig\\\"><a name=\\\"6、Security的全局配置指定SmsCodeSecurityConfig\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>6、Security的全局配置指定SmsCodeSecurityConfig</h3><p>由于是分开配置，因此必须在全局配置中指定才会生效，代码如下：</p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/BlogImage/raw/master/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%88%E6%9D%83%E7%B1%BB%E5%9E%8B/9.png\\\" alt=\\\"\\\"></p>\\n<h3 id=\\\"h3-7-compositetokengranter-\\\"><a name=\\\"7、加到CompositeTokenGranter集合中\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>7、加到CompositeTokenGranter集合中</h3><p>需要将自定义的授权类型加到集合CompositeTokenGranter中，此处需要修改认证中心的配置类（<strong>AuthorizationServerConfig</strong>）中的代码，如下：</p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/BlogImage/raw/master/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%88%E6%9D%83%E7%B1%BB%E5%9E%8B/10.png\\\" alt=\\\"\\\"></p>\\n<h3 id=\\\"h3-8-oauth_client_details-\\\"><a name=\\\"8、oauth_client_details表中添加授权类型\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>8、oauth_client_details表中添加授权类型</h3><p><strong>oauth_client_details</strong>这个表是存储客户端的详细信息的，需要在对应的客户端资源那一行中的<strong>authorized_grant_types</strong>这个字段中添加自定义的授权类型，多个用逗号分隔。</p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/BlogImage/raw/master/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%88%E6%9D%83%E7%B1%BB%E5%9E%8B/11.png\\\" alt=\\\"\\\"></p>\\n<h2 id=\\\"h2-u6D4Bu8BD5\\\"><a name=\\\"测试\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>测试</h2><p>经过上述的步骤已经配置完成，下面来测试，启动服务，请求如下：</p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/BlogImage/raw/master/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%88%E6%9D%83%E7%B1%BB%E5%9E%8B/12.jpg\\\" alt=\\\"\\\"></p>\\n<h2 id=\\\"h2-u6E90u7801u83B7u53D6\\\"><a name=\\\"源码获取\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>源码获取</h2><p>授权类型主要是针对 <strong>认证中心（oauth2-cloud-auth-server）</strong> 的改动，改动的目录如下：</p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/BlogImage/raw/master/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%88%E6%9D%83%E7%B1%BB%E5%9E%8B/12.png\\\" alt=\\\"\\\"></p>\\n<p>陈某直接在之前网关整合<strong>Spring Security</strong>的源码上更改了一版。</p>\\n<blockquote>\\n<p>案例源码已上传GitHub，关注公众号：<strong>码猿技术专栏</strong>，回复关键：<strong>9529</strong> 获取！</p>\\n</blockquote>\\n<h2 id=\\\"h2--\\\"><a name=\\\"最后说一句（别白嫖，求关注）\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>最后说一句（别白嫖，求关注）</h2><p>陈某每一篇文章都是精心输出，已经写了<strong>3个专栏</strong>，整理成<strong>PDF</strong>，获取方式如下：</p>\\n<ol>\\n<li><a href=\\\"https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&amp;action=getalbum&amp;album_id=2042874937312346114#wechat_redirect\\\">《Spring Cloud 进阶》</a>PDF：关注公众号：【<strong>码猿技术专栏</strong>】回复关键词 <strong>Spring Cloud 进阶</strong> 获取！</li><li><a href=\\\"https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&amp;action=getalbum&amp;album_id=1532834475389288449#wechat_redirect\\\">《Spring Boot 进阶》</a>PDF：关注公众号：【<strong>码猿技术专栏</strong>】回复关键词 <strong>Spring Boot进阶</strong> 获取！</li><li><a href=\\\"https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&amp;action=getalbum&amp;album_id=1500819225232343046#wechat_redirect\\\">《Mybatis 进阶》</a>PDF：关注公众号：【<strong>码猿技术专栏</strong>】回复关键词 <strong>Mybatis 进阶</strong> 获取！</li></ol>\\n<p>如果这篇文章对你有所帮助，或者有所启发的话，帮忙<strong>点赞</strong>、<strong>在看</strong>、<strong>转发</strong>、<strong>收藏</strong>，你的支持就是我坚持下去的最大动力！</p>\\n<p>关注公众号：<strong>【码猿技术专栏】</strong>，公众号内有超赞的粉丝福利，回复：<strong>加群</strong>，可以加入技术讨论群，和大家一起讨论技术，吹牛逼！</p>\\n\",\"createTime\":1646561864557,\"describe\":\"Spring Cloud 自定义授权模式\",\"flag\":1,\"id\":5,\"imgUrl\":\"https://gitee.com/chenjiabing666/BlogImage/raw/master/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%88%E6%9D%83%E7%B1%BB%E5%9E%8B/13.png\",\"isAppreciate\":1,\"isComment\":1,\"isExplain\":1,\"isRecommend\":1,\"source\":1,\"status\":2,\"title\":\"Spring Cloud 自定义授权模式\",\"typeId\":3,\"updateTime\":1646561864557,\"viewNum\":0}', '2022-03-06 18:17:45', '2022-03-06 18:18:42', 2, 'article_exchange', NULL, 'article_key', 2);
INSERT INTO `mq_msg` VALUES (9, '{\"articleId\":\"552917989473648640\",\"authorId\":\"94dd9d02befd4dac9d6e708ff92f7d82\",\"content\":\"<p><strong>大家好，我是不才陈某~</strong></p>\\n<p>数据同步一直是一个令人头疼的问题。在业务量小，场景不多，数据量不大的情况下我们可能会选择在项目中直接写一些定时任务手动处理数据，例如从多个表将数据查出来，再汇总处理，再插入到相应的地方。</p>\\n<p>但是随着业务量增大，数据量变多以及各种复杂场景下的分库分表的实现，使数据同步变得越来越困难。</p>\\n<p>今天这篇文章使用<strong>阿里</strong>开源的中间件<strong>Canal</strong>解决数据增量同步的痛点。</p>\\n<p>文章目录如下：</p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/204.png\\\" alt=\\\"\\\"></p>\\n<h2 id=\\\"h2-canal-\\\"><a name=\\\"Canal是什么？\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>Canal是什么？</h2><p><strong>canal</strong>译意为水道/管道/沟渠，主要用途是基于 <strong>MySQL</strong> 数据库<strong>增量日志</strong>解析，提供增量数据订阅和消费。</p>\\n<p>从这句话理解到了什么？</p>\\n<p>基于MySQL，并且通过MySQL日志进行的增量解析，这也就意味着对原有的业务代码完全是无侵入性的。</p>\\n<blockquote>\\n<p>工作原理：解析MySQL的binlog日志，提供增量数据。</p>\\n</blockquote>\\n<p>基于日志增量订阅和消费的业务包括</p>\\n<ul>\\n<li>数据库镜像</li><li>数据库实时备份</li><li>索引构建和实时维护(拆分异构索引、倒排索引等)</li><li>业务 cache 刷新</li><li>带业务逻辑的增量数据处理</li></ul>\\n<p>当前的 canal 支持源端 MySQL 版本包括 5.1.x , 5.5.x , 5.6.x , 5.7.x , 8.0.x。</p>\\n<blockquote>\\n<p>官方文档：<a href=\\\"https://github.com/alibaba/canal\\\">https://github.com/alibaba/canal</a></p>\\n</blockquote>\\n<h2 id=\\\"h2-canal-\\\"><a name=\\\"Canal数据如何传输？\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>Canal数据如何传输？</h2><p>先来一张官方图：</p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/196.png\\\" alt=\\\"\\\"></p>\\n<p>Canal分为服务端和客户端，这也是阿里常用的套路，比如前面讲到的注册中心<strong>Nacos</strong>：</p>\\n<ul>\\n<li><strong>服务端</strong>：负责解析MySQL的binlog日志，传递增量数据给客户端或者消息中间件</li><li><strong>客户端</strong>：负责解析服务端传过来的数据，然后定制自己的业务处理。</li></ul>\\n<p>目前为止支持的消息中间件很全面了，比如<strong>Kafka</strong>、<strong>RocketMQ</strong>，<strong>RabbitMQ</strong>。</p>\\n<h2 id=\\\"h2--\\\"><a name=\\\"数据同步还有其他中间件吗？\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>数据同步还有其他中间件吗？</h2><p>有，当然有，还有一些开源的中间件也是相当不错的，比如<strong>Bifrost</strong>。</p>\\n<p>常见的几款中间件的区别如下：</p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/197.png\\\" alt=\\\"\\\"></p>\\n<p>当然要我选择的话，首选阿里的中间件Canal。</p>\\n<h2 id=\\\"h2-canal-\\\"><a name=\\\"Canal服务端安装\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>Canal服务端安装</h2><p>服务端需要下载压缩包，下载地址：<a href=\\\"https://github.com/alibaba/canal/releases\\\">https://github.com/alibaba/canal/releases</a></p>\\n<p>目前最新的是<strong>v1.1.5</strong>，点击下载：</p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/198.png\\\" alt=\\\"\\\"></p>\\n<p>下载完成解压，目录如下：</p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/199.png\\\" alt=\\\"\\\"></p>\\n<p>本文使用<strong>Canal+RabbitMQ</strong>进行数据的同步，因此下面步骤完全按照这个base进行。</p>\\n<h3 id=\\\"h3--strong-1-mysql-binlog-strong-\\\"><a name=\\\"<strong>1、打开MySQL的binlog日志</strong>\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span><strong>1、打开MySQL的binlog日志</strong></h3><p>修改MySQL的日志文件，my.cnf 配置如下：</p>\\n<pre><code class=\\\"lang-properties\\\">[mysqld]\\nlog-bin=mysql-bin # 开启 binlog\\nbinlog-format=ROW # 选择 ROW 模式\\nserver_id=1 # 配置 MySQL replaction 需要定义，不要和 canal 的 slaveId 重复\\n</code></pre>\\n<h3 id=\\\"h3--strong-2-mysql-strong-\\\"><a name=\\\"<strong>2、设置MySQL的配置</strong>\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span><strong>2、设置MySQL的配置</strong></h3><p>需要设置服务端配置文件中的MySQL配置，这样Canal才能知道需要监听哪个库、哪个表的日志文件。</p>\\n<p>一个 Server 可以配置多个实例监听 ，Canal 功能默认自带的有个 example 实例，本篇就用 example 实例 。如果增加实例，复制 example 文件夹内容到同级目录下，然后在 <code>canal.properties</code> 指定添加实例的名称。</p>\\n<p><strong>修改canal.deployer-1.1.5\\\\conf\\\\example\\\\instance.properties配置文件</strong></p>\\n<pre><code class=\\\"lang-properties\\\"># url\\ncanal.instance.master.address=127.0.0.1:3306\\n# username/password\\ncanal.instance.dbUsername=root\\ncanal.instance.dbPassword=root\\n# 监听的数据库\\ncanal.instance.defaultDatabaseName=test\\n\\n# 监听的表，可以指定，多个用逗号分割，这里正则是监听所有\\ncanal.instance.filter.regex=.*\\\\\\\\..*\\n</code></pre>\\n<h3 id=\\\"h3--strong-3-rabbitmq-strong-\\\"><a name=\\\"<strong>3、设置RabbitMQ的配置</strong>\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span><strong>3、设置RabbitMQ的配置</strong></h3><p>服务端默认的传输方式是<strong>tcp</strong>，需要在配置文件中设置<strong>MQ</strong>的相关信息。</p>\\n<p>这里需要修改两处配置文件，如下；</p>\\n<p><strong>1、canal.deployer-1.1.5\\\\conf\\\\canal.properties</strong></p>\\n<p>这个配置文件主要是设置MQ相关的配置，比如URL，用户名、密码…</p>\\n<pre><code class=\\\"lang-properties\\\"># 传输方式：tcp, kafka, rocketMQ, rabbitMQ\\ncanal.serverMode = rabbitMQ\\n##################################################\\n#########             RabbitMQ         #############\\n##################################################\\nrabbitmq.host = 127.0.0.1\\nrabbitmq.virtual.host =/\\n# exchange\\nrabbitmq.exchange =canal.exchange\\n# 用户名、密码\\nrabbitmq.username =guest\\nrabbitmq.password =guest\\n## 是否持久化\\nrabbitmq.deliveryMode = 2\\n</code></pre>\\n<p>2、<strong>canal.deployer-1.1.5\\\\conf\\\\example\\\\instance.properties</strong></p>\\n<p>这个文件设置MQ的路由KEY，这样才能路由到指定的队列中，如下：</p>\\n<pre><code class=\\\"lang-properties\\\">canal.mq.topic=canal.routing.key\\n</code></pre>\\n<h3 id=\\\"h3--strong-4-rabbitmq-exchange-queue-strong-\\\"><a name=\\\"<strong>4、RabbitMQ新建exchange和Queue</strong>\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span><strong>4、RabbitMQ新建exchange和Queue</strong></h3><p>在RabbitMQ中需要新建一个<strong>canal.exchange</strong>（必须和配置中的相同）的exchange和一个名称为 <strong>canal.queue</strong>（名称随意）的队列。</p>\\n<p>其中绑定的路由KEY为：<strong>canal.routing.key</strong>（必须和配置中的相同），如下图：</p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/200.png\\\" alt=\\\"\\\"></p>\\n<h3 id=\\\"h3--strong-5-strong-\\\"><a name=\\\"<strong>5、启动服务端</strong>\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span><strong>5、启动服务端</strong></h3><p>点击bin目录下的脚本，windows直接双击<strong>startup.bat</strong>，启动成功如下：</p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/201.png\\\" alt=\\\"\\\"></p>\\n<h3 id=\\\"h3--strong-6-strong-\\\"><a name=\\\"<strong>6、测试</strong>\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span><strong>6、测试</strong></h3><p>在本地数据库<strong>test</strong>中的<strong>oauth_client_details</strong>插入一条数据，如下：</p>\\n<pre><code class=\\\"lang-mysql\\\">INSERT INTO `oauth_client_details` VALUES (&#39;myjszl&#39;, &#39;res1&#39;, &#39;$2a$10$F1tQdeb0SEMdtjlO8X/0wO6Gqybu6vPC/Xg8OmP9/TL1i4beXdK9W&#39;, &#39;all&#39;, &#39;password,refresh_token,authorization_code,client_credentials,implicit&#39;, &#39;http://www.baidu.com&#39;, NULL, 1000, 1000, NULL, &#39;false&#39;);\\n</code></pre>\\n<p>此时查看MQ中的<strong>canal.queue</strong>已经有了数据，如下：</p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/202.png\\\" alt=\\\"\\\"></p>\\n<p>其实就是一串JSON数据，这个JSON如下：</p>\\n<pre><code class=\\\"lang-json\\\">{\\n    &quot;data&quot;: [{\\n        &quot;client_id&quot;: &quot;myjszl&quot;,\\n        &quot;resource_ids&quot;: &quot;res1&quot;,\\n        &quot;client_secret&quot;: &quot;$2a$10$F1tQdeb0SEMdtjlO8X/0wO6Gqybu6vPC/Xg8OmP9/TL1i4beXdK9W&quot;,\\n        &quot;scope&quot;: &quot;all&quot;,\\n        &quot;authorized_grant_types&quot;: &quot;password,refresh_token,authorization_code,client_credentials,implicit&quot;,\\n        &quot;web_server_redirect_uri&quot;: &quot;http://www.baidu.com&quot;,\\n        &quot;authorities&quot;: null,\\n        &quot;access_token_validity&quot;: &quot;1000&quot;,\\n        &quot;refresh_token_validity&quot;: &quot;1000&quot;,\\n        &quot;additional_information&quot;: null,\\n        &quot;autoapprove&quot;: &quot;false&quot;\\n    }],\\n    &quot;database&quot;: &quot;test&quot;,\\n    &quot;es&quot;: 1640337532000,\\n    &quot;id&quot;: 7,\\n    &quot;isDdl&quot;: false,\\n    &quot;mysqlType&quot;: {\\n        &quot;client_id&quot;: &quot;varchar(48)&quot;,\\n        &quot;resource_ids&quot;: &quot;varchar(256)&quot;,\\n        &quot;client_secret&quot;: &quot;varchar(256)&quot;,\\n        &quot;scope&quot;: &quot;varchar(256)&quot;,\\n        &quot;authorized_grant_types&quot;: &quot;varchar(256)&quot;,\\n        &quot;web_server_redirect_uri&quot;: &quot;varchar(256)&quot;,\\n        &quot;authorities&quot;: &quot;varchar(256)&quot;,\\n        &quot;access_token_validity&quot;: &quot;int(11)&quot;,\\n        &quot;refresh_token_validity&quot;: &quot;int(11)&quot;,\\n        &quot;additional_information&quot;: &quot;varchar(4096)&quot;,\\n        &quot;autoapprove&quot;: &quot;varchar(256)&quot;\\n    },\\n    &quot;old&quot;: null,\\n    &quot;pkNames&quot;: [&quot;client_id&quot;],\\n    &quot;sql&quot;: &quot;&quot;,\\n    &quot;sqlType&quot;: {\\n        &quot;client_id&quot;: 12,\\n        &quot;resource_ids&quot;: 12,\\n        &quot;client_secret&quot;: 12,\\n        &quot;scope&quot;: 12,\\n        &quot;authorized_grant_types&quot;: 12,\\n        &quot;web_server_redirect_uri&quot;: 12,\\n        &quot;authorities&quot;: 12,\\n        &quot;access_token_validity&quot;: 4,\\n        &quot;refresh_token_validity&quot;: 4,\\n        &quot;additional_information&quot;: 12,\\n        &quot;autoapprove&quot;: 12\\n    },\\n    &quot;table&quot;: &quot;oauth_client_details&quot;,\\n    &quot;ts&quot;: 1640337532520,\\n    &quot;type&quot;: &quot;INSERT&quot;\\n}\\n</code></pre>\\n<p>每个字段的意思已经很清楚了，有表名称、方法、参数、参数类型、参数值…..</p>\\n<p><strong>客户端要做的就是监听MQ获取JSON数据，然后将其解析出来，处理自己的业务逻辑。</strong></p>\\n<h2 id=\\\"h2-canal-\\\"><a name=\\\"Canal客户端搭建\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>Canal客户端搭建</h2><p>客户端很简单实现，要做的就是消费Canal服务端传递过来的消息，监听<strong>canal.queue</strong>这个队列。</p>\\n<h3 id=\\\"h3--strong-1-strong-\\\"><a name=\\\"<strong>1、创建消息实体类</strong>\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span><strong>1、创建消息实体类</strong></h3><p>MQ传递过来的是JSON数据，当然要创建个实体类接收数据，如下：</p>\\n<pre><code class=\\\"lang-java\\\">/**\\n * @author 公众号 码猿技术专栏\\n * Canal消息接收实体类\\n */\\n@NoArgsConstructor\\n@Data\\npublic class CanalMessage&lt;T&gt; {\\n    @JsonProperty(&quot;type&quot;)\\n    private String type;\\n\\n    @JsonProperty(&quot;table&quot;)\\n    private String table;\\n\\n    @JsonProperty(&quot;data&quot;)\\n    private List&lt;T&gt; data;\\n\\n    @JsonProperty(&quot;database&quot;)\\n    private String database;\\n\\n    @JsonProperty(&quot;es&quot;)\\n    private Long es;\\n\\n    @JsonProperty(&quot;id&quot;)\\n    private Integer id;\\n\\n    @JsonProperty(&quot;isDdl&quot;)\\n    private Boolean isDdl;\\n\\n    @JsonProperty(&quot;old&quot;)\\n    private List&lt;T&gt; old;\\n\\n    @JsonProperty(&quot;pkNames&quot;)\\n    private List&lt;String&gt; pkNames;\\n\\n    @JsonProperty(&quot;sql&quot;)\\n    private String sql;\\n\\n    @JsonProperty(&quot;ts&quot;)\\n    private Long ts;\\n}\\n</code></pre>\\n<h3 id=\\\"h3--strong-2-mq-strong-\\\"><a name=\\\"<strong>2、MQ消息监听业务</strong>\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span><strong>2、MQ消息监听业务</strong></h3><p>接下来就是监听队列，一旦有Canal服务端有数据推送能够及时的消费。</p>\\n<p>代码很简单，只是给出个接收的案例，具体的业务逻辑可以根据业务实现，如下：</p>\\n<pre><code class=\\\"lang-java\\\">import cn.hutool.json.JSONUtil;\\nimport cn.myjszl.middle.ware.canal.mq.rabbit.model.CanalMessage;\\nimport lombok.RequiredArgsConstructor;\\nimport lombok.extern.slf4j.Slf4j;\\nimport org.springframework.amqp.rabbit.annotation.Exchange;\\nimport org.springframework.amqp.rabbit.annotation.Queue;\\nimport org.springframework.amqp.rabbit.annotation.QueueBinding;\\nimport org.springframework.amqp.rabbit.annotation.RabbitListener;\\nimport org.springframework.stereotype.Component;\\n\\n/**\\n * 监听MQ获取Canal增量的数据消息\\n */\\n@Component\\n@Slf4j\\n@RequiredArgsConstructor\\npublic class CanalRabbitMQListener {\\n\\n    @RabbitListener(bindings = {\\n            @QueueBinding(\\n                    value = @Queue(value = &quot;canal.queue&quot;, durable = &quot;true&quot;),\\n                    exchange = @Exchange(value = &quot;canal.exchange&quot;),\\n                    key = &quot;canal.routing.key&quot;\\n            )\\n    })\\n    public void handleDataChange(String message) {\\n        //将message转换为CanalMessage\\n        CanalMessage canalMessage = JSONUtil.toBean(message, CanalMessage.class);\\n        String tableName = canalMessage.getTable();\\n        log.info(&quot;Canal 监听 {} 发生变化；明细：{}&quot;, tableName, message);\\n        //TODO 业务逻辑自己完善...............\\n    }\\n}\\n</code></pre>\\n<h3 id=\\\"h3--strong-3-strong-\\\"><a name=\\\"<strong>3、测试</strong>\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span><strong>3、测试</strong></h3><p>下面向表中插入数据，看下接收的消息是什么样的，SQL如下：</p>\\n<pre><code class=\\\"lang-sql\\\">INSERT INTO `oauth_client_details`\\nVALUES\\n    ( &#39;myjszl&#39;, &#39;res1&#39;, &#39;$2a$10$F1tQdeb0SEMdtjlO8X/0wO6Gqybu6vPC/Xg8OmP9/TL1i4beXdK9W&#39;, &#39;all&#39;, &#39;password,refresh_token,authorization_code,client_credentials,implicit&#39;, &#39;http://www.baidu.com&#39;, NULL, 1000, 1000, NULL, &#39;false&#39; );\\n</code></pre>\\n<p>客户端转换后的消息如下图：</p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/203.png\\\" alt=\\\"\\\"></p>\\n<p>上图可以看出所有的数据都已经成功接收到，只需要根据数据完善自己的业务逻辑即可。</p>\\n<blockquote>\\n<p>客户端案例源码已经上传GitHub，关注公众号：<strong>码猿技术专栏</strong>，回复关键词：<strong>9530</strong> 获取！</p>\\n</blockquote>\\n<h2 id=\\\"h2-u603Bu7ED3\\\"><a name=\\\"总结\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>总结</h2><p>数据增量同步的开源工具并不只有Canal一种，根据自己的业务需要选择合适的组件。</p>\\n<h2 id=\\\"h2--\\\"><a name=\\\"最后说一句（别白嫖，求关注）\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>最后说一句（别白嫖，求关注）</h2><p>陈某每一篇文章都是精心输出，已经写了<strong>3个专栏</strong>，整理成<strong>PDF</strong>，获取方式如下：</p>\\n<ol>\\n<li><a href=\\\"https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&amp;action=getalbum&amp;album_id=2042874937312346114#wechat_redirect\\\">《Spring Cloud 进阶》</a>PDF：关注公众号：【<strong>码猿技术专栏</strong>】回复关键词 <strong>Spring Cloud 进阶</strong> 获取！</li><li><a href=\\\"https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&amp;action=getalbum&amp;album_id=1532834475389288449#wechat_redirect\\\">《Spring Boot 进阶》</a>PDF：关注公众号：【<strong>码猿技术专栏</strong>】回复关键词 <strong>Spring Boot进阶</strong> 获取！</li><li><a href=\\\"https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&amp;action=getalbum&amp;album_id=1500819225232343046#wechat_redirect\\\">《Mybatis 进阶》</a>PDF：关注公众号：【<strong>码猿技术专栏</strong>】回复关键词 <strong>Mybatis 进阶</strong> 获取！</li></ol>\\n<p>如果这篇文章对你有所帮助，或者有所启发的话，帮忙<strong>点赞</strong>、<strong>在看</strong>、<strong>转发</strong>、<strong>收藏</strong>，你的支持就是我坚持下去的最大动力！</p>\\n<p>关注公众号：<strong>【码猿技术专栏】</strong>，公众号内有超赞的粉丝福利，回复：<strong>加群</strong>，可以加入技术讨论群，和大家一起讨论技术，吹牛逼！</p>\\n\",\"createTime\":1646561921410,\"describe\":\"SpringBoot 整合阿里中间件canal实现无感知增量同步\",\"flag\":1,\"id\":6,\"imgUrl\":\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/199.png\",\"isAppreciate\":1,\"isComment\":1,\"isExplain\":1,\"isRecommend\":1,\"source\":1,\"status\":2,\"title\":\"SpringBoot 整合阿里中间件canal实现无感知增量同步\",\"typeId\":2,\"updateTime\":1646561921410,\"viewNum\":0}', '2022-03-06 18:18:41', '2022-03-06 18:19:39', 2, 'article_exchange', NULL, 'article_key', 2);
INSERT INTO `mq_msg` VALUES (10, '{\"articleId\":\"552918342474661888\",\"authorId\":\"94dd9d02befd4dac9d6e708ff92f7d82\",\"content\":\"<h2 id=\\\"h2--\\\"><a name=\\\"一、前言\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>一、前言</h2><p>核心隐私数据无论对于企业还是用户来说尤其重要，因此要想办法杜绝各种隐私数据的泄漏。下面陈某带大家从以下三个方面讲解一下隐私数据如何脱敏，也是日常开发中需要注意的：</p>\\n<ol>\\n<li>配置文件数据脱敏</li><li>接口返回数据脱敏</li><li>日志文件数据脱敏</li></ol>\\n<p>文章目录如下：</p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F/6.png\\\" alt=\\\"\\\"></p>\\n<h2 id=\\\"h2--\\\"><a name=\\\"二、配置文件如何脱敏？\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>二、配置文件如何脱敏？</h2><p>经常会遇到这样一种情况：项目的配置文件中总有一些敏感信息，比如数据源的url、用户名、密码….这些信息一旦被暴露那么整个数据库都将会被泄漏，那么如何将这些配置隐藏呢？</p>\\n<p>以前都是手动将加密之后的配置写入到配置文件中，提取的时候再手动解密，当然这是一种思路，也能解决问题，但是每次都要手动加密、解密不觉得麻烦吗？</p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F/7.jpg\\\" alt=\\\"\\\"></p>\\n<p>今天介绍一种方案，让你在无感知的情况下实现配置文件的加密、解密。利用一款开源插件：<code>jasypt-spring-boot</code>。项目地址如下：</p>\\n<pre><code class=\\\"lang-java\\\">https://github.com/ulisesbocchio/jasypt-spring-boot\\n</code></pre>\\n<p>使用方法很简单，整合Spring Boot 只需要添加一个<code>starter</code>。</p>\\n<h3 id=\\\"h3-1-\\\"><a name=\\\"1. 添加依赖\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>1. 添加依赖</h3><pre><code class=\\\"lang-xml\\\">&lt;dependency&gt;\\n        &lt;groupId&gt;com.github.ulisesbocchio&lt;/groupId&gt;\\n        &lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt;\\n        &lt;version&gt;3.0.3&lt;/version&gt;\\n&lt;/dependency&gt;\\n</code></pre>\\n<h3 id=\\\"h3-2-\\\"><a name=\\\"2. 配置秘钥\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>2. 配置秘钥</h3><p>在配置文件中添加一个加密的秘钥（任意），如下：</p>\\n<pre><code class=\\\"lang-yaml\\\">jasypt:\\n  encryptor:\\n    password: Y6M9fAJQdU7jNp5MW\\n</code></pre>\\n<p>当然将秘钥直接放在配置文件中也是不安全的，我们可以在项目启动的时候配置秘钥，命令如下：</p>\\n<pre><code class=\\\"lang-shell\\\">java -jar xxx.jar  -Djasypt.encryptor.password=Y6M9fAJQdU7jNp5MW\\n</code></pre>\\n<h3 id=\\\"h3-3-\\\"><a name=\\\"3. 生成加密后的数据\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>3. 生成加密后的数据</h3><p>这一步骤是将配置明文进行加密，代码如下：</p>\\n<pre><code class=\\\"lang-java\\\">@SpringBootTest\\n@RunWith(SpringRunner.class)\\npublic class SpringbootJasyptApplicationTests {\\n\\n    /**\\n     * 注入加密方法\\n     */\\n    @Autowired\\n    private StringEncryptor encryptor;\\n\\n    /**\\n     * 手动生成密文，此处演示了url，user，password\\n     */\\n    @Test\\n    public void encrypt() {\\n        String url = encryptor.encrypt(&quot;jdbc\\\\\\\\:mysql\\\\\\\\://127.0.0.1\\\\\\\\:3306/test?useUnicode\\\\\\\\=true&amp;characterEncoding\\\\\\\\=UTF-8&amp;zeroDateTimeBehavior\\\\\\\\=convertToNull&amp;useSSL\\\\\\\\=false&amp;allowMultiQueries\\\\\\\\=true&amp;serverTimezone=Asia/Shanghai&quot;);\\n        String name = encryptor.encrypt(&quot;root&quot;);\\n        String password = encryptor.encrypt(&quot;123456&quot;);\\n        System.out.println(&quot;database url: &quot; + url);\\n        System.out.println(&quot;database name: &quot; + name);\\n        System.out.println(&quot;database password: &quot; + password);\\n        Assert.assertTrue(url.length() &gt; 0);\\n        Assert.assertTrue(name.length() &gt; 0);\\n        Assert.assertTrue(password.length() &gt; 0);\\n    }\\n}\\n</code></pre>\\n<p>上述代码对数据源的url、user、password进行了明文加密，输出的结果如下：</p>\\n<pre><code class=\\\"lang-properties\\\">database url: szkFDG56WcAOzG2utv0m2aoAvNFH5g3DXz0o6joZjT26Y5WNA+1Z+pQFpyhFBokqOp2jsFtB+P9b3gB601rfas3dSfvS8Bgo3MyP1nojJgVp6gCVi+B/XUs0keXPn+pbX/19HrlUN1LeEweHS/LCRZslhWJCsIXTwZo1PlpXRv3Vyhf2OEzzKLm3mIAYj51CrEaN3w5cMiCESlwvKUhpAJVz/uXQJ1spLUAMuXCKKrXM/6dSRnWyTtdFRost5cChEU9uRjw5M+8HU3BLemtcK0vM8iYDjEi5zDbZtwxD3hA=\\n\\ndatabase name: L8I2RqYPptEtQNL4x8VhRVakSUdlsTGzEND/3TOnVTYPWe0ZnWsW0/5JdUsw9ulm\\n\\ndatabase password: EJYCSbBL8Pmf2HubIH7dHhpfDZcLyJCEGMR9jAV3apJtvFtx9TVdhUPsAxjQ2pnJ\\n</code></pre>\\n<h3 id=\\\"h3-4-\\\"><a name=\\\"4. 将加密后的密文写入配置\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>4. 将加密后的密文写入配置</h3><p><code>jasypt</code>默认使用<code>ENC()</code>包裹，此时的数据源配置如下：</p>\\n<pre><code class=\\\"lang-yaml\\\">spring:\\n  datasource:\\n    #   数据源基本配置\\n    username: ENC(L8I2RqYPptEtQNL4x8VhRVakSUdlsTGzEND/3TOnVTYPWe0ZnWsW0/5JdUsw9ulm)\\n    password: ENC(EJYCSbBL8Pmf2HubIH7dHhpfDZcLyJCEGMR9jAV3apJtvFtx9TVdhUPsAxjQ2pnJ)\\n    driver-class-name: com.mysql.jdbc.Driver\\n    url: ENC(szkFDG56WcAOzG2utv0m2aoAvNFH5g3DXz0o6joZjT26Y5WNA+1Z+pQFpyhFBokqOp2jsFtB+P9b3gB601rfas3dSfvS8Bgo3MyP1nojJgVp6gCVi+B/XUs0keXPn+pbX/19HrlUN1LeEweHS/LCRZslhWJCsIXTwZo1PlpXRv3Vyhf2OEzzKLm3mIAYj51CrEaN3w5cMiCESlwvKUhpAJVz/uXQJ1spLUAMuXCKKrXM/6dSRnWyTtdFRost5cChEU9uRjw5M+8HU3BLemtcK0vM8iYDjEi5zDbZtwxD3hA=)\\n    type: com.alibaba.druid.pool.DruidDataSource\\n</code></pre>\\n<p>上述配置是使用默认的<code>prefix=ENC(</code>、<code>suffix=)</code>，当然我们可以根据自己的要求更改，只需要在配置文件中更改即可，如下：</p>\\n<pre><code class=\\\"lang-yaml\\\">jasypt:\\n  encryptor:\\n    ## 指定前缀、后缀\\n    property:\\n      prefix: &#39;PASS(&#39;\\n      suffix: &#39;)&#39;\\n</code></pre>\\n<p>那么此时的配置就必须使用<code>PASS()</code>包裹才会被解密，如下：</p>\\n<pre><code class=\\\"lang-yaml\\\">spring:\\n  datasource:\\n    #   数据源基本配置\\n    username: PASS(L8I2RqYPptEtQNL4x8VhRVakSUdlsTGzEND/3TOnVTYPWe0ZnWsW0/5JdUsw9ulm)\\n    password: PASS(EJYCSbBL8Pmf2HubIH7dHhpfDZcLyJCEGMR9jAV3apJtvFtx9TVdhUPsAxjQ2pnJ)\\n    driver-class-name: com.mysql.jdbc.Driver\\n    url: PASS(szkFDG56WcAOzG2utv0m2aoAvNFH5g3DXz0o6joZjT26Y5WNA+1Z+pQFpyhFBokqOp2jsFtB+P9b3gB601rfas3dSfvS8Bgo3MyP1nojJgVp6gCVi+B/XUs0keXPn+pbX/19HrlUN1LeEweHS/LCRZslhWJCsIXTwZo1PlpXRv3Vyhf2OEzzKLm3mIAYj51CrEaN3w5cMiCESlwvKUhpAJVz/uXQJ1spLUAMuXCKKrXM/6dSRnWyTtdFRost5cChEU9uRjw5M+8HU3BLemtcK0vM8iYDjEi5zDbZtwxD3hA=)\\n    type: com.alibaba.druid.pool.DruidDataSource\\n</code></pre>\\n<h3 id=\\\"h3-5-\\\"><a name=\\\"5. 总结\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>5. 总结</h3><p>jasypt还有许多高级用法，比如可以自己配置加密算法，具体的操作可以参考Github上的文档。</p>\\n<h2 id=\\\"h2--\\\"><a name=\\\"三、接口返回数据如何脱敏？\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>三、接口返回数据如何脱敏？</h2><p>通常接口返回值中的一些敏感数据也是要脱敏的，比如身份证号、手机号码、地址…..通常的手段就是用<code>*</code>隐藏一部分数据，当然也可以根据自己需求定制。</p>\\n<p>言归正传，如何优雅的实现呢？有两种实现方案，如下：</p>\\n<ul>\\n<li><p>整合Mybatis插件，在查询的时候针对特定的字段进行脱敏</p>\\n</li><li><p>整合Jackson，在序列化阶段对特定字段进行脱敏</p>\\n</li><li><p>基于<code>Sharding Sphere</code>实现数据脱敏，查看之前的文章：<a href=\\\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247493021&amp;idx=2&amp;sn=f27a4eeb6dd3eb5b1551eabf6e31739e&amp;chksm=fcf73a50cb80b3465e6f7cf1fd841bfec098fcde47c587a2c35e7793bad3b33ebe8f2433d3ff&amp;token=1439687168&amp;lang=zh_CN#rd\\\">基于Sharding Sphere实现数据“一键脱敏”</a></p>\\n</li></ul>\\n<p>第一种方案网上很多实现方式，下面演示第二种，整合Jackson。</p>\\n<h3 id=\\\"h3-1-jackson-\\\"><a name=\\\"1. 自定义一个Jackson注解\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>1. 自定义一个Jackson注解</h3><p>需要自定义一个脱敏注解，一旦有属性被标注，则进行对应得脱敏，如下：</p>\\n<pre><code class=\\\"lang-java\\\">/**\\n * 自定义jackson注解，标注在属性上\\n */\\n@Retention(RetentionPolicy.RUNTIME)\\n@Target(ElementType.FIELD)\\n@JacksonAnnotationsInside\\n@JsonSerialize(using = SensitiveJsonSerializer.class)\\npublic @interface Sensitive {\\n    //脱敏策略\\n    SensitiveStrategy strategy();\\n}\\n</code></pre>\\n<h3 id=\\\"h3-2-\\\"><a name=\\\"2. 定制脱敏策略\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>2. 定制脱敏策略</h3><p>针对项目需求，定制不同字段的脱敏规则，比如手机号中间几位用<code>*</code>替代，如下：</p>\\n<pre><code class=\\\"lang-java\\\">/**\\n * 脱敏策略，枚举类，针对不同的数据定制特定的策略\\n */\\npublic enum SensitiveStrategy {\\n    /**\\n     * 用户名\\n     */\\n    USERNAME(s -&gt; s.replaceAll(&quot;(\\\\\\\\S)\\\\\\\\S(\\\\\\\\S*)&quot;, &quot;$1*$2&quot;)),\\n    /**\\n     * 身份证\\n     */\\n    ID_CARD(s -&gt; s.replaceAll(&quot;(\\\\\\\\d{4})\\\\\\\\d{10}(\\\\\\\\w{4})&quot;, &quot;$1****$2&quot;)),\\n    /**\\n     * 手机号\\n     */\\n    PHONE(s -&gt; s.replaceAll(&quot;(\\\\\\\\d{3})\\\\\\\\d{4}(\\\\\\\\d{4})&quot;, &quot;$1****$2&quot;)),\\n    /**\\n     * 地址\\n     */\\n    ADDRESS(s -&gt; s.replaceAll(&quot;(\\\\\\\\S{3})\\\\\\\\S{2}(\\\\\\\\S*)\\\\\\\\S{2}&quot;, &quot;$1****$2****&quot;));\\n\\n\\n    private final Function&lt;String, String&gt; desensitizer;\\n\\n    SensitiveStrategy(Function&lt;String, String&gt; desensitizer) {\\n        this.desensitizer = desensitizer;\\n    }\\n\\n    public Function&lt;String, String&gt; desensitizer() {\\n        return desensitizer;\\n    }\\n}\\n</code></pre>\\n<p>以上只是提供了部分，具体根据自己项目要求进行配置。</p>\\n<h3 id=\\\"h3-3-json-\\\"><a name=\\\"3. 定制JSON序列化实现\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>3. 定制JSON序列化实现</h3><p>下面将是重要实现，对标注注解<code><a href=\\\"https://github.com/Sensitive\\\" title=\\\"&#64;Sensitive\\\" class=\\\"at-link\\\">@Sensitive</a></code>的字段进行脱敏，实现如下：</p>\\n<pre><code class=\\\"lang-java\\\">/**\\n * 序列化注解自定义实现\\n * JsonSerializer&lt;String&gt;：指定String 类型，serialize()方法用于将修改后的数据载入\\n */\\npublic class SensitiveJsonSerializer extends JsonSerializer&lt;String&gt; implements ContextualSerializer {\\n    private SensitiveStrategy strategy;\\n\\n    @Override\\n    public void serialize(String value, JsonGenerator gen, SerializerProvider serializers) throws IOException {\\n        gen.writeString(strategy.desensitizer().apply(value));\\n    }\\n\\n    /**\\n     * 获取属性上的注解属性\\n     */\\n    @Override\\n    public JsonSerializer&lt;?&gt; createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException {\\n\\n        Sensitive annotation = property.getAnnotation(Sensitive.class);\\n        if (Objects.nonNull(annotation)&amp;&amp;Objects.equals(String.class, property.getType().getRawClass())) {\\n            this.strategy = annotation.strategy();\\n            return this;\\n        }\\n        return prov.findValueSerializer(property.getType(), property);\\n\\n    }\\n}\\n</code></pre>\\n<h3 id=\\\"h3-4-person-\\\"><a name=\\\"4. 定义Person类，对其数据脱敏\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>4. 定义Person类，对其数据脱敏</h3><p>使用注解<code><a href=\\\"https://github.com/Sensitive\\\" title=\\\"&#64;Sensitive\\\" class=\\\"at-link\\\">@Sensitive</a></code>注解进行数据脱敏，代码如下：</p>\\n<pre><code class=\\\"lang-java\\\">@Data\\npublic class Person {\\n    /**\\n     * 真实姓名\\n     */\\n    @Sensitive(strategy = SensitiveStrategy.USERNAME)\\n    private String realName;\\n    /**\\n     * 地址\\n     */\\n    @Sensitive(strategy = SensitiveStrategy.ADDRESS)\\n    private String address;\\n    /**\\n     * 电话号码\\n     */\\n    @Sensitive(strategy = SensitiveStrategy.PHONE)\\n    private String phoneNumber;\\n    /**\\n     * 身份证号码\\n     */\\n    @Sensitive(strategy = SensitiveStrategy.ID_CARD)\\n    private String idCard;\\n}\\n</code></pre>\\n<h3 id=\\\"h3-5-\\\"><a name=\\\"5. 模拟接口测试\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>5. 模拟接口测试</h3><p>以上4个步骤完成了数据脱敏的Jackson注解，下面写个controller进行测试，代码如下：</p>\\n<pre><code class=\\\"lang-java\\\">@RestController\\npublic class TestController {\\n    @GetMapping(&quot;/test&quot;)\\n    public Person test(){\\n        Person user = new Person();\\n        user.setRealName(&quot;不才陈某&quot;);\\n        user.setPhoneNumber(&quot;19796328206&quot;);\\n        user.setAddress(&quot;浙江省杭州市温州市....&quot;);\\n        user.setIdCard(&quot;4333333333334334333&quot;);\\n        return user;\\n    }\\n}\\n</code></pre>\\n<p>调用接口查看数据有没有正常脱敏，结果如下：</p>\\n<pre><code class=\\\"lang-json\\\">{\\n    &quot;realName&quot;: &quot;不*陈某&quot;,\\n    &quot;address&quot;: &quot;浙江省****市温州市..****&quot;,\\n    &quot;phoneNumber&quot;: &quot;197****8206&quot;,\\n    &quot;idCard&quot;: &quot;4333****34333&quot;\\n}\\n</code></pre>\\n<h3 id=\\\"h3-6-\\\"><a name=\\\"6. 总结\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>6. 总结</h3><p>数据脱敏有很多种实现方式，关键是哪种更加适合，哪种更加优雅…..</p>\\n<h2 id=\\\"h2--\\\"><a name=\\\"四、日志文件如何数据脱敏？\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>四、日志文件如何数据脱敏？</h2><p>上面讲了配置文件、接口返回值的数据脱敏，现在总该轮到日志脱敏了。项目中总避免不了打印日志，肯定会涉及到一些敏感数据被明文打印出来，那么此时就需要过滤掉这些敏感数据（身份证、号码、用户名…..）。</p>\\n<p>关于Spring Boot 日志方面的问题有不理解的可以看我之前的文章：<a href=\\\"https://mp.weixin.qq.com/s/5hyGi6X6BhfCC5kTEvUyFg\\\">Spring Boot第三弹，一文带你搞懂日志如何配置？</a>、<a href=\\\"https://mp.weixin.qq.com/s/ute0JxWgqPe4VvKMbUQMNw\\\">Spring Boot第二弹，配置文件怎么造？</a>。</p>\\n<p>下面以<strong>log4j2</strong>这款日志为例讲解一下日志如何脱敏，其他日志框架大致思路一样。</p>\\n<h3 id=\\\"h3-1-log4j2-\\\"><a name=\\\"1. 添加log4j2日志依赖\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>1. 添加log4j2日志依赖</h3><p>Spring Boot 默认日志框架是logback，但是我们可以切换到log4j2，依赖如下：</p>\\n<pre><code class=\\\"lang-xml\\\">&lt;dependency&gt;\\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\\n    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\\n    &lt;!-- 去掉springboot默认配置 --&gt;\\n    &lt;exclusions&gt;\\n        &lt;exclusion&gt;\\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\\n            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;\\n        &lt;/exclusion&gt;\\n    &lt;/exclusions&gt;\\n&lt;/dependency&gt;\\n&lt;!--使用log4j2替换 LogBack--&gt;\\n&lt;dependency&gt;\\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\\n    &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;\\n&lt;/dependency&gt;\\n</code></pre>\\n<h3 id=\\\"h3-2-resource-log4j2-xml-\\\"><a name=\\\"2. 在/resource目录下新建log4j2.xml配置\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>2. 在/resource目录下新建log4j2.xml配置</h3><p>log4j2的日志配置很简单，只需要在<code>/resource</code>文件夹下新建一个<code>log4j2.xml</code>配置文件，内容如下图：</p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F/1.png\\\" alt=\\\"\\\"></p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F/2.png\\\" alt=\\\"\\\"></p>\\n<p>关于每个节点如何配置，含义是什么，在我上面的两篇文章中有详细的介绍。</p>\\n<blockquote>\\n<p>上图的配置并没有实现数据脱敏，这是普通的配置，使用的是<strong>PatternLayout</strong></p>\\n</blockquote>\\n<h3 id=\\\"h3-3-patternlayout-\\\"><a name=\\\"3.  自定义PatternLayout实现数据脱敏\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>3.  自定义PatternLayout实现数据脱敏</h3><p><strong>步骤</strong>2中的配置使用的是<code>PatternLayout</code>实现日志的格式，那么我们也可以自定义一个PatternLayout来实现日志的过滤脱敏。</p>\\n<p>PatternLayout的类图继承关系如下：</p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F/3.png\\\" alt=\\\"\\\"></p>\\n<p>从上图中可以清楚的看出来，PatternLayout继承了一个抽象类<code>AbstractStringLayout</code>，因此想要自定义只需要继承这个抽象类即可。</p>\\n<p><strong>1、创建CustomPatternLayout，继承抽象类AbstractStringLayout</strong></p>\\n<p>代码如下：</p>\\n<pre><code class=\\\"lang-java\\\">/**\\n * log4j2 脱敏插件\\n * 继承AbstractStringLayout\\n **/\\n@Plugin(name = &quot;CustomPatternLayout&quot;, category = Node.CATEGORY, elementType = Layout.ELEMENT_TYPE, printObject = true)\\npublic class CustomPatternLayout extends AbstractStringLayout {\\n\\n\\n    public final static Logger logger = LoggerFactory.getLogger(CustomPatternLayout.class);\\n    private PatternLayout patternLayout;\\n\\n\\n    protected CustomPatternLayout(Charset charset, String pattern) {\\n        super(charset);\\n        patternLayout = PatternLayout.newBuilder().withPattern(pattern).build();\\n        initRule();\\n    }\\n\\n    /**\\n     * 要匹配的正则表达式map\\n     */\\n    private static Map&lt;String, Pattern&gt; REG_PATTERN_MAP = new HashMap&lt;&gt;();\\n    private static Map&lt;String, String&gt; KEY_REG_MAP = new HashMap&lt;&gt;();\\n\\n\\n    private void initRule() {\\n        try {\\n            if (MapUtils.isEmpty(Log4j2Rule.regularMap)) {\\n                return;\\n            }\\n            Log4j2Rule.regularMap.forEach((a, b) -&gt; {\\n                if (StringUtils.isNotBlank(a)) {\\n                    Map&lt;String, String&gt; collect = Arrays.stream(a.split(&quot;,&quot;)).collect(Collectors.toMap(c -&gt; c, w -&gt; b, (key1, key2) -&gt; key1));\\n                    KEY_REG_MAP.putAll(collect);\\n                }\\n                Pattern compile = Pattern.compile(b);\\n                REG_PATTERN_MAP.put(b, compile);\\n            });\\n\\n        } catch (Exception e) {\\n            logger.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt; 初始化日志脱敏规则失败 ERROR：{}&quot;, e);\\n        }\\n\\n    }\\n\\n    /**\\n     * 处理日志信息，进行脱敏\\n     * 1.判断配置文件中是否已经配置需要脱敏字段\\n     * 2.判断内容是否有需要脱敏的敏感信息\\n     * 2.1 没有需要脱敏信息直接返回\\n     * 2.2 处理: 身份证 ,姓名,手机号敏感信息\\n     */\\n    public String hideMarkLog(String logStr) {\\n        try {\\n            //1.判断配置文件中是否已经配置需要脱敏字段\\n            if (StringUtils.isBlank(logStr) || MapUtils.isEmpty(KEY_REG_MAP) || MapUtils.isEmpty(REG_PATTERN_MAP)) {\\n                return logStr;\\n            }\\n            //2.判断内容是否有需要脱敏的敏感信息\\n            Set&lt;String&gt; charKeys = KEY_REG_MAP.keySet();\\n            for (String key : charKeys) {\\n                if (logStr.contains(key)) {\\n                    String regExp = KEY_REG_MAP.get(key);\\n                    logStr = matchingAndEncrypt(logStr, regExp, key);\\n                }\\n            }\\n            return logStr;\\n        } catch (Exception e) {\\n            logger.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 脱敏处理异常 ERROR:{}&quot;, e);\\n            //如果抛出异常为了不影响流程，直接返回原信息\\n            return logStr;\\n        }\\n    }\\n\\n    /**\\n     * 正则匹配对应的对象。\\n     *\\n     * @param msg\\n     * @param regExp\\n     * @return\\n     */\\n    private static String matchingAndEncrypt(String msg, String regExp, String key) {\\n        Pattern pattern = REG_PATTERN_MAP.get(regExp);\\n        if (pattern == null) {\\n            logger.info(&quot;&gt;&gt;&gt; logger 没有匹配到对应的正则表达式 &quot;);\\n            return msg;\\n        }\\n        Matcher matcher = pattern.matcher(msg);\\n        int length = key.length() + 5;\\n        boolean contains = Log4j2Rule.USER_NAME_STR.contains(key);\\n        String hiddenStr = &quot;&quot;;\\n        while (matcher.find()) {\\n            String originStr = matcher.group();\\n            if (contains) {\\n                // 计算关键词和需要脱敏词的距离小于5。\\n                int i = msg.indexOf(originStr);\\n                if (i &lt; 0) {\\n                    continue;\\n                }\\n                int span = i - length;\\n                int startIndex = span &gt;= 0 ? span : 0;\\n                String substring = msg.substring(startIndex, i);\\n                if (StringUtils.isBlank(substring) ||  !substring.contains(key)) {\\n                    continue;\\n                }\\n                hiddenStr = hideMarkStr(originStr);\\n                msg = msg.replace(originStr, hiddenStr);\\n            } else {\\n                hiddenStr = hideMarkStr(originStr);\\n                msg = msg.replace(originStr, hiddenStr);\\n            }\\n\\n        }\\n        return msg;\\n    }\\n\\n    /**\\n     * 标记敏感文字规则\\n     *\\n     * @param needHideMark\\n     * @return\\n     */\\n    private static String hideMarkStr(String needHideMark) {\\n        if (StringUtils.isBlank(needHideMark)) {\\n            return &quot;&quot;;\\n        }\\n        int startSize = 0, endSize = 0, mark = 0, length = needHideMark.length();\\n\\n        StringBuffer hideRegBuffer = new StringBuffer(&quot;(\\\\\\\\S{&quot;);\\n        StringBuffer replaceSb = new StringBuffer(&quot;$1&quot;);\\n\\n        if (length &gt; 4) {\\n            int i = length / 3;\\n            startSize = i;\\n            endSize = i;\\n        } else {\\n            startSize = 1;\\n            endSize = 0;\\n        }\\n\\n        mark = length - startSize - endSize;\\n        for (int i = 0; i &lt; mark; i++) {\\n            replaceSb.append(&quot;*&quot;);\\n        }\\n        hideRegBuffer.append(startSize).append(&quot;})\\\\\\\\S*(\\\\\\\\S{&quot;).append(endSize).append(&quot;})&quot;);\\n        replaceSb.append(&quot;$2&quot;);\\n        needHideMark = needHideMark.replaceAll(hideRegBuffer.toString(), replaceSb.toString());\\n        return needHideMark;\\n    }\\n\\n\\n    /**\\n     * 创建插件\\n     */\\n    @PluginFactory\\n    public static Layout createLayout(@PluginAttribute(value = &quot;pattern&quot;) final String pattern,\\n                                      @PluginAttribute(value = &quot;charset&quot;) final Charset charset) {\\n        return new CustomPatternLayout(charset, pattern);\\n    }\\n\\n\\n    @Override\\n    public String toSerializable(LogEvent event) {\\n        return hideMarkLog(patternLayout.toSerializable(event));\\n    }\\n\\n}\\n</code></pre>\\n<p>关于其中的一些细节，比如<code><a href=\\\"https://github.com/Plugin\\\" title=\\\"&#64;Plugin\\\" class=\\\"at-link\\\">@Plugin</a></code>、<code><a href=\\\"https://github.com/PluginFactory\\\" title=\\\"&#64;PluginFactory\\\" class=\\\"at-link\\\">@PluginFactory</a></code>这两个注解什么意思？log4j2如何实现自定义一个插件，这里不再详细介绍，不是本文重点，有兴趣的可以查看<code>log4j2</code>的官方文档。</p>\\n<p><strong>2、自定义自己的脱敏规则</strong></p>\\n<p>上述代码中的<code>Log4j2Rule</code>则是脱敏规则静态类，我这里是直接放在了静态类中配置，实际项目中可以设置到配置文件中，代码如下：</p>\\n<pre><code class=\\\"lang-java\\\">/**\\n * 现在拦截加密的日志有三类:\\n * 1，身份证\\n * 2，姓名\\n * 3，身份证号\\n * 加密的规则后续可以优化在配置文件中\\n **/\\npublic class Log4j2Rule {\\n\\n    /**\\n     * 正则匹配 关键词 类别\\n     */\\n    public static Map&lt;String, String&gt; regularMap = new HashMap&lt;&gt;();\\n    /**\\n     * TODO  可配置\\n     * 此项可以后期放在配置项中\\n     */\\n    public static final String USER_NAME_STR = &quot;Name,name,联系人,姓名&quot;;\\n    public static final String USER_IDCARD_STR = &quot;empCard,idCard,身份证,证件号&quot;;\\n    public static final String USER_PHONE_STR = &quot;mobile,Phone,phone,电话,手机&quot;;\\n\\n    /**\\n     * 正则匹配，自己根据业务要求自定义\\n     */\\n    private static String IDCARD_REGEXP = &quot;(\\\\\\\\d{17}[0-9Xx]|\\\\\\\\d{14}[0-9Xx])&quot;;\\n    private static String USERNAME_REGEXP = &quot;[\\\\\\\\u4e00-\\\\\\\\u9fa5]{2,4}&quot;;\\n    private static String PHONE_REGEXP = &quot;(?&lt;!\\\\\\\\d)(?:(?:1[3456789]\\\\\\\\d{9})|(?:861[356789]\\\\\\\\d{9}))(?!\\\\\\\\d)&quot;;\\n\\n    static {\\n        regularMap.put(USER_NAME_STR, USERNAME_REGEXP);\\n        regularMap.put(USER_IDCARD_STR, IDCARD_REGEXP);\\n        regularMap.put(USER_PHONE_STR, PHONE_REGEXP);\\n    }\\n\\n}\\n</code></pre>\\n<p>经过上述两个步骤，自定义的<code>PatternLayout</code>已经完成，下面将是改写<code>log4j2.xml</code>这个配置文件了。</p>\\n<h3 id=\\\"h3-4-log4j2-xml-\\\"><a name=\\\"4. 修改log4j2.xml配置文件\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>4. 修改log4j2.xml配置文件</h3><p>其实这里修改很简单，原配置文件是直接使用<code>PatternLayout</code>进行日志格式化的，那么只需要将默认的<code>&lt;PatternLayout/&gt;</code>这个节点替换成<code>&lt;CustomPatternLayout/&gt;</code>，如下图：</p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F/4.png\\\" alt=\\\"\\\"></p>\\n<p>直接全局替换掉即可，至此，这个配置文件就修改完成了。</p>\\n<h3 id=\\\"h3-5-\\\"><a name=\\\"5. 演示效果\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>5. 演示效果</h3><p>在<strong>步骤3</strong>这边自定义了脱敏规则静态类<code>Log4j2Rule</code>，其中定义了姓名、身份证、号码这三个脱敏规则，如下：</p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F/5.png\\\" alt=\\\"\\\"></p>\\n<p>下面就来演示这三个规则能否正确脱敏，直接使用日志打印，代码如下：</p>\\n<pre><code class=\\\"lang-java\\\">@Test\\npublic void test3(){\\n    log.debug(&quot;身份证：{}，姓名：{}，电话：{}&quot;,&quot;320829112334566767&quot;,&quot;不才陈某&quot;,&quot;19896327106&quot;);\\n}\\n</code></pre>\\n<p>控制台打印的日志如下：</p>\\n<pre><code class=\\\"lang-java\\\">身份证：320829******566767，姓名：不***，电话：198*****106\\n</code></pre>\\n<p>哦豁，成功了，so easy！！！</p>\\n<h3 id=\\\"h3-6-\\\"><a name=\\\"6. 总结\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>6. 总结</h3><p>日志脱敏的方案很多，陈某也只是介绍一种常用的，有兴趣的可以研究一下。</p>\\n<h2 id=\\\"h2--\\\"><a name=\\\"五、总结\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>五、总结</h2><p>本篇文章从三个维度介绍了隐私数据的脱敏实现方案，码字不易，赶紧点赞收藏吧！！！</p>\\n<blockquote>\\n<p>源码已经上传GitHub，需要的公众号码猿技术专栏，回复关键词<code>数据脱敏</code>获取。</p>\\n</blockquote>\\n\",\"createTime\":1646562005572,\"describe\":\"Springboot 日志、配置文件、接口数据如何脱敏？老鸟们都是这样玩的！\",\"flag\":1,\"id\":7,\"imgUrl\":\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F/7.jpg\",\"isAppreciate\":1,\"isComment\":1,\"isExplain\":1,\"isRecommend\":1,\"source\":1,\"status\":2,\"title\":\"Springboot 日志、配置文件、接口数据如何脱敏？老鸟们都是这样玩的！\",\"typeId\":2,\"updateTime\":1646562005572,\"viewNum\":0}', '2022-03-06 18:20:06', '2022-03-06 18:21:03', 2, 'article_exchange', NULL, 'article_key', 2);
INSERT INTO `mq_msg` VALUES (11, '{\"articleId\":\"552955219609124864\",\"authorId\":\"94dd9d02befd4dac9d6e708ff92f7d82\",\"content\":\"<h2 id=\\\"h2--\\\"><a name=\\\"持续原创输出，点击上方蓝字关注我\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>持续原创输出，点击上方蓝字关注我</h2><p><img src=\\\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%BC%B9%EF%BC%8CSpring%20Boot%E6%95%B4%E5%90%88%E5%A4%9A%E7%82%B9%E5%A5%97%E8%B7%AF%EF%BC%8C%E5%B0%91%E8%B5%B0%E5%BC%AF%E8%B7%AF%EF%BC%81%EF%BC%81%EF%BC%81/1.jpg\\\" alt=\\\"\\\"></p>\\n<blockquote>\\n<p>个人原创博客+1，<a href=\\\"https://chenjiabing666.github.io/\\\">点击前往，查看更多</a></p>\\n</blockquote>\\n<h2 id=\\\"h2-u76EEu5F55\\\"><a name=\\\"目录\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>目录</h2><ul>\\n<li>前言</li><li>Spring Boot 版本</li><li><ol>\\n<li>找到自动配置类</li></ol>\\n</li><li><ol>\\n<li>注意<code><a href=\\\"https://github.com/Conditionalxxx\\\" title=\\\"&#64;Conditionalxxx\\\" class=\\\"at-link\\\"><a href=\\\"https://github.com/Conditionalxxx\\\" title=\\\"&#64;Conditionalxxx\\\" class=\\\"at-link\\\">@Conditionalxxx</a></a></code>注解</li></ol>\\n</li><li><ol>\\n<li>注意<code>EnableConfigurationProperties</code>注解</li></ol>\\n</li><li><ol>\\n<li>注意<code><a href=\\\"https://github.com/Import\\\" title=\\\"&#64;Import\\\" class=\\\"at-link\\\"><a href=\\\"https://github.com/Import\\\" title=\\\"&#64;Import\\\" class=\\\"at-link\\\">@Import</a></a></code>注解</li></ol>\\n</li><li><ol>\\n<li>注意<code><a href=\\\"https://github.com/AutoConfigurexxx\\\" title=\\\"&#64;AutoConfigurexxx\\\" class=\\\"at-link\\\"><a href=\\\"https://github.com/AutoConfigurexxx\\\" title=\\\"&#64;AutoConfigurexxx\\\" class=\\\"at-link\\\">@AutoConfigurexxx</a></a></code>注解</li></ol>\\n</li><li><ol>\\n<li>注意内部静态配置类</li></ol>\\n</li><li>总结</li></ul>\\n<h2 id=\\\"h2-u524Du8A00\\\"><a name=\\\"前言\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>前言</h2><p>网上有很多文章都在说<code>Spring Boot 如何整合 xxx</code>，有文章教你为什么这么整合吗？整合了千万个框架，其实套路就那么几个，干嘛要学千万个，不如来这学习几个套路轻松整合，它不香吗？？？</p>\\n<p>今天写这篇文章的目的就是想从思想上教给大家几个套路，不用提到整合什么就去百度了，自己尝试去亲手整合一个。</p>\\n<h2 id=\\\"h2-spring-boot-\\\"><a name=\\\"Spring Boot 版本\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>Spring Boot 版本</h2><p>本文基于的Spring Boot的版本是<code>2.3.4.RELEASE</code>。</p>\\n<h2 id=\\\"h2-1-\\\"><a name=\\\"1. 找到自动配置类\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>1. 找到自动配置类</h2><p>Spring Boot 在整合任何一个组件的时候都会先添加一个依赖<code>starter</code>，比如整合的Mybatis有一个<code>mybatis-spring-boot-starter</code>，依赖如下：</p>\\n<pre><code class=\\\"lang-xml\\\">&lt;dependency&gt;\\n         &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;\\n         &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;\\n        &lt;version&gt;2.0.0&lt;/version&gt;\\n&lt;/dependency&gt;\\n</code></pre>\\n<p>每一个<code>starter</code>基本都会有一个自动配置类，命名方式也是类似的，格式为：<code>xxxAutoConfiguration</code>，比如Mybatis的自动配置类就是<code>MybatisAutoConfiguration</code>，<code>Redis</code>的自动配置类是<code>RedisAutoConfiguration</code>，<code>WEB</code>模块的自动配置类是<code>WebMvcAutoConfiguration</code>。</p>\\n<h2 id=\\\"h2-2-conditionalxxx-\\\"><a name=\\\"2. 注意@Conditionalxxx注解\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>2. 注意<a href=\\\"https://github.com/Conditionalxxx\\\" title=\\\"&#64;Conditionalxxx\\\" class=\\\"at-link\\\">@Conditionalxxx</a>注解</h2><p><code><a href=\\\"https://github.com/Conditionalxxx\\\" title=\\\"&#64;Conditionalxxx\\\" class=\\\"at-link\\\">@Conditionalxxx</a></code>标注在配置类上或者结合<code><a href=\\\"https://github.com/Bean\\\" title=\\\"&#64;Bean\\\" class=\\\"at-link\\\">@Bean</a></code>标注在方法上，究竟是什么意思，在上一篇文章<a href=\\\"https://mp.weixin.qq.com/s/BoujdCIHPK79jT9RKAmyug\\\">这类注解都不知道，还好意思说会Spring Boot</a>已经从表层到底层深入的讲了一遍，不理解的可以查阅一下。</p>\\n<blockquote>\\n<p>首先需要注意自动配置类上的<code><a href=\\\"https://github.com/Conditionalxxx\\\" title=\\\"&#64;Conditionalxxx\\\" class=\\\"at-link\\\">@Conditionalxxx</a></code>注解，这个是自动配置类生效的条件。</p>\\n</blockquote>\\n<p>比如<code>WebMvcAutoConfiguration</code>类上标了一个如下注解：</p>\\n<pre><code class=\\\"lang-java\\\">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)\\n</code></pre>\\n<p>以上这行代码的意思就是当前IOC容器中没有<code>WebMvcConfigurationSupport</code>这个类的实例时自动配置类才会生效，这也就是在配置类上标注<code><a href=\\\"https://github.com/EnableWebMvc\\\" title=\\\"&#64;EnableWebMvc\\\" class=\\\"at-link\\\">@EnableWebMvc</a></code>会导致自动配置类<code>WebMvcAutoConfiguration</code>失效的原因。</p>\\n<blockquote>\\n<p>其次需要注意方法上的<code><a href=\\\"https://github.com/Conditionalxxx\\\" title=\\\"&#64;Conditionalxxx\\\" class=\\\"at-link\\\">@Conditionalxxx</a></code>注解，Spring Boot会在自动配置类中结合<code><a href=\\\"https://github.com/Bean\\\" title=\\\"&#64;Bean\\\" class=\\\"at-link\\\">@Bean</a></code>和<code><a href=\\\"https://github.com/Conditionalxxx\\\" title=\\\"&#64;Conditionalxxx\\\" class=\\\"at-link\\\">@Conditionalxxx</a></code>注解提供一些组件运行的默认配置，但是利用<code><a href=\\\"https://github.com/Conditionalxxx\\\" title=\\\"&#64;Conditionalxxx\\\" class=\\\"at-link\\\">@Conditionalxxx</a></code>（在特定条件下生效）注解的<code>条件性</code>，方便开发者覆盖这些配置。</p>\\n</blockquote>\\n<p>比如在Mybatis的自动配置类<code>MybatisAutoConfiguration</code>中有如下一个方法：</p>\\n<pre><code class=\\\"lang-java\\\">  @Bean\\n  @ConditionalOnMissingBean\\n  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {}\\n</code></pre>\\n<p>以上这个方法不用看方法体的内容，只看方法上的注解。<code><a href=\\\"https://github.com/Bean\\\" title=\\\"&#64;Bean\\\" class=\\\"at-link\\\">@Bean</a></code>这个注解的意思是注入一个<code>Bean</code>到<code>IOC容器</code>中，<code><a href=\\\"https://github.com/ConditionalOnMissingBean\\\" title=\\\"&#64;ConditionalOnMissingBean\\\" class=\\\"at-link\\\">@ConditionalOnMissingBean</a></code>这个注解就是一个条件判断了，表示当<code>SqlSessionFactory</code>类型的对象在<code>IOC容器</code>中不存在才会注入。</p>\\n<p>哦？领悟到了吧，<strong>言外之意就是如果开发者需要定制<code>SqlSessionFactory</code>，则可以自己的创建一个<code>SqlSessionFactory</code>类型的对象并且注入到IOC容器中即能覆盖自动配置类中的</strong>。比如在Mybatis配置多数据源的时候就需要定制一个<code>SqlSessionFactory</code>而不是使用自动配置类中的。</p>\\n<blockquote>\\n<p>总之，一定要注意自动配置类上或者方法上的<code><a href=\\\"https://github.com/Conditionalxxx\\\" title=\\\"&#64;Conditionalxxx\\\" class=\\\"at-link\\\">@Conditionalxxx</a></code>注解，这个注解表示某种特定条件。</p>\\n</blockquote>\\n<p>下面列出了常用的几种注解，如下：</p>\\n<ol>\\n<li><code><a href=\\\"https://github.com/ConditionalOnBean\\\" title=\\\"&#64;ConditionalOnBean\\\" class=\\\"at-link\\\">@ConditionalOnBean</a></code>：当容器中有指定Bean的条件下进行实例化。</li><li><code><a href=\\\"https://github.com/ConditionalOnMissingBean\\\" title=\\\"&#64;ConditionalOnMissingBean\\\" class=\\\"at-link\\\">@ConditionalOnMissingBean</a></code>：当容器里没有指定Bean的条件下进行实例化。</li><li><code><a href=\\\"https://github.com/ConditionalOnClass\\\" title=\\\"&#64;ConditionalOnClass\\\" class=\\\"at-link\\\">@ConditionalOnClass</a></code>：当classpath类路径下有指定类的条件下进行实例化。</li><li><code><a href=\\\"https://github.com/ConditionalOnMissingClass\\\" title=\\\"&#64;ConditionalOnMissingClass\\\" class=\\\"at-link\\\">@ConditionalOnMissingClass</a></code>：当类路径下没有指定类的条件下进行实例化。</li><li><code><a href=\\\"https://github.com/ConditionalOnWebApplication\\\" title=\\\"&#64;ConditionalOnWebApplication\\\" class=\\\"at-link\\\">@ConditionalOnWebApplication</a></code>：当项目是一个Web项目时进行实例化。</li><li><code><a href=\\\"https://github.com/ConditionalOnNotWebApplication\\\" title=\\\"&#64;ConditionalOnNotWebApplication\\\" class=\\\"at-link\\\">@ConditionalOnNotWebApplication</a></code>：当项目不是一个Web项目时进行实例化。</li><li><code><a href=\\\"https://github.com/ConditionalOnProperty\\\" title=\\\"&#64;ConditionalOnProperty\\\" class=\\\"at-link\\\">@ConditionalOnProperty</a></code>：当指定的属性有指定的值时进行实例化。</li><li><code><a href=\\\"https://github.com/ConditionalOnExpression\\\" title=\\\"&#64;ConditionalOnExpression\\\" class=\\\"at-link\\\">@ConditionalOnExpression</a></code>：基于SpEL表达式的条件判断。</li><li><code><a href=\\\"https://github.com/ConditionalOnJava\\\" title=\\\"&#64;ConditionalOnJava\\\" class=\\\"at-link\\\">@ConditionalOnJava</a></code>：当JVM版本为指定的版本范围时触发实例化。</li><li><code><a href=\\\"https://github.com/ConditionalOnResource\\\" title=\\\"&#64;ConditionalOnResource\\\" class=\\\"at-link\\\">@ConditionalOnResource</a></code>：当类路径下有指定的资源时触发实例化。</li><li><code><a href=\\\"https://github.com/ConditionalOnJndi\\\" title=\\\"&#64;ConditionalOnJndi\\\" class=\\\"at-link\\\">@ConditionalOnJndi</a></code>：在JNDI存在的条件下触发实例化。</li><li><code><a href=\\\"https://github.com/ConditionalOnSingleCandidate\\\" title=\\\"&#64;ConditionalOnSingleCandidate\\\" class=\\\"at-link\\\">@ConditionalOnSingleCandidate</a></code>：当指定的Bean在容器中只有一个，或者有多个但是指定了首选的Bean时触发实例化。</li></ol>\\n<h2 id=\\\"h2-3-enableconfigurationproperties-\\\"><a name=\\\"3. 注意EnableConfigurationProperties注解\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>3. 注意EnableConfigurationProperties注解</h2><p><code>EnableConfigurationProperties</code>这个注解常标注在配置类上，使得<code><a href=\\\"https://github.com/ConfigurationProperties\\\" title=\\\"&#64;ConfigurationProperties\\\" class=\\\"at-link\\\">@ConfigurationProperties</a></code>标注的配置文件生效，这样就可以在全局配置文件（<code>application.xxx</code>）配置指定前缀的属性了。</p>\\n<p>在Redis的自动配置类<code>RedisAutoConfiguration</code>上方标注如下一行代码：</p>\\n<pre><code class=\\\"lang-java\\\">@EnableConfigurationProperties(RedisProperties.class)\\n</code></pre>\\n<p>这行代码有意思了，我们可以看看<code>RedisProperties</code>的源码，如下：</p>\\n<pre><code class=\\\"lang-java\\\">@ConfigurationProperties(prefix = &quot;spring.redis&quot;)\\npublic class RedisProperties {\\n    private int database = 0;\\n    private String url;\\n    private String host = &quot;localhost&quot;;\\n    private String password;\\n  .....\\n</code></pre>\\n<p><code><a href=\\\"https://github.com/ConfigurationProperties\\\" title=\\\"&#64;ConfigurationProperties\\\" class=\\\"at-link\\\">@ConfigurationProperties</a></code>这个注解指定了全局配置文件中以<code>spring.redis.xxx</code>为前缀的配置都会映射到<code>RedisProperties</code>的指定属性中，其实<code>RedisProperties</code>这个类中定义了Redis的一些所需属性，比如<code>host</code>，<code>IP地址</code>，<code>密码</code>等等。</p>\\n<p><strong><code><a href=\\\"https://github.com/EnableConfigurationProperties\\\" title=\\\"&#64;EnableConfigurationProperties\\\" class=\\\"at-link\\\">@EnableConfigurationProperties</a></code>注解就是使得指定的配置生效，能够将全局配置文件中配置的属性映射到相关类的属性中。</strong></p>\\n<p><strong>为什么要注意<code><a href=\\\"https://github.com/EnableConfigurationProperties\\\" title=\\\"&#64;EnableConfigurationProperties\\\" class=\\\"at-link\\\">@EnableConfigurationProperties</a></code>这个注解呢？</strong></p>\\n<blockquote>\\n<p>引入一个组件后往往需要改些配置，我们都知道在全局配置文件中可以修改，但是不知道前缀是什么，可以改哪些属性，因此找到<code><a href=\\\"https://github.com/EnableConfigurationProperties\\\" title=\\\"&#64;EnableConfigurationProperties\\\" class=\\\"at-link\\\">@EnableConfigurationProperties</a></code>这个注解后就能找到对应的配置前缀以及可以修改的属性了。</p>\\n</blockquote>\\n<h2 id=\\\"h2-4-import-\\\"><a name=\\\"4. 注意@Import注解\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>4. 注意<a href=\\\"https://github.com/Import\\\" title=\\\"&#64;Import\\\" class=\\\"at-link\\\">@Import</a>注解</h2><p>这个注解有点牛逼了，<code>Spring 3.x</code>中就已经有的一个注解，大致的意思的就是快速导入一个Bean或者配置类到IOC容器中。这个注解有很多妙用，后续会单独写篇文章介绍下。</p>\\n<blockquote>\\n<p><code><a href=\\\"https://github.com/Import\\\" title=\\\"&#64;Import\\\" class=\\\"at-link\\\">@Import</a></code>这个注解通常标注在自动配置类上方，并且一般都是导入一个或者多个配置类。</p>\\n</blockquote>\\n<p>比如<code>RabbitMQ</code>的自动配置类<code>RabbitAutoConfiguration</code>上有如下一行代码：</p>\\n<pre><code class=\\\"lang-java\\\">@Import(RabbitAnnotationDrivenConfiguration.class)\\n</code></pre>\\n<p>这行代码的作用就是添加了<code>RabbitAnnotationDrivenConfiguration</code>这个配置类，使得Spring Boot在加载到自动配置类的时候能够一起加载。</p>\\n<p>比如Redis的自动配置类<code>RedisAutoConfiguration</code>上有如下一行代码：</p>\\n<pre><code class=\\\"lang-java\\\">@Import({ LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class })\\n</code></pre>\\n<p>这个<code><a href=\\\"https://github.com/Import\\\" title=\\\"&#64;Import\\\" class=\\\"at-link\\\">@Import</a></code>同时引入了<code>Lettuce</code>和<code>Jedis</code>两个配置类了，因此如果你的Redis需要使用Jedis作为连接池的话，想要知道Jedis都要配置什么，此时就应该看看<code>JedisConnectionConfiguration</code>这个配置类了。</p>\\n<blockquote>\\n<p><strong>总结</strong>：<code><a href=\\\"https://github.com/Import\\\" title=\\\"&#64;Import\\\" class=\\\"at-link\\\">@Import</a></code>标注在自动配置类上方，一般都是快速导入一个或者多个配置类，因此如果自动配置类没有配置一些东西时，一定要看看<code><a href=\\\"https://github.com/Import\\\" title=\\\"&#64;Import\\\" class=\\\"at-link\\\">@Import</a></code>这个注解导入的配置类。</p>\\n</blockquote>\\n<h2 id=\\\"h2-5-autoconfigurexxx-\\\"><a name=\\\"5. 注意@AutoConfigurexxx注解\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>5. 注意<a href=\\\"https://github.com/AutoConfigurexxx\\\" title=\\\"&#64;AutoConfigurexxx\\\" class=\\\"at-link\\\">@AutoConfigurexxx</a>注解</h2><p><code><a href=\\\"https://github.com/AutoConfigurexxx\\\" title=\\\"&#64;AutoConfigurexxx\\\" class=\\\"at-link\\\">@AutoConfigurexxx</a></code>这类注解决定了自动配置类的加载顺序，比如<code>AutoConfigureAfter</code>（在指定自动配置类之后）、<code>AutoConfigureBefore</code>（在指定自动配置类之前）、<code>AutoConfigureOrder</code>（指定自动配置类的优先级）。</p>\\n<blockquote>\\n<p>为什么要注意顺序呢？因为某些组件往往之间是相互依赖的，比如<code>Mybatis</code>和<code>DataSource</code>，肯定要先将数据源相关的东西配置成功才能配置<code>Mybatis</code>吧。<code><a href=\\\"https://github.com/AutoConfigurexxx\\\" title=\\\"&#64;AutoConfigurexxx\\\" class=\\\"at-link\\\">@AutoConfigurexxx</a></code>这类注解正是解决了组件之间相互依赖的问题。</p>\\n</blockquote>\\n<p>比如<code>MybatisAutoConfiguration</code>上方标注了如下一行代码：</p>\\n<pre><code class=\\\"lang-java\\\">@AutoConfigureAfter(DataSourceAutoConfiguration.class)\\n</code></pre>\\n<p>这个行代码意思很简单，就是<code>MybatisAutoConfiguration</code>这个自动配置在<code>DataSourceAutoConfiguration</code>这个之后加载，因为你需要我，多么简单的理由。</p>\\n<p>好了，这下明白了吧，以后别犯傻问：<strong>为什么Mybatis配置好了，启动会报错</strong>？这个问题先看看数据源有没有配置成功吧。</p>\\n<h2 id=\\\"h2-6-\\\"><a name=\\\"6. 注意内部静态配置类\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>6. 注意内部静态配置类</h2><p>有些自动配置类比较简单没那么多套路，比如<code>RedisAutoConfiguration</code>这个自动配置类中就定义了两个注入Bean的方法，其他的没了。</p>\\n<p>但是有些自动配置类就没那么单纯了，中间能嵌套<code>n</code>个静态配置类，比如<code>WebMvcAutoConfiguration</code>，类中还嵌套了<code>WebMvcAutoConfigurationAdapter</code>、<code>EnableWebMvcConfiguration</code>、<code>ResourceChainCustomizerConfiguration</code>这三个配置类。如果你光看<code>WebMvcAutoConfiguration</code>这个自动配置类好像没配置什么，但是其内部却是大有乾坤啊。</p>\\n<blockquote>\\n<p><strong>总结</strong>：一定要自动配置类的内部嵌套的配置类，真是大有乾坤啊。</p>\\n</blockquote>\\n<h2 id=\\\"h2-u603Bu7ED3\\\"><a name=\\\"总结\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>总结</h2><p>以上总结了六条整合的套路，希望能够帮助读者摆脱百度，自己也能独立整合组件。</p>\\n<p>总之，Spring Boot整合xxx组件的文章很多，相信大家也看的比较懵，其实套路都是一样，学会陈某分享的套路，让你少走弯路！！！</p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png\\\" alt=\\\"\\\"></p>\\n\",\"createTime\":1646570797765,\"describe\":\"Spring Boot 第 十二弹，Spring Boot整合多点套路，少走点弯路！！！\",\"flag\":1,\"id\":8,\"imgUrl\":\"https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%BC%98%E8%B4%A8%E8%A7%86%E9%A2%91%E8%B5%84%E6%BA%90/1.png\",\"isAppreciate\":1,\"isComment\":1,\"isExplain\":1,\"isRecommend\":1,\"source\":1,\"status\":2,\"title\":\"Spring Boot 第 十二弹，Spring Boot整合多点套路，少走点弯路！！！\",\"typeId\":2,\"updateTime\":1646570797765,\"viewNum\":0}', '2022-03-06 20:46:38', '2022-03-06 20:47:35', 2, 'article_exchange', NULL, 'article_key', 2);
INSERT INTO `mq_msg` VALUES (12, '{\"articleId\":\"552955376010526720\",\"authorId\":\"94dd9d02befd4dac9d6e708ff92f7d82\",\"content\":\"<h2 id=\\\"h2--\\\"><a name=\\\"持续原创输出，点击上方蓝字关注我吧\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>持续原创输出，点击上方蓝字关注我吧</h2><p><img src=\\\"https://gitee.com/chenjiabing666/Blog-file/raw/master/springBoot%E7%AC%AC%E4%BA%8C%E5%BC%B9%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%80%8E%E4%B9%88%E9%80%A0%EF%BC%9F/1.jpeg\\\" alt=\\\"\\\"></p>\\n<h2 id=\\\"h2-u76EEu5F55\\\"><a name=\\\"目录\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>目录</h2><ul>\\n<li>前言</li><li>properties格式简介</li><li>YML格式简介<ul>\\n<li>如何使用</li><li>总结</li></ul>\\n</li><li>如何从配置文件取值？<ul>\\n<li><a href=\\\"https://github.com/ConfigurationProperties\\\" title=\\\"&#64;ConfigurationProperties\\\" class=\\\"at-link\\\"><a href=\\\"https://github.com/ConfigurationProperties\\\" title=\\\"&#64;ConfigurationProperties\\\" class=\\\"at-link\\\">@ConfigurationProperties</a></a></li><li><a href=\\\"https://github.com/Value\\\" title=\\\"&#64;Value\\\" class=\\\"at-link\\\"><a href=\\\"https://github.com/Value\\\" title=\\\"&#64;Value\\\" class=\\\"at-link\\\">@Value</a></a></li></ul>\\n</li><li>如何从自定义配置文件中取值？</li></ul>\\n<h2 id=\\\"h2-u524Du8A00\\\"><a name=\\\"前言\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>前言</h2><p>自从用了Spring Boot，个人最喜欢的就是Spring Boot的配置文件了，和Spring比起，Spring Boot更加灵活，修改的某些配置也是更加得心应手。</p>\\n<p>Spring Boot 官方提供了两种常用的配置文件格式，分别是<code>properties</code>、<code>YML</code>格式。相比于<code>properties</code>来说，<code>YML</code>更加年轻，层级也是更加分明。</p>\\n<p>今天这篇文章就来介绍一下Spring Boot的配置文件的语法以及如何从配置文件中取值。</p>\\n<h2 id=\\\"h2-properties-\\\"><a name=\\\"properties格式简介\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>properties格式简介</h2><p>常见的一种配置文件格式，Spring中也是用这种格式，语法结构很简单，结构为：<code>key=value</code>。具体如下：</p>\\n<pre><code class=\\\"lang-properties\\\">userinfo.name=myjszl\\nuserinfo.age=25\\nuserinfo.active=true\\nuserinfo.created-date=2018/03/31 16:54:30\\nuserinfo.map.k1=v1\\nuserinfo.map.k2=v2\\n</code></pre>\\n<p>上述配置文件中对应的实体类如下：</p>\\n<pre><code class=\\\"lang-java\\\">@Data\\n@ToString\\npublic class UserInfo {\\n    private String name;\\n    private Integer age;\\n    private Boolean active;\\n    private Map&lt;String,Object&gt; map;\\n    private Date createdDate;\\n    private List&lt;String&gt; hobbies;\\n}\\n</code></pre>\\n<p>结构很简单，无非就是<code>key=value</code>这种形式，也是在开发中用的比较多的一种格式。</p>\\n<h2 id=\\\"h2-yml-\\\"><a name=\\\"YML格式简介\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>YML格式简介</h2><p>以空格的缩进程度来控制层级关系。空格的个数并不重要，只要左边空格对齐则视为同一个层级。注意不能用<code>tab</code>代替空格。且大小写敏感。支持字面值，对象，数组三种数据结构，也支持复合结构。</p>\\n<p><strong>字面值</strong>：字符串，布尔类型，数值，日期。字符串默认不加引号，单引号会转义特殊字符。日期格式支持<code>yyyy/MM/dd HH:mm:ss</code></p>\\n<p><strong>对象</strong>：由键值对组成，形如 key:(空格)value 的数据组成。冒号后面的空格是必须要有的，每组键值对占用一行，且缩进的程度要一致，也可以使用行内写法：<code>{k1: v1, ....kn: vn}</code></p>\\n<p><strong>数组</strong>：由形如 -(空格)value 的数据组成。短横线后面的空格是必须要有的，每组数据占用一行，且缩进的程度要一致，也可以使用行内写法：<code>[1,2,...n]</code></p>\\n<p><strong>复合结构</strong>：上面三种数据结构任意组合</p>\\n<h3 id=\\\"h3-u5982u4F55u4F7Fu7528\\\"><a name=\\\"如何使用\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>如何使用</h3><p>在<code>src/resources</code>文件夹下创建一个<code>application.yml</code>文件。支持的类型主要有字符串，带特殊字符的字符串，布尔类型，数值，集合，行内集合，行内对象，集合对象这几种常用的数据格式。</p>\\n<p>具体的示例如下：</p>\\n<pre><code class=\\\"lang-yml\\\">userinfo:\\n    age: 25\\n    name: myjszl\\n    active: true\\n    created-date: 2018/03/31 16:54:30\\n    map: {k1: v1,k2: v2}\\n    hobbies:\\n      - one\\n      - two\\n      - three\\n</code></pre>\\n<p>上述配置文件对应的实体类如下：</p>\\n<pre><code class=\\\"lang-java\\\">@Data\\n@ToString\\npublic class UserInfo {\\n    private String name;\\n    private Integer age;\\n    private Boolean active;\\n    private Map&lt;String,Object&gt; map;\\n    private Date createdDate;\\n    private List&lt;String&gt; hobbies;\\n}\\n</code></pre>\\n<h3 id=\\\"h3-u603Bu7ED3\\\"><a name=\\\"总结\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>总结</h3><p>YML是一种新式的格式，层级鲜明，个人比较喜欢使用的一种格式，注意如下：</p>\\n<ol>\\n<li><strong>字符串可以不加引号，若加双引号则输出特殊字符，若不加或加单引号则转义特殊字符</strong></li><li><strong>数组类型，短横线后面要有空格；对象类型，冒号后面要有空格</strong></li><li><strong>YAML是以空格缩进的程度来控制层级关系，但不能用tab键代替空格，大小写敏感</strong></li></ol>\\n<h2 id=\\\"h2--\\\"><a name=\\\"如何从配置文件取值？\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>如何从配置文件取值？</h2><p>一切的配置都是为了取值，Spring Boot也是提供了几种取值的方式，下面一一介绍。</p>\\n<h3 id=\\\"h3--configurationproperties\\\"><a name=\\\"@ConfigurationProperties\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span><a href=\\\"https://github.com/ConfigurationProperties\\\" title=\\\"&#64;ConfigurationProperties\\\" class=\\\"at-link\\\">@ConfigurationProperties</a></h3><p>这个注解用于从配置文件中取值，支持复杂的数据类型，但是不支持<code>SPEL</code>表达式。</p>\\n<p>该注解中有一个属性<code>prefix</code>，用于指定获配置的前缀，毕竟配置文件中的属性很多，也有很多重名的，必须用一个前缀来区分下。</p>\\n<p><strong>该注解可以标注在类上也可以标注在方法上，这也注定了它有两种获取值的方式。</strong></p>\\n<h4 id=\\\"h4-1-\\\"><a name=\\\"1. 标注在实体类上\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>1. 标注在实体类上</h4><p>这种方式用于从实体类上取值，并且赋值到对应的属性。使用如下：</p>\\n<pre><code class=\\\"lang-java\\\">/**\\n * @Component ：注入到IOC容器中\\n * @ConfigurationProperties：从配置文件中读取文件\\n */\\n@Component\\n@ConfigurationProperties(prefix = &quot;userinfo&quot;)\\n@Data\\n@ToString\\npublic class UserInfo {\\n    private String name;\\n    private Integer age;\\n    private Boolean active;\\n    private Map&lt;String,Object&gt; map;\\n    private Date createdDate;\\n    private List&lt;String&gt; hobbies;\\n}\\n</code></pre>\\n<h4 id=\\\"h4-u6807u6CE8u5728u914Du7F6Eu7C7Bu4E2Du7684u65B9u6CD5u4E0A\\\"><a name=\\\"标注在配置类中的方法上\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>标注在配置类中的方法上</h4><p>标注在配置类上的方法上，同样是从配置文件中取值赋值到返回值的属性中。使用如下：</p>\\n<pre><code class=\\\"lang-java\\\">    /**\\n     * @Bean : 将返回的结果注入到IOC容器中\\n     * @ConfigurationProperties ：从配置文件中取值\\n     * @return\\n     */\\n    @ConfigurationProperties(prefix = &quot;userinfo&quot;)\\n    @Bean\\n    public UserInfo userInfo(){\\n        return new UserInfo();\\n    }\\n</code></pre>\\n<h4 id=\\\"h4-u603Bu7ED3\\\"><a name=\\\"总结\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>总结</h4><p><code><a href=\\\"https://github.com/ConfigurationProperties\\\" title=\\\"&#64;ConfigurationProperties\\\" class=\\\"at-link\\\">@ConfigurationProperties</a></code>注解能够很轻松的从配置文件中取值，优点如下：</p>\\n<ol>\\n<li>支持批量的注入属性，只需要指定一个前缀<code>prefix</code></li><li>支持复杂的数据类型，比如<code>List</code>、<code>Map</code></li><li>对属性名匹配的要求较低，比如<code>user-name</code>，<code>user_name</code>，<code>userName</code>，<code>USER_NAME</code>都可以取值</li><li>支持JAVA的JSR303数据校验</li></ol>\\n<p><strong>注意：<code><a href=\\\"https://github.com/ConfigurationProperties\\\" title=\\\"&#64;ConfigurationProperties\\\" class=\\\"at-link\\\">@ConfigurationProperties</a></code>这个注解仅仅是支持从Spring Boot的默认配置文件中取值，比如<code>application.properties</code>、<code>application.yml</code>。</strong></p>\\n<h3 id=\\\"h3--value\\\"><a name=\\\"@Value\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span><a href=\\\"https://github.com/Value\\\" title=\\\"&#64;Value\\\" class=\\\"at-link\\\">@Value</a></h3><p><code><a href=\\\"https://github.com/Value\\\" title=\\\"&#64;Value\\\" class=\\\"at-link\\\">@Value</a></code>这个注解估计很熟悉了，Spring中从属性取值的注解，支持<code>SPEL</code>表达式，不支持复杂的数据类型，比如<code>List</code>。使用如下：</p>\\n<pre><code class=\\\"lang-java\\\">    @Value(&quot;${userinfo.name}&quot;)\\n    private String UserName;\\n</code></pre>\\n<h2 id=\\\"h2--\\\"><a name=\\\"如何从自定义配置文件中取值？\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>如何从自定义配置文件中取值？</h2><p>Spring Boot在启动的时候会自动加载<code>application.xxx</code>和<code>bootsrap.xxx</code>，但是为了区分，有时候需要自定义一个配置文件，那么如何从自定义的配置文件中取值呢？此时就需要配合<code><a href=\\\"https://github.com/PropertySource\\\" title=\\\"&#64;PropertySource\\\" class=\\\"at-link\\\">@PropertySource</a></code>这个注解使用了。</p>\\n<p>只需要在配置类上标注<code><a href=\\\"https://github.com/PropertySource\\\" title=\\\"&#64;PropertySource\\\" class=\\\"at-link\\\">@PropertySource</a></code>并指定你自定义的配置文件即可完成。如下：</p>\\n<pre><code class=\\\"lang-java\\\">@SpringBootApplication\\n@PropertySource(value = {&quot;classpath:custom.properties&quot;})\\npublic class DemoApplication {\\n</code></pre>\\n<p><strong><code>value</code>属性是一个数组，可以指定多个配置文件同时引入。</strong></p>\\n<p><strong><code><a href=\\\"https://github.com/PropertySource\\\" title=\\\"&#64;PropertySource\\\" class=\\\"at-link\\\">@PropertySource</a></code>默认加载<code>xxx.properties</code>类型的配置文件，不能加载<code>YML</code>格式的配置文件，怎么破？？？</strong></p>\\n<h3 id=\\\"h3--yml-\\\"><a name=\\\"如何加载自定义YML格式的配置文件？\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>如何加载自定义YML格式的配置文件？</h3><p><code><a href=\\\"https://github.com/PropertySource\\\" title=\\\"&#64;PropertySource\\\" class=\\\"at-link\\\">@PropertySource</a></code>注解有一个属性<code>factory</code>，默认值是<code>PropertySourceFactory.class</code>，这个就是用来加载<code>properties</code>格式的配置文件，我们可以自定义一个用来加载<code>YML</code>格式的配置文件，如下：</p>\\n<pre><code class=\\\"lang-java\\\">import org.springframework.beans.factory.config.YamlPropertiesFactoryBean;\\nimport org.springframework.core.env.PropertiesPropertySource;\\nimport org.springframework.core.env.PropertySource;\\nimport org.springframework.core.io.support.DefaultPropertySourceFactory;\\nimport org.springframework.core.io.support.EncodedResource;\\n\\nimport java.io.IOException;\\nimport java.util.Properties;\\n\\npublic class YmlConfigFactory extends DefaultPropertySourceFactory {\\n    @Override\\n    public PropertySource&lt;?&gt; createPropertySource(String name, EncodedResource resource) throws IOException {\\n        String sourceName = name != null ? name : resource.getResource().getFilename();\\n        if (!resource.getResource().exists()) {\\n            return new PropertiesPropertySource(sourceName, new Properties());\\n        } else if (sourceName.endsWith(&quot;.yml&quot;) || sourceName.endsWith(&quot;.yaml&quot;)) {\\n            Properties propertiesFromYaml = loadYml(resource);\\n            return new PropertiesPropertySource(sourceName, propertiesFromYaml);\\n        } else {\\n            return super.createPropertySource(name, resource);\\n        }\\n    }\\n\\n    private Properties loadYml(EncodedResource resource) throws IOException {\\n        YamlPropertiesFactoryBean factory = new YamlPropertiesFactoryBean();\\n        factory.setResources(resource.getResource());\\n        factory.afterPropertiesSet();\\n        return factory.getObject();\\n    }\\n\\n}\\n</code></pre>\\n<p>此时只需要将<code>factory</code>属性指定为<code>YmlConfigFactory</code>即可，如下：</p>\\n<pre><code class=\\\"lang-java\\\">@SpringBootApplication\\n@PropertySource(value = {&quot;classpath:custom.yml&quot;},factory = YmlConfigFactory.class)\\npublic class DemoApplication {\\n</code></pre>\\n<h3 id=\\\"h3-u603Bu7ED3\\\"><a name=\\\"总结\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>总结</h3><p><code><a href=\\\"https://github.com/PropertySource\\\" title=\\\"&#64;PropertySource\\\" class=\\\"at-link\\\">@PropertySource</a></code>指定加载自定义的配置文件，默认只能加载<code>properties</code>格式，但是可以指定<code>factory</code>属性来加载<code>YML</code>格式的配置文件。</p>\\n<h2 id=\\\"h2-u603Bu7ED3\\\"><a name=\\\"总结\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>总结</h2><p>以上内容介绍了Spring Boot中的配置文件的语法以及如何从配置文件中取值，这个内容很重要，作者也是尽可能讲的通俗易懂，希望读者能够有所收获。</p>\\n<p>好了，肝了两个多小时，每一篇文章都是作者精心原创制作，读者朋友们的每一个点赞分享都是对我莫大的支持，谢谢！！！<br><img src=\\\"https://gitee.com/chenjiabing666/Blog-file/raw/master/myjszl_log.png\\\" alt=\\\"\\\"></p>\\n\",\"createTime\":1646570835054,\"describe\":\"Spring Boot 第二弹，配置文件怎么造？\",\"flag\":1,\"id\":9,\"imgUrl\":\"https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%BC%98%E8%B4%A8%E8%A7%86%E9%A2%91%E8%B5%84%E6%BA%90/1.png\",\"isAppreciate\":1,\"isComment\":1,\"isExplain\":1,\"isRecommend\":1,\"source\":1,\"status\":2,\"title\":\"Spring Boot 第二弹，配置文件怎么造？\",\"typeId\":2,\"updateTime\":1646570835054,\"viewNum\":0}', '2022-03-06 20:47:15', '2022-03-06 20:48:13', 2, 'article_exchange', NULL, 'article_key', 2);
INSERT INTO `mq_msg` VALUES (13, '{\"articleId\":\"552955802348945408\",\"authorId\":\"94dd9d02befd4dac9d6e708ff92f7d82\",\"content\":\"<h3 id=\\\"h3--\\\"><a name=\\\"持续原创输出,点击上方蓝字关注我\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>持续原创输出,点击上方蓝字关注我</h3><p><img src=\\\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%AF%E5%8A%A8%E5%99%A8/2.jpeg\\\" alt=\\\"\\\"></p>\\n<h3 id=\\\"h3-u76EEu5F55\\\"><a name=\\\"目录\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>目录</h3><ul>\\n<li>前言</li><li>如何自定义一个starter？<ul>\\n<li>准备自己的自动配置类</li><li>将自动配置类设置在spring.factories</li><li>如何指定自动配置类的执行顺序？<ul>\\n<li>分享一个经典的误区</li><li>源码分析自动配置类如何排序？</li></ul>\\n</li><li>总结<h2 id=\\\"h2-u524Du8A00\\\"><a name=\\\"前言\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>前言</h2>日常工作中对于<code>Spring Boot</code> 提供的一些启动器可能已经足够使用了，但是不可避免的需要自定义启动器，比如整合一个陌生的组件，也想要达到开箱即用的效果。</li></ul>\\n</li></ul>\\n<p>在上一章节从底层源码介绍了<code>Spring Boot</code> 的自动配置的原理，未读过的朋友建议看一下：<a href=\\\"https://mp.weixin.qq.com/s/cEBvxQ4iDo3QOMYWvwE6nw\\\">Spring Boot 自动配置源码解析</a></p>\\n<p>这篇文章将会介绍如何自定义一个启动器，同时对于自动配置类的执行顺序做一个详细的分析。</p>\\n<h2 id=\\\"h2--starter-\\\"><a name=\\\"如何自定义一个starter？\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>如何自定义一个starter？</h2><p>启动器的核心其实就是自动配置类，在自动配置源码分析的章节已经介绍过，<code>AutoConfigurationImportSelector</code>是从<code>spring.factories</code>中加载自动配置类，因此只需要将自定义的自动配置类设置在该文件中即可。</p>\\n<p>读过源码的朋友都知道自动配置类常用的一些注解，总结如下：</p>\\n<ol>\\n<li><code><a href=\\\"https://github.com/Configuration\\\" title=\\\"&#64;Configuration\\\" class=\\\"at-link\\\">@Configuration</a></code>： 该注解标志这是一个配置类，<strong>自动配置类可以不加该注解</strong>。</li><li><code><a href=\\\"https://github.com/EnableConfigurationProperties\\\" title=\\\"&#64;EnableConfigurationProperties\\\" class=\\\"at-link\\\">@EnableConfigurationProperties</a></code>：这个配置也是经常使用了，使得指定的属性配置生效。一般自动配置类都需要从全局属性配置中读取自定义的配置，这就是一个开关。</li><li><code><a href=\\\"https://github.com/ConditionalOnXxxx\\\" title=\\\"&#64;ConditionalOnXxxx\\\" class=\\\"at-link\\\">@ConditionalOnXxxx</a></code>：该注解是自动配置类的核心了，自动配置类既要启动时自动配置，又要保证用户用户自定义的配置覆盖掉自动配置，该注解就是一个条件语句，只有当指定条件成立才会执行某操作。不理解的，请看作者前面的一篇文章：<a href=\\\"https://mp.weixin.qq.com/s/BoujdCIHPK79jT9RKAmyug\\\">这类注解都不知道，还说用过Spring Boot~</a></li><li><code><a href=\\\"https://github.com/AutoConfigureAfter\\\" title=\\\"&#64;AutoConfigureAfter\\\" class=\\\"at-link\\\">@AutoConfigureAfter</a></code>：指定自动配置类的执行先后顺序，下文详细介绍。</li><li><code><a href=\\\"https://github.com/AutoConfigureBefore\\\" title=\\\"&#64;AutoConfigureBefore\\\" class=\\\"at-link\\\">@AutoConfigureBefore</a></code>：指定自动配置列的执行先后顺序，下文详细介绍。</li><li><code><a href=\\\"https://github.com/AutoConfigureOrder\\\" title=\\\"&#64;AutoConfigureOrder\\\" class=\\\"at-link\\\">@AutoConfigureOrder</a></code>：指定自动配置类的优先级，下文详细介绍。</li></ol>\\n<p>有了以上准备，自定义一个<code>starter</code>非常简单，分为两个步骤。</p>\\n<h3 id=\\\"h3-1-\\\"><a name=\\\"1. 准备自己的自动配置类\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>1. 准备自己的自动配置类</h3><p>启动器的灵魂核心就是自动配置类，因此需要首先创建一个自动配置类，如下：</p>\\n<pre><code class=\\\"lang-java\\\">@Configuration\\n@AutoConfigureAfter(DataSourceAutoConfiguration.class)\\n@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE+5)\\n@ConditionalOnProperty(prefix = &quot;my.auto&quot;,name = &quot;enabled&quot;,havingValue = &quot;true&quot;,matchIfMissing = true)\\npublic class MyCustomAutoConfiguration {\\n\\n}\\n</code></pre>\\n<p>以上自动配置类只是作者简单的按照格式随手写了一个，真实开发中需要根据启动器的业务做默认配置。</p>\\n<h3 id=\\\"h3-2-spring-factories\\\"><a name=\\\"2. 将自动配置类设置在spring.factories\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>2. 将自动配置类设置在spring.factories</h3><p>标注了<code><a href=\\\"https://github.com/Configuration\\\" title=\\\"&#64;Configuration\\\" class=\\\"at-link\\\">@Configuration</a></code>注解的自动配置类如果不放在<code>spring.factories</code>文件中，仅仅是一个普通的配置类而已。想要其成为自动配置类，需要在<code>spring.factories</code>文件中设置，如下：</p>\\n<pre><code class=\\\"lang-java\\\"># Auto Configure\\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\\\\ncom.example.autoconfig.MyCustomAutoConfiguration\\n</code></pre>\\n<p>经过以上的配置，粗略的启动器完成了，只需要打包，然后<code>Maven</code>引入即可工作。</p>\\n<h2 id=\\\"h2--\\\"><a name=\\\"如何指定自动配置类的执行顺序？\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>如何指定自动配置类的执行顺序？</h2><p>自动配置类需要定义执行顺序吗？答案：肯定的。比如<code>Mybatis</code>的自动配置类，肯定要在数据源的自动配置类之后执行，否则如何创建<code>SqlSessionFactory</code>？</p>\\n<p>如何自定义自动配置类的执行顺序呢？此时就需要用到上文提到的三个注解，如下：</p>\\n<ol>\\n<li><code><a href=\\\"https://github.com/AutoConfigureAfter\\\" title=\\\"&#64;AutoConfigureAfter\\\" class=\\\"at-link\\\">@AutoConfigureAfter</a></code>： 当前配置类在指定配置类之后执行</li><li><code><a href=\\\"https://github.com/AutoConfigureBefore\\\" title=\\\"&#64;AutoConfigureBefore\\\" class=\\\"at-link\\\">@AutoConfigureBefore</a></code>： 当前配置类在指定配置类之前执行</li><li><code><a href=\\\"https://github.com/AutoConfigureOrder\\\" title=\\\"&#64;AutoConfigureOrder\\\" class=\\\"at-link\\\">@AutoConfigureOrder</a></code>：指定优先级，数值越小，优先级越高。</li></ol>\\n<h3 id=\\\"h3-u5206u4EABu4E00u4E2Au7ECFu5178u7684u8BEFu533A\\\"><a name=\\\"分享一个经典的误区\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>分享一个经典的误区</h3><p>对于<code>Spring Boot</code>不是很了解的人写出的代码真是<strong>不堪入目</strong>，曾经看过有人在<strong>普通的配置类</strong>上使用<code><a href=\\\"https://github.com/AutoConfigurexxx\\\" title=\\\"&#64;AutoConfigurexxx\\\" class=\\\"at-link\\\">@AutoConfigurexxx</a></code>注解，如下；</p>\\n<pre><code class=\\\"lang-java\\\">@Configuration\\n@AutoConfigureBefore(Config2.class)\\npublic class Config1{}\\n\\n@Configuration\\npublic class Config2{}\\n</code></pre>\\n<p>是不是感觉很爽，原来还能这么指定配置类的执行顺序…..（此处省略一万字）</p>\\n<blockquote>\\n<p>可能有时候走了狗屎运给你一种错觉还真的配置成功了。实际上这种方式是不可行的，以上三个注解只有针对自动配置类才会生效。</p>\\n</blockquote>\\n<h3 id=\\\"h3--\\\"><a name=\\\"源码分析自动配置类如何排序？\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>源码分析自动配置类如何排序？</h3><p>其实关键的代码还是在<code>AutoConfigurationImportSelector</code>中，将自动配置类从<code>spring.factories</code>加载出来之后会根据条件排序，在<code>selectImports()</code>方法中最后一行代码如下：</p>\\n<pre><code class=\\\"lang-java\\\">return sortAutoConfigurations(processedConfigurations, getAutoConfigurationMetadata()).stream()\\n                    .map((importClassName) -&gt; new Entry(this.entries.get(importClassName), importClassName))\\n                    .collect(Collectors.toList());\\n</code></pre>\\n<p>上面的代码则是将排序好的自动配置类返回，跟进代码，发现最终的实现都在<code>AutoConfigurationSorter.getInPriorityOrder()</code>方法中，逻辑如下图：</p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%AF%E5%8A%A8%E5%99%A8/1.png\\\" alt=\\\"\\\"></p>\\n<p>具体的流程如上图，排序也是按照先后顺序，如下：</p>\\n<ol>\\n<li>先按照字母排序</li><li>按照<code><a href=\\\"https://github.com/AutoConfigureOrder\\\" title=\\\"&#64;AutoConfigureOrder\\\" class=\\\"at-link\\\">@AutoConfigureOrder</a></code>优先级排序</li><li>最终按照<code><a href=\\\"https://github.com/AutoConfigureAfter\\\" title=\\\"&#64;AutoConfigureAfter\\\" class=\\\"at-link\\\">@AutoConfigureAfter</a></code>、<code><a href=\\\"https://github.com/AutoConfigureBefore\\\" title=\\\"&#64;AutoConfigureBefore\\\" class=\\\"at-link\\\">@AutoConfigureBefore</a></code>排序</li></ol>\\n<blockquote>\\n<p>从上面配置的顺序可以知道，最终决定权还是在<code><a href=\\\"https://github.com/AutoConfigureAfter\\\" title=\\\"&#64;AutoConfigureAfter\\\" class=\\\"at-link\\\">@AutoConfigureAfter</a></code>、<code><a href=\\\"https://github.com/AutoConfigureBefore\\\" title=\\\"&#64;AutoConfigureBefore\\\" class=\\\"at-link\\\">@AutoConfigureBefore</a></code>这两个注解。</p>\\n</blockquote>\\n<h2 id=\\\"h2-u603Bu7ED3\\\"><a name=\\\"总结\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>总结</h2><p>本文介绍了如何自定义一个启动器以及指定自动配置类的执行顺序，通过作者的介绍，希望读者们能够理解并灵活运用。</p>\\n<p>另外作者的第一本<code>PDF</code>书籍已经整理好了，由浅入深的详细介绍了Mybatis基础以及底层源码，有需要的朋友公众号回复关键词<strong>Mybatis进阶</strong>即可获取，目录如下：</p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E8%BF%9B%E9%98%B6PDF/2.png\\\" alt=\\\"\\\"></p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png\\\" alt=\\\"\\\"></p>\\n\",\"createTime\":1646570936702,\"describe\":\"Spring Boot 第二十三弹，自定义启动器\",\"flag\":1,\"id\":10,\"imgUrl\":\"https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%BC%98%E8%B4%A8%E8%A7%86%E9%A2%91%E8%B5%84%E6%BA%90/1.png\",\"isAppreciate\":1,\"isComment\":1,\"isExplain\":1,\"isRecommend\":1,\"source\":1,\"status\":2,\"title\":\"Spring Boot 第二十三弹，自定义启动器\",\"typeId\":2,\"updateTime\":1646570936702,\"viewNum\":0}', '2022-03-06 20:48:57', '2022-03-06 20:49:54', 2, 'article_exchange', NULL, 'article_key', 2);
INSERT INTO `mq_msg` VALUES (14, '{\"articleId\":\"552956006712213504\",\"authorId\":\"94dd9d02befd4dac9d6e708ff92f7d82\",\"content\":\"<h2 id=\\\"h2--\\\"><a name=\\\"持续原创输出，点击上方蓝字关注我\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>持续原创输出，点击上方蓝字关注我</h2><p><img src=\\\"https://gitee.com/chenjiabing666/Blog-file/raw/master/Spring%20Boot%E7%AC%AC%E5%85%AB%E5%BC%B9%EF%BC%8C%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8/2.jpeg\\\" alt=\\\"\\\"></p>\\n<h2 id=\\\"h2-u76EEu5F55\\\"><a name=\\\"目录\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>目录</h2><ul>\\n<li>前言</li><li>Spring Boot 版本</li><li>全局统一异常处理的前世今生</li><li>Spring Boot的异常如何分类？</li><li>如何统一异常处理？</li><li>异常匹配的顺序是什么？</li><li>总结</li></ul>\\n<h2 id=\\\"h2-u524Du8A00\\\"><a name=\\\"前言\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>前言</h2><p>软件开发过程中难免遇到各种的BUG，各种的异常，一直就是在解决异常的路上永不停歇，如果你的代码中再出现<code>try(){...}catch(){...}finally{...}</code>代码块，你还有心情看下去吗？自己不觉得恶心吗？</p>\\n<p>冗余的代码往往回丧失写代码的动力，每天搬砖似的写代码，真的很难受。今天这篇文章教你如何去掉满屏的<code>try(){...}catch(){...}finally{...}</code>，解放你的双手。</p>\\n<h2 id=\\\"h2-spring-boot-\\\"><a name=\\\"Spring Boot 版本\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>Spring Boot 版本</h2><p>本文基于的Spring Boot的版本是<code>2.3.4.RELEASE</code>。</p>\\n<h2 id=\\\"h2-u5168u5C40u7EDFu4E00u5F02u5E38u5904u7406u7684u524Du4E16u4ECAu751F\\\"><a name=\\\"全局统一异常处理的前世今生\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>全局统一异常处理的前世今生</h2><p>早在<code>Spring 3.x</code>就已经提出了<code><a href=\\\"https://github.com/ControllerAdvice\\\" title=\\\"&#64;ControllerAdvice\\\" class=\\\"at-link\\\">@ControllerAdvice</a></code>，可以与<code><a href=\\\"https://github.com/ExceptionHandler\\\" title=\\\"&#64;ExceptionHandler\\\" class=\\\"at-link\\\">@ExceptionHandler</a></code>、<code><a href=\\\"https://github.com/InitBinder\\\" title=\\\"&#64;InitBinder\\\" class=\\\"at-link\\\">@InitBinder</a></code>、<code><a href=\\\"https://github.com/ModelAttribute\\\" title=\\\"&#64;ModelAttribute\\\" class=\\\"at-link\\\">@ModelAttribute</a></code> 等注解注解配套使用，这几个此处就不再详细解释了。</p>\\n<p>这几个注解小眼一瞟只有<code><a href=\\\"https://github.com/ExceptionHandler\\\" title=\\\"&#64;ExceptionHandler\\\" class=\\\"at-link\\\">@ExceptionHandler</a></code>与异常有关啊，翻译过来就是<code>异常处理器</code>。<strong>其实异常的处理可以分为两类，分别是<code>局部异常处理</code>和<code>全局异常处理</code></strong>。</p>\\n<p><strong><code>局部异常处理</code></strong>：<code><a href=\\\"https://github.com/ExceptionHandler\\\" title=\\\"&#64;ExceptionHandler\\\" class=\\\"at-link\\\">@ExceptionHandler</a></code>和<code><a href=\\\"https://github.com/Controller\\\" title=\\\"&#64;Controller\\\" class=\\\"at-link\\\">@Controller</a></code>注解搭配使用，只有指定的controller层出现了异常才会被<code><a href=\\\"https://github.com/ExceptionHandler\\\" title=\\\"&#64;ExceptionHandler\\\" class=\\\"at-link\\\">@ExceptionHandler</a></code>捕获到，实际生产中怕是有成百上千个controller了吧，显然这种方式不合适。</p>\\n<p><strong><code>全局异常处理</code></strong>：既然局部异常处理不合适了，自然有人站出来解决问题了，于是就有了<code><a href=\\\"https://github.com/ControllerAdvice\\\" title=\\\"&#64;ControllerAdvice\\\" class=\\\"at-link\\\">@ControllerAdvice</a></code>这个注解的横空出世了，<code><a href=\\\"https://github.com/ControllerAdvice\\\" title=\\\"&#64;ControllerAdvice\\\" class=\\\"at-link\\\">@ControllerAdvice</a></code>搭配<code><a href=\\\"https://github.com/ExceptionHandler\\\" title=\\\"&#64;ExceptionHandler\\\" class=\\\"at-link\\\">@ExceptionHandler</a></code>彻底解决了全局统一异常处理。当然后面还出现了<code><a href=\\\"https://github.com/RestControllerAdvice\\\" title=\\\"&#64;RestControllerAdvice\\\" class=\\\"at-link\\\">@RestControllerAdvice</a></code>这个注解，其实就是<code><a href=\\\"https://github.com/ControllerAdvice\\\" title=\\\"&#64;ControllerAdvice\\\" class=\\\"at-link\\\">@ControllerAdvice</a></code>和<code><a href=\\\"https://github.com/ResponseBody\\\" title=\\\"&#64;ResponseBody\\\" class=\\\"at-link\\\">@ResponseBody</a></code>结晶。</p>\\n<h2 id=\\\"h2-spring-boot-\\\"><a name=\\\"Spring Boot的异常如何分类？\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>Spring Boot的异常如何分类？</h2><p>Java中的异常就很多，更别说Spring Boot中的异常了，这里不再根据传统意义上Java的异常进行分类了，而是按照<code>controller</code>进行分类，分为<code>进入controller前的异常</code>和<code>业务层的异常</code>，如下图：</p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/Blog-file/raw/master/Spring%20Boot%E7%AC%AC%E5%85%AB%E5%BC%B9%EF%BC%8C%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8/1.png\\\" alt=\\\"\\\"></p>\\n<p>进入controller之前异常一般是<code>javax.servlet.ServletException</code>类型的异常，因此在全局异常处理的时候需要统一处理。几个常见的异常如下：</p>\\n<ol>\\n<li><code>NoHandlerFoundException</code>：客户端的请求没有找到对应的controller，将会抛出<code>404</code>异常。</li><li><code>HttpRequestMethodNotSupportedException</code>：若匹配到了（匹配结果是一个列表，不同的是http方法不同，如：Get、Post等），则尝试将请求的http方法与列表的控制器做匹配，若没有对应http方法的控制器，则抛该异常</li><li><code>HttpMediaTypeNotSupportedException</code>：然后再对请求头与控制器支持的做比较，比如<code>content-type</code>请求头，若控制器的参数签名包含注解<code><a href=\\\"https://github.com/RequestBody\\\" title=\\\"&#64;RequestBody\\\" class=\\\"at-link\\\">@RequestBody</a></code>，但是请求的<code>content-type</code>请求头的值没有包含<code>application/json</code>，那么会抛该异常（当然，不止这种情况会抛这个异常）</li><li><code>MissingPathVariableException</code>：未检测到路径参数。比如url为：/user/{userId}，参数签名包含<code><a href=\\\"https://github.com/PathVariable\\\" title=\\\"&#64;PathVariable\\\" class=\\\"at-link\\\">@PathVariable</a>(&quot;userId&quot;)</code>，当请求的url为/user，在没有明确定义url为/user的情况下，会被判定为：缺少路径参数</li></ol>\\n<h2 id=\\\"h2--\\\"><a name=\\\"如何统一异常处理？\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>如何统一异常处理？</h2><p>在统一异常处理之前其实还有许多东西需要优化的，比如统一结果返回的形式。当然这里不再细说了，不属于本文范畴。</p>\\n<p><strong>统一异常处理很简单，这里以前后端分离的项目为例，步骤如下</strong>：</p>\\n<ol>\\n<li>新建一个统一异常处理的一个类</li><li>类上标注<code><a href=\\\"https://github.com/RestControllerAdvice\\\" title=\\\"&#64;RestControllerAdvice\\\" class=\\\"at-link\\\">@RestControllerAdvice</a></code>这一个注解，或者同时标注<code><a href=\\\"https://github.com/ControllerAdvice\\\" title=\\\"&#64;ControllerAdvice\\\" class=\\\"at-link\\\">@ControllerAdvice</a></code>和<code><a href=\\\"https://github.com/ResponseBody\\\" title=\\\"&#64;ResponseBody\\\" class=\\\"at-link\\\">@ResponseBody</a></code>这两个注解。</li><li>在方法上标注<code><a href=\\\"https://github.com/ExceptionHandler\\\" title=\\\"&#64;ExceptionHandler\\\" class=\\\"at-link\\\">@ExceptionHandler</a></code>注解，并且指定需要捕获的异常，可以同时捕获多个。</li></ol>\\n<p>下面是作者随便配置一个demo，如下：</p>\\n<pre><code class=\\\"lang-java\\\">/**\\n * 全局统一的异常处理，简单的配置下，根据自己的业务要求详细配置\\n */\\n@RestControllerAdvice\\n@Slf4j\\npublic class GlobalExceptionHandler {\\n\\n\\n    /**\\n     * 重复请求的异常\\n     * @param ex\\n     * @return\\n     */\\n    @ExceptionHandler(RepeatSubmitException.class)\\n    public ResultResponse onException(RepeatSubmitException ex){\\n        //打印日志\\n        log.error(ex.getMessage());\\n        //todo 日志入库等等操作\\n\\n        //统一结果返回\\n        return new ResultResponse(ResultCodeEnum.CODE_NOT_REPEAT_SUBMIT);\\n    }\\n\\n\\n    /**\\n     * 自定义的业务上的异常\\n     */\\n    @ExceptionHandler(ServiceException.class)\\n    public ResultResponse onException(ServiceException ex){\\n        //打印日志\\n        log.error(ex.getMessage());\\n        //todo 日志入库等等操作\\n\\n        //统一结果返回\\n        return new ResultResponse(ResultCodeEnum.CODE_SERVICE_FAIL);\\n    }\\n\\n\\n    /**\\n     * 捕获一些进入controller之前的异常，有些4xx的状态码统一设置为200\\n     * @param ex\\n     * @return\\n     */\\n    @ExceptionHandler({HttpRequestMethodNotSupportedException.class,\\n            HttpMediaTypeNotSupportedException.class, HttpMediaTypeNotAcceptableException.class,\\n            MissingPathVariableException.class, MissingServletRequestParameterException.class,\\n            ServletRequestBindingException.class, ConversionNotSupportedException.class,\\n            TypeMismatchException.class, HttpMessageNotReadableException.class,\\n            HttpMessageNotWritableException.class,\\n            MissingServletRequestPartException.class, BindException.class,\\n            NoHandlerFoundException.class, AsyncRequestTimeoutException.class})\\n    public ResultResponse onException(Exception ex){\\n        //打印日志\\n        log.error(ex.getMessage());\\n        //todo 日志入库等等操作\\n\\n        //统一结果返回\\n        return new ResultResponse(ResultCodeEnum.CODE_FAIL);\\n    }\\n}\\n</code></pre>\\n<p><strong>注意</strong>：<strong>上面的只是一个例子，实际开发中还有许多的异常需要捕获，比如<code>TOKEN失效</code>、<code>过期</code>等等异常，如果整合了其他的框架，还要注意这些框架抛出的异常，比如<code>Shiro</code>，<code>Spring Security</code>等等框架。</strong></p>\\n<h2 id=\\\"h2--\\\"><a name=\\\"异常匹配的顺序是什么？\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>异常匹配的顺序是什么？</h2><p>有些朋友可能疑惑了，如果我同时捕获了父类和子类，那么到底能够被那个异常处理器捕获呢？比如<code>Exception</code>和<code>ServiceException</code>。<br><img src=\\\"https://gitee.com/chenjiabing666/Blog-file/raw/master/Spring%20Boot%E7%AC%AC%E5%85%AB%E5%BC%B9%EF%BC%8C%E5%A6%82%E4%BD%95%E6%89%A9%E5%B1%95%E5%85%A8%E9%9D%A2%E6%8E%A5%E5%8F%A3MVC/1.jpg\\\" alt=\\\"\\\"></p>\\n<p>此时可能就疑惑了，<strong>这里先揭晓一下答案，当然是<code>ServiceException</code>的异常处理器捕获了，精确匹配，如果没有<code>ServiceException</code>的异常处理器才会轮到它的<code>父亲</code>，<code>父亲</code>没有才会到<code>祖父</code>。总之一句话，精准匹配，找那个关系最近的。</strong></p>\\n<p>为什么呢？这可不是凭空瞎说的，源码为证，出处<code>org.springframework.web.method.annotation.ExceptionHandlerMethodResolver#getMappedMethod</code>，如下：</p>\\n<pre><code class=\\\"lang-java\\\">@Nullable\\n    private Method getMappedMethod(Class&lt;? extends Throwable&gt; exceptionType) {\\n        List&lt;Class&lt;? extends Throwable&gt;&gt; matches = new ArrayList&lt;&gt;();\\n    //遍历异常处理器中定义的异常类型\\n        for (Class&lt;? extends Throwable&gt; mappedException : this.mappedMethods.keySet()) {\\n      //是否是抛出异常的父类，如果是添加到集合中\\n            if (mappedException.isAssignableFrom(exceptionType)) {    \\n        //添加到集合中\\n                matches.add(mappedException);  \\n            }\\n        }\\n    //如果集合不为空，则按照规则进行排序\\n        if (!matches.isEmpty()) {\\n            matches.sort(new ExceptionDepthComparator(exceptionType));\\n      //取第一个\\n            return this.mappedMethods.get(matches.get(0));\\n        }\\n        else {\\n            return null;\\n        }\\n    }\\n</code></pre>\\n<p><strong>在初次异常处理的时候会执行上述的代码找到最匹配的那个异常处理器方法，后续都是直接从缓存中（一个<code>Map</code>结构，<code>key</code>是异常类型，<code>value</code>是异常处理器方法）。</strong></p>\\n<p>别着急，上面代码最精华的地方就是对<code>matches</code>进行排序的代码了，我们来看看<code>ExceptionDepthComparator</code>这个比较器的关键代码，如下：</p>\\n<pre><code class=\\\"lang-java\\\">//递归调用，获取深度，depth值越小越精准匹配\\nprivate int getDepth(Class&lt;?&gt; declaredException, Class&lt;?&gt; exceptionToMatch, int depth) {\\n    //如果匹配了，返回\\n        if (exceptionToMatch.equals(declaredException)) {\\n            // Found it!\\n            return depth;\\n        }\\n        // 递归结束的条件，最大限度了\\n        if (exceptionToMatch == Throwable.class) {\\n            return Integer.MAX_VALUE;\\n        }\\n    //继续匹配父类\\n        return getDepth(declaredException, exceptionToMatch.getSuperclass(), depth + 1);\\n    }\\n</code></pre>\\n<p><strong>精髓全在这里了，一个递归搞定，计算深度，<code>depth</code>初始值为0。值越小，匹配度越高越精准。</strong></p>\\n<h2 id=\\\"h2-u603Bu7ED3\\\"><a name=\\\"总结\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>总结</h2><p>全局异常的文章万万千，能够讲清楚的能有几篇呢？<strong>只出最精的文章，做最野的程序员</strong>，如果觉得不错的，关注分享走一波，谢谢支持！！！</p>\\n<p><strong>另外作者的第一本PDF书籍已经整理好了，由浅入深的详细介绍了Mybatis基础以及底层源码，有需要的朋友公众号回复关键词<code>Mybatis进阶</code>即可获取，目录如下：</strong></p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E8%BF%9B%E9%98%B6PDF/2.png\\\" alt=\\\"\\\"></p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/Blog-file/raw/master/myjszl_log.png\\\" alt=\\\"\\\"></p>\\n\",\"createTime\":1646570985426,\"describe\":\"Spring Boot第九弹，满屏的try-catch，你不瘆得慌？\",\"flag\":1,\"id\":11,\"imgUrl\":\"https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%BC%98%E8%B4%A8%E8%A7%86%E9%A2%91%E8%B5%84%E6%BA%90/1.png\",\"isAppreciate\":0,\"isComment\":1,\"isExplain\":1,\"isRecommend\":1,\"source\":1,\"status\":2,\"title\":\"Spring Boot第九弹，满屏的try-catch，你不瘆得慌？\",\"typeId\":2,\"updateTime\":1646570985426,\"viewNum\":0}', '2022-03-06 20:49:45', '2022-03-06 20:50:43', 2, 'article_exchange', NULL, 'article_key', 2);
INSERT INTO `mq_msg` VALUES (15, '{\"articleId\":\"552956313429082112\",\"authorId\":\"94dd9d02befd4dac9d6e708ff92f7d82\",\"content\":\"<h2 id=\\\"h2--\\\"><a name=\\\"持续原创输出，点击上方蓝字关注我\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>持续原创输出，点击上方蓝字关注我</h2><p><img src=\\\"https://gitee.com/chenjiabing666/Blog-file/raw/master/Spring%20Boot%E7%AC%AC%E4%B8%83%E5%BC%B9%EF%BC%8C%E8%BF%87%E6%BB%A4%E5%99%A8%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE/3.jpeg\\\" alt=\\\"\\\"></p>\\n<h2 id=\\\"h2-u76EEu5F55\\\"><a name=\\\"目录\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>目录</h2><ul>\\n<li>前言</li><li>Spring Boot 版本</li><li>什么是过滤器？</li><li>Filter的执行原理</li><li>如何自定义一个Filter？</li><li>Spring Boot如何配置Filter？<ul>\\n<li>配置类中使用<a href=\\\"https://github.com/Bean\\\" title=\\\"&#64;Bean\\\" class=\\\"at-link\\\"><a href=\\\"https://github.com/Bean\\\" title=\\\"&#64;Bean\\\" class=\\\"at-link\\\">@Bean</a></a>注入【推荐使用】</li><li>使用<a href=\\\"https://github.com/WebFilter\\\" title=\\\"&#64;WebFilter\\\" class=\\\"at-link\\\"><a href=\\\"https://github.com/WebFilter\\\" title=\\\"&#64;WebFilter\\\" class=\\\"at-link\\\">@WebFilter</a></a></li></ul>\\n</li><li>举个栗子</li><li>总结</li></ul>\\n<h2 id=\\\"h2-u524Du8A00\\\"><a name=\\\"前言\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>前言</h2><p>上篇文章介绍了Spring Boot中如何配置拦截器，今天这篇文章就来讲讲类似于拦截器的一个组件：过滤器。</p>\\n<p>其实在实际开发中过滤器真的接触的不多，但是在应用中却是不可或缺的角色，值得花费一个章节专门介绍一下。</p>\\n<h2 id=\\\"h2-spring-boot-\\\"><a name=\\\"Spring Boot 版本\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>Spring Boot 版本</h2><p>本文基于的Spring Boot的版本是<code>2.3.4.RELEASE</code>。</p>\\n<h2 id=\\\"h2--\\\"><a name=\\\"什么是过滤器？\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>什么是过滤器？</h2><p><code>Filter</code>也称之为过滤器，它是Servlet技术中最实用的技术，WEB开发人员通过Filter技术，对web服务器管理的所有web资源：例如JSP，Servlet，静态图片文件或静态HTML文件进行拦截，从而实现一些特殊功能。例如实现<code>URL级别的权限控制</code>、<code>过滤敏感词汇</code>、<code>压缩响应信息</code>等一些高级功能。</p>\\n<h2 id=\\\"h2-filter-\\\"><a name=\\\"Filter的执行原理\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>Filter的执行原理</h2><p>当客户端发出Web资源的请求时，Web服务器根据应用程序配置文件设置的过滤规则进行检查，若客户请求满足过滤规则，则对客户请求／响应进行拦截，对请求头和请求数据进行检查或改动，并依次通过过滤器链，最后把请求／响应交给请求的Web资源处理。请求信息在过滤器链中可以被修改，也可以根据条件让请求不发往资源处理器，并直接向客户机发回一个响应。当资源处理器完成了对资源的处理后，响应信息将逐级逆向返回。同样在这个过程中，用户可以修改响应信息，从而完成一定的任务，如下图：</p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/Blog-file/raw/master/Spring%20Boot%E7%AC%AC%E4%B8%83%E5%BC%B9%EF%BC%8C%E8%BF%87%E6%BB%A4%E5%99%A8%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE/1.png\\\" alt=\\\"\\\"></p>\\n<p>服务器会按照过滤器定义的先后循序组装成<code>一条链</code>，然后一次执行其中的<code>doFilter()</code>方法。（注：这一点<code>Filter</code>和<code>Servlet</code>是不一样的）执行的顺序就如下图所示，执行第一个过滤器的<code>chain.doFilter()</code>之前的代码，第二个过滤器的<code>chain.doFilter()</code>之前的代码，请求的资源，第二个过滤器的<code>chain.doFilter()</code>之后的代码，第一个过滤器的<code>chain.doFilter()</code>之后的代码，最后返回响应。</p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/Blog-file/raw/master/Spring%20Boot%E7%AC%AC%E4%B8%83%E5%BC%B9%EF%BC%8C%E8%BF%87%E6%BB%A4%E5%99%A8%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE/2.jpg\\\" alt=\\\"\\\"></p>\\n<h2 id=\\\"h2--filter-\\\"><a name=\\\"如何自定义一个Filter？\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>如何自定义一个Filter？</h2><p>这个问题其实不是Spring Boot这个章节应该介绍的了，在Spring MVC中就应该会的内容，只需要实现<code>javax.servlet.Filter</code>这个接口，重写其中的方法。实例如下：</p>\\n<pre><code class=\\\"lang-java\\\">@Component\\npublic class CrosFilter implements Filter {\\n\\n    //重写其中的doFilter方法\\n    @Override\\n    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {\\n        //继续执行下一个过滤器\\n        chain.doFilter(req, response);\\n    }\\n</code></pre>\\n<h2 id=\\\"h2-spring-boot-filter-\\\"><a name=\\\"Spring Boot如何配置Filter？\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>Spring Boot如何配置Filter？</h2><p>自定义好了过滤器当然要使其在Spring Boot中生效了，Spring Boot配置Filter有两种方式，其实都很简单，下面一一介绍。</p>\\n<h3 id=\\\"h3--bean-\\\"><a name=\\\"配置类中使用@Bean注入【推荐使用】\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>配置类中使用<a href=\\\"https://github.com/Bean\\\" title=\\\"&#64;Bean\\\" class=\\\"at-link\\\">@Bean</a>注入【推荐使用】</h3><p>其实很简单，只需要将<code>FilterRegistrationBean</code>这个实例注入到IOC容器中即可，如下：</p>\\n<pre><code class=\\\"lang-java\\\">@Configuration\\npublic class FilterConfig {\\n    @Autowired\\n    private Filter1 filter1;\\n\\n    @Autowired\\n    private Filter2 filter2;\\n\\n\\n    /**\\n     * 注入Filter1\\n     * @return\\n     */\\n    @Bean\\n    public FilterRegistrationBean filter1() {\\n        FilterRegistrationBean registration = new FilterRegistrationBean();\\n        registration.setFilter(filter1);\\n        registration.addUrlPatterns(&quot;/*&quot;);\\n        registration.setName(&quot;filter1&quot;);\\n        //设置优先级别\\n        registration.setOrder(1);\\n        return registration;\\n    }\\n\\n    /**\\n     * 注入Filter2\\n     * @return\\n     */\\n    @Bean\\n    public FilterRegistrationBean filter2() {\\n        FilterRegistrationBean registration = new FilterRegistrationBean();\\n        registration.setFilter(filter2);\\n        registration.addUrlPatterns(&quot;/*&quot;);\\n        registration.setName(&quot;filter2&quot;);\\n        //设置优先级别\\n        registration.setOrder(2);\\n        return registration;\\n    }\\n}\\n</code></pre>\\n<p><strong>注意：设置的优先级别决定了过滤器的执行顺序。</strong></p>\\n<h3 id=\\\"h3--webfilter\\\"><a name=\\\"使用@WebFilter\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>使用<a href=\\\"https://github.com/WebFilter\\\" title=\\\"&#64;WebFilter\\\" class=\\\"at-link\\\">@WebFilter</a></h3><p><code><a href=\\\"https://github.com/WebFilter\\\" title=\\\"&#64;WebFilter\\\" class=\\\"at-link\\\">@WebFilter</a></code>是Servlet3.0的一个注解，用于标注一个Filter，Spring Boot也是支持这种方式，只需要在自定义的Filter上标注该注解即可，如下：</p>\\n<pre><code class=\\\"lang-java\\\">@WebFilter(filterName = &quot;crosFilter&quot;,urlPatterns = {&quot;/*&quot;})\\npublic class CrosFilter implements Filter {\\n\\n    //重写其中的doFilter方法\\n    @Override\\n    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {\\n        //继续执行下一个过滤器\\n        chain.doFilter(req, response);\\n    }\\n}\\n</code></pre>\\n<p><strong>要想<code><a href=\\\"https://github.com/WebFilter\\\" title=\\\"&#64;WebFilter\\\" class=\\\"at-link\\\">@WebFilter</a></code>注解生效，需要在配置类上标注另外一个注解<code><a href=\\\"https://github.com/ServletComponentScan\\\" title=\\\"&#64;ServletComponentScan\\\" class=\\\"at-link\\\">@ServletComponentScan</a></code>用于扫描使其生效</strong>，如下：</p>\\n<pre><code class=\\\"lang-java\\\">@SpringBootApplication\\n@ServletComponentScan(value = {&quot;com.example.springbootintercept.filter&quot;})\\npublic class SpringbootApplication {}\\n</code></pre>\\n<p>至此，配置就完成了，启动项目，即可正常运行。</p>\\n<h2 id=\\\"h2-u4E3Eu4E2Au6817u5B50\\\"><a name=\\\"举个栗子\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>举个栗子</h2><p>对于前后端分离的项目来说跨域是一个难题，什么是跨域问题？如何造成的？这个不是本章的重点。</p>\\n<p>对于跨域问题有多中解决方案，比如JSONP，网关支持等等。<strong>关于跨域的问题以及Spring Boot如何优雅的解决跨域问题？将会在后续文章中介绍</strong>。今天主要介绍如何使用过滤器来解决跨域问题。</p>\\n<p>其实原理很简单，只需要在请求头中添加相应支持跨域的内容即可，如下代码仅仅是简单的演示下，针对细致的内容还需自己完善，比如白名单等等。</p>\\n<pre><code class=\\\"lang-java\\\">@Component\\npublic class CrosFilter implements Filter {\\n\\n    //重写其中的doFilter方法\\n    @Override\\n    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {\\n        HttpServletResponse response = (HttpServletResponse) res;\\n        response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);\\n        response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);\\n        response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, DELETE&quot;);\\n        response.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;);\\n        response.setHeader(&quot;Access-Control-Allow-Headers&quot;,&quot; Origin, X-Requested-With, Content-Type, Accept&quot;);\\n        //继续执行下一个过滤器\\n        chain.doFilter(req, response);\\n    }\\n}\\n</code></pre>\\n<p>配置类中注入<code>FilterRegistrationBean</code>，如下代码：</p>\\n<pre><code class=\\\"lang-java\\\">@Configuration\\npublic class FilterConfig {\\n    @Autowired\\n    private CrosFilter crosFilter;\\n\\n    /**\\n     * 注入crosFilter\\n     * @return\\n     */\\n    @Bean\\n    public FilterRegistrationBean crosFilter() {\\n        FilterRegistrationBean registration = new FilterRegistrationBean();\\n        registration.setFilter(crosFilter);\\n        registration.addUrlPatterns(&quot;/*&quot;);\\n        registration.setName(&quot;crosFilter&quot;);\\n        //设置优先级别\\n        registration.setOrder(Ordered.HIGHEST_PRECEDENCE);\\n        return registration;\\n    }\\n}\\n</code></pre>\\n<p>至此，配置完成，相关细致功能还需自己润色。</p>\\n<h2 id=\\\"h2-u603Bu7ED3\\\"><a name=\\\"总结\\\" class=\\\"reference-link\\\"></a><span class=\\\"header-link octicon octicon-link\\\"></span>总结</h2><p>过滤器内容相对简单些，但是在实际开发中不可或缺，比如常用的权限控制框架<code>Shiro</code>，<code>Spring Security</code>，内部都是使用过滤器，了解一下对以后的深入学习有着固本的作用。</p>\\n<p><strong>另外作者的第一本PDF书籍已经整理好了，由浅入深的详细介绍了Mybatis基础以及底层源码，有需要的朋友公众号回复关键词<code>Mybatis进阶</code>即可获取，目录如下：</strong></p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E8%BF%9B%E9%98%B6PDF/2.png\\\" alt=\\\"\\\"></p>\\n<p>如果有所收获，不妨关注在看支持一下，持续连载中…..</p>\\n<p><img src=\\\"https://gitee.com/chenjiabing666/Blog-file/raw/master/myjszl_log.png\\\" alt=\\\"\\\"></p>\\n\",\"createTime\":1646571058553,\"describe\":\"Spring Boot第七弹，过滤器如何配置，一波梭哈~\",\"flag\":1,\"id\":12,\"imgUrl\":\"https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%BC%98%E8%B4%A8%E8%A7%86%E9%A2%91%E8%B5%84%E6%BA%90/1.png\",\"isAppreciate\":1,\"isComment\":1,\"isExplain\":1,\"isRecommend\":0,\"source\":1,\"status\":2,\"title\":\"Spring Boot第七弹，过滤器如何配置，一波梭哈~\",\"typeId\":2,\"updateTime\":1646571058553,\"viewNum\":0}', '2022-03-06 20:50:59', '2022-03-06 20:51:56', 2, 'article_exchange', NULL, 'article_key', 2);

-- ----------------------------
-- Table structure for type
-- ----------------------------
DROP TABLE IF EXISTS `type`;
CREATE TABLE `type`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime(0) NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP(0) COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 11 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '分类表' ROW_FORMAT = Compact;

-- ----------------------------
-- Records of type
-- ----------------------------
INSERT INTO `type` VALUES (2, 'Spring Boot', '2022-01-14 09:09:00', '2022-01-14 09:09:04');
INSERT INTO `type` VALUES (3, 'Spring Cloud', '2022-01-14 09:09:00', '2022-01-15 23:39:53');
INSERT INTO `type` VALUES (7, 'Mybatis', '2022-02-15 11:02:07', '2022-02-15 11:02:07');
INSERT INTO `type` VALUES (8, 'Mybatis', '2022-02-15 11:02:22', '2022-02-15 11:02:22');
INSERT INTO `type` VALUES (9, 'Mybatis', '2022-02-15 11:05:38', '2022-02-15 11:05:38');
INSERT INTO `type` VALUES (10, 'Mybatis', '2022-02-15 11:05:43', '2022-02-15 11:05:43');

-- ----------------------------
-- Table structure for undo_log
-- ----------------------------
DROP TABLE IF EXISTS `undo_log`;
CREATE TABLE `undo_log`  (
  `branch_id` bigint(20) NOT NULL COMMENT 'branch transaction id',
  `xid` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT 'global transaction id',
  `context` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT 'undo_log context,such as serialization',
  `rollback_info` longblob NOT NULL COMMENT 'rollback info',
  `log_status` int(11) NOT NULL COMMENT '0:normal status,1:defense status',
  `log_created` datetime(6) NOT NULL COMMENT 'create datetime',
  `log_modified` datetime(6) NOT NULL COMMENT 'modify datetime',
  UNIQUE INDEX `ux_undo_log`(`xid`, `branch_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = 'AT transaction mode undo table' ROW_FORMAT = Compact;

SET FOREIGN_KEY_CHECKS = 1;
